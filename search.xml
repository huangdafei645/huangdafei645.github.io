<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022年终总结</title>
    <url>/posts/1ff43dbc.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="2022年终总结"><a href="#2022年终总结" class="headerlink" title="2022年终总结"></a>2022年终总结</h1><p>author: Jerry</p>
<h2 id="2022新闻"><a href="#2022新闻" class="headerlink" title="2022新闻"></a>2022新闻</h2><p>这一年，<br>一月，迎接新生命；<br>二月，冬季奥林匹克运动会开幕、女足夺得第20届亚足联女子亚洲杯冠军；<br>三月，俄乌战争充斥头条、港股步入金融海啸；<br>四月，上海之声；</p>
<span id="more"></span>

<p>五月，2023年亚足联亚洲杯异地举办；<br>六月，中国神舟十四号载人飞船发射、唐山暴力攻击事件；<br>七月，河南村镇银行取款难、安倍晋三遇刺身亡；<br>八月，佩洛西访台激民愤；<br>九月，涉疫隔离转运客车～侧翻事故；<br>十月，新班子走马、上任。<br>十一月，凡凡压火、卡塔尔世界杯拉开帷幕。<br>十二月，ChatGPT、新十条、通行码下线、羊羊羊。</p>
<p>2022年， 是不平凡的一年， 感觉时间过的好快， 让我不禁感慨， 我们到底是活了365天， 还是活了一天。然后重复了364次</p>
<p>学到的一些技术：</p>
<p>我是非常喜欢学习新技术的，而且每天都喜欢看新闻， 看看国内外的哪些地方发生了什么有趣的事？</p>
<p>比如说chatgpt的发布， 当时不温不火的，但是就是在那么短短的几天，各大社交平台， 各位业界大佬， 都对于这个chatgpt给予了非常高的评价， 包括马斯克， 今年收购了twitter， 并进行了很大程度的改造，也有人形象地将这件事比喻为公牛闯进了瓷器店， 哈哈哈真的是非常形象地比喻</p>
<p>这一年， 我养成了听播客的习惯， 总是喜欢走在路上的时候， 洗澡的时候， 吃饭的时候，甚至坐车的时候都开始听播客， 听播客的时候， 就好像是和其中的主持人面对面的交谈， 那种下午清闲宁静的时候， 是不是正好能用来听播客呢？</p>
<p>2022年底的那几天， 我感染了新冠肺炎， 哦不， 现在应该叫新冠感染了。这个病毒放倒了我身边的好多人，都是清一色的症状。先发烧， 腰酸背痛， 四肢乏力；第二天还是发烧， 咳嗽， 流鼻涕，嗓子疼；第三天会好受一点， 到了第四天， 那种难受的感觉基本就是好了，2022年12月27号那一天，我新冠痊愈。但是后来看到消息， 说是我们得的新冠在痊愈之后如果不好好休整的话， 那么就会落下病根，换句话说就是新冠后遗症，身体不能剧烈运动， 不能抽烟，不能喝酒。说是得多一个多月身体才能慢慢恢复</p>
<p>2022，这一年过的很快， 2022看的技术类的书：<br>《vue3.js设计与实现》<br>《javascript忍者秘籍》<br>《你不知道的javascript》<br>《前端工程师面试题库》</p>
<p>自己在大学的时候也是学习了专业课《数据结构和算法》，哪些东西觉得枯燥无聊， 学的话得需要大神去带， 大二的时候确定方向， 开始主攻前端。</p>
<p>除此之外还总结了好多的面试题，但是我上次电脑出了点问题并没有来得及备份， 导致内容丢失， 是真的难受<br>零零散散的也看了好多github上面的优秀的项目，大多都是在一个微信公众号：HelloGithub上面看到的， 作者把一些好用的项目总结了一下，我觉得质量可以说是非常高<br>就目前的情况来看， javascript是一门非常火的语言， 但是js的奇葩问题也多，所以我也正在尝试去用typescript， typescript被普遍适用于一些大项目，通常配套react和vue3来进行开发，以后还是得自己尽量的去练习， 去真正的掌握这门语言</p>
<p>我有拍照的习惯， 去记录那生活中那些美好的一瞬间，真正的灵感真的是一瞬间爆发的，去观察， 去捕捉那短暂的， 值得记录的一瞬间，这样拍出的照片才是真正的有感觉， 那些脖子跨个照相机， 翻来覆去找东西拍的人反而拍不出感觉， 这个我本人的对于拍照的一点点小小的看法</p>
<p>喜欢B站的一个博主， 叫“刘老师说电影”，是我非常喜欢的一个哔哩哔哩的一个博主， 主要就是电影赏析， 而且我发现， 自己的价值观和它的好像， 这就导致他的作品我真的是每期都看， 各种各样的电影， 刘老师帮我筛查了一些好电影， 一些不好的。真的是非常的不错，非常喜欢他的影评，做成视频，因为语速快并且诙谐幽默， 导致我每期都会看他。比如他写的这个关于周杰伦的《不能说的秘密》的影评， 真的是让我看了一遍又一遍，里面剖析了很多的细节，阿宝和阿郎给阿论的涂写笔， 故事开头提到的学校要拆掉的琴房， 还有之前小雨被别人看不见的细节， 都是需要重复观看才能发现的：比如剧中的台词：我能遇见你， 已经是很不可思议了；还有小雨所说的那个秘密：从琴房到教室， 一共108步。我们第一遍看的时候确实是看不懂， 但是听刘老师讲过一遍后， 茅塞顿开， 再一次感慨这部神作，哪些铺垫， 双关，细节至今历历在目。杰伦真的是一个拥有极高艺术审美的天才。当然我也是正宗的杰伦粉， 写这段话的时候，我正在听着杰伦的《手写的从前》，除去我的粉丝滤镜， 我也是非常喜欢杰伦， 希望能给大家带来更多更好的作品， 是不是有点太自私了， 杰伦粉不要攻击我哦哈哈哈。</p>
<p>还有B站的一个博主也很有意思，叫：小Lin说。非常喜欢这个博主， 也很喜欢她的创作风格，每期视频都含有很大的信息量，每次看完都能够学到不少的东西。她主要普及的是金融学的知识， 贯穿生活的各个方面， 每次听完之后都是感觉：哇塞， 还能这样啊！很形象， 很有用。比如咖啡烘培的知识，咖啡的来历啥的，都是我非常喜欢的科普知识， 大家有兴趣可以去听听。反正我是非常喜欢的， 在这里也是推荐给大家哈哈</p>
<p>这一年， 也有让人感动的一幕， 我的爷爷50年代的人， 现在七十多岁， 和他老人家相处也让我的生活变得多姿多彩， 记得以前在外面的时候， 每周无论多忙， 都不能忘给他老人家打个电话， 一般打电话都是在晚上， 记得打过去的话， 如果我当时不忙， 聊天可以达到两个小时， 那个场面， 那一声声真切的问候， 那是50后和00后没有代沟的彻夜长谈， 其实类似这样的场面还是有很多次的， 举个例子：当我早上和爷爷见面时， 爷孙俩几乎就同时问：“饭吃了吗？”，然后又同时回答：“吃了”；这个时候， 又不约而同的笑了起来<br>脑海中突然浮现出了一个画面：爷爷拿着指甲刀，为奶奶修剪指甲；<br>奶奶70多岁， 患有脑梗，手脚活动也就会变得不是那么自然， 拿个筷子手都会颤抖的那种。想起了寻梦环游记中的那个片段：</p>
<p><a href="https://www.bilibili.com/video/BV1zW411H7Wz/">寻梦环游记</a>，千言万语涌上心头， 但是不知道怎么表达， 最后化成滴滴泪水荡漾在眼角，Remember me<br>我想说的话，纸和笔都装不下， 去年看的一个哔哩哔哩上面的视频：世界再大，勿忘回家 。每次看的时候都有不同的感悟，这是真正的好作品<a href="https://www.bilibili.com/video/BV1vM4y1N79U/?spm_id_from=333.337.search-card.all.click">世界再大，勿忘回家</a></p>
<p>用光头强的口吻描述打工人的辛苦， 人人都笑光头强，人人都是光头强</p>
<p>这一年， 我还培养了听播客的兴趣：<br>我个人比较喜欢的几个播客有：<br>《声东击西》<br>《余生皆假期》该播客的主持人是一个很特别的女孩：早见Hayami<br>《捕蛇者说》<br>《不明白》<br>《developer tea》<br>《牛油果烤面包》<br>《代码时间》<br>《teahour》<br>《大话前端｜细说前端方方面面》<br>《web worker-前端程序员们的闲聊》</p>
<p>对于人工智能的新一代，chatgpt：我觉得他是有里程碑意义的，想想以后人工智能成为下一次工业革命的主角， 好多人失去工作。你可以使用chatgpt写信， 写年终总结，各种各样的东西，人工智能真的是一个非常棒的东西。<br>玩的还比较多的又一个discord的midjourney，是一个非常好用的绘画AI，绘画效果很亮眼，我真的非常喜欢。</p>
<p><a href="https://beta.character.ai/?iss=https://character-ai.us.auth0.com/">AI合集</a></p>
<p>这是一个AI汇总的网站，里面你可以选择不同风格的这些个AI，效果也是非常的不错，AI就像是你的一个私人助手， 但是功能确实要比siri这些强大的多，人工智能的热度自从chatGPT出现后在github只增不减，很喜欢三体中的技术爆炸一词，技术爆炸真的是一个链式反应， 从互联网刚出现到现在也只不过几十年，这短短的几十年出现了移动支付， 人工智能，也就是说：不同的国家之间也会发生技术爆炸，我随时可能发生技术爆炸， 一下子远远的走在你的前面， 鸦片战争就是活生生的一个例子，还在师夷蛮技以制夷，这就是我们的老祖宗闹出的笑话， 都被人家打败了， 还在嘲笑人家。几千年了， 还是老样子<br>看了《未来史记》中对于未来人工智能的幻想， 那个时候真的是有种现代科技的味道， 比如在观察肿瘤的过程中，使用人工智能的识别准确率会高于一个经验丰富的医生</p>
<p>自己也是学了很多感兴趣的东西：<br>一直对嵌入式技术挺感兴趣的，但是毕竟是感兴趣， 可不敢上面花费太多时间， 因为自己是学前端的， 也算是一个可以糊口的职业<br>想去的地方：<br>珠穆朗玛峰：只想去那边看看， 玩玩， 但是不敢有登山的想法， 自己非常清楚那将会非常的危险<br>西藏， 青海：西藏是一片净土， 想夏天去玩玩，青海我觉得也是一个非常不错的地方， 很适合去旅行<br>四川九寨沟：听说秋天的九寨沟景色优美， 以后想带上自己的家人驾车去游玩<br>泰山： 前几天感染新冠， 就和朋友闲聊， 提到了登泰山， 以后有机会的话， 肯定带上自己的家人登上泰山， 然后等到第二天日出的时候， 提前找好角度， 拍下那值得记录的一幕，登泰山估计也不是什么难事<br>加拿大的温哥华： 一个美丽的边远小城，我想去的地方好多呀， 如果能有这样的一个地方去度假是真的舒服， 窗外大雪纷飞， 你坐在里面烤着壁炉，这真的是非常欢欣开心的事， 事实上， 今年还没有下过一场像样的雪<br>自己去过的地方好少，每天就是无休止的重复， 唯一让我觉得开心的就是学到了新的技术， 还有读到的好书，发现然后记录的那些美好的瞬间，明年自己应该会增加运动的时间， 给自己一个更好的身体，这次的病毒把自己确实是折腾的不轻<br>新的一年，当然也会结交更多的有趣的朋友， 也很高兴自己能找到志同道合的朋友，这些朋友给予你欢乐， 感动， 知识， 情谊， 安慰。和你无话不谈，我们需要这样的朋友</p>
<p>和药学的一个朋友讨论， 对于目前新冠，我的认知是现在治疗发烧最好的药是布洛芬和对乙酰， 这是目前最管用的， 老百姓最能承受的药了， 但是他的回答显得我很幼稚， 很呆， 他告诉我：药商在接到一个药方如果要大批量生产的话， 要考虑以下几个方面：药的药效， 药的安全性， 药的成本，药的材料成本等等等。接着我们的话题转到了哪种药药效最好，他说了一句：“真正好的药方要么是成本高， 要么就是药商不赚钱， 药商会把药的成本和效果控制到一个很好的水准， 就是我的药吃不死你， 但是还能让你感到有效果，要是直接治好你， 我还怎么赚钱？”听完后， 觉得大受震撼。</p>
<h2 id="2022我都学到了什么？"><a href="#2022我都学到了什么？" class="headerlink" title="2022我都学到了什么？"></a>2022我都学到了什么？</h2><p>看完的书：</p>
<ol>
<li><p>《三体》全集</p>
</li>
<li><p>《三体》英文版全集</p>
</li>
<li><p>《海鸟的哭泣：人们看不到的鸟类爱情与生活》</p>
</li>
<li><p>《寻美》</p>
</li>
<li><p>《未来史记》</p>
</li>
<li><p>《掌控力： 让所有人对你讲真话》</p>
</li>
<li><p>《美丽新世界》</p>
</li>
<li><p>《影响一生的旅行计划： 中国最美的100个地方》</p>
</li>
<li><p>《中国文化十万个为什么》</p>
</li>
<li><p>《营销笔记》</p>
</li>
<li><p>《反内耗：如何化解我们内心的冲突》</p>
</li>
<li><p>《极客物理学： 地球上最有趣的问题和出人意料的答案》</p>
</li>
<li><p>《你的灯亮着吗》</p>
</li>
<li><p>《效率脑科学》</p>
<h2 id="2022看的电影"><a href="#2022看的电影" class="headerlink" title="2022看的电影"></a>2022看的电影</h2><ol>
<li><p>《不能说的秘密》</p>
</li>
<li><p>《盲井》</p>
</li>
<li><p>《盲山》</p>
</li>
<li><p>《盲道》</p>
</li>
<li><p>《猫和老鼠》</p>
</li>
<li><p>《名侦探柯南： 绯红的子弹》</p>
</li>
<li><p>《肖申克的救赎》连续五年每年至少看一次</p>
</li>
<li><p>《当幸福来敲门》和朋友一块看的，看一遍有一遍的感觉，真的与众不同</p>
</li>
</ol>
<h3 id="2022培养的兴趣爱好"><a href="#2022培养的兴趣爱好" class="headerlink" title="2022培养的兴趣爱好"></a>2022培养的兴趣爱好</h3><ol>
<li>听音乐：自己在敲代码时经常喜欢听音乐， 尤其是听周杰伦， 不知道是为什么， 那种音乐会让我的心静下来， 专心去做现在正在专注的事情， 我的网易云用户名是鱼酱爱吃喵</li>
<li>跑步：我跑步主要就是为了锻炼身体， 春天到夏天的时候， 我经常是在早晨7点钟左右去跑步，但是到了冬天， 白天的时间变得特别短， 我更倾向于吃完晚饭去公园散散步， 散步的时候听听音乐， 呼吸那新鲜的空气</li>
<li>看新闻： 每天早上醒来， 会一直看看今天有什么新鲜的事情， 我从来不玩抖音， 快手， 小红书哪些，微博之前还玩， 但是最后由于weibo环境越来越恶劣， 最后放弃了，国内软件现在就玩一个bilibili，微信也是关注了好多的技术公众号，看看哪些号主发一些新奇的技术和玩意， 我是非常喜欢逛github的， 我觉得新鲜的东西我大脑潜意识理解为新闻， 我看的更多的就是今天前端界出现了什么新鲜的东西， 发生了什么有趣的东西， 我是受阮一峰老师的影响也是开始写这个的， 但是我在之前， 就一直有记日记和随笔的习惯， 把自己喜欢的， 生活中有趣的片段记下来， 这样才能让乏味的生活变得多姿多彩</li>
<li>弹吉他： 去年买了一个吉他， 我喜欢音乐， 喜欢它的节奏感， 给我带来的轻松与欢乐， 由于疫情的原因， 导致我已经有好几个月没有玩过吉他了， 我每天都听音乐， 已经产生了依赖， 音乐已经成为了我的生活的一部分， 伴随我跑步， 伴随我睡觉， 甚至是工作的时候， 还有现在， 我写下这几个字的时候就在听着音乐， 很宁静，很安详。一个风和日丽的下午， 这一份独属于自己的快乐</li>
<li>敲代码： 敲代码是我的工作， 当然也是我最大的一个爱好， 从做出的第一个产品开始， 能用技术解决生活中的问题， 学以致用， 这是我最开心的， 开心并快乐的学习着， 给自己建立一个正反馈，这样自己的生活积极主动， 自然而然， 顺其自然。遇到一个问题， 享受解决他的过程， 当给同事造成困扰时，请他们喝奶茶或吃饭。 生活和工作同步进行，既积极主动， 尽力而为， 又自然而然，顺其自然。非常的开心。</li>
<li>看书： 今年看的国外的书多了， 也是对自己造成了很多思想上的变化，认识了很多书友， 自己看书一般是看个简介， 看看我对这类书有没有兴趣， 也是受到了现在的速食文化的影响， 如果感兴趣的话， 那么就开始浏览情节了， 浏览完情节后，就会对这本书的内容有了一个大致的了解。然后尝试找资料， 写观后感，看看有没有漏点的细节， 真正的好书， 都是在反复的品读后发现其中的好，好的电影也是。就好像我看的最多的一部抗战剧：《亮剑》。每一次看完都有一种不同的感觉，这是真正的经典，看书也是。</li>
<li>拍照： 我喜欢拍照， 喜欢记录生活中那些美好的瞬间，每一帧， 每一秒，每一个可爱的笑容。我可以翻翻相册， 找找那些好看的照片</li>
</ol>
</li>
</ol>
<img src="/posts/1ff43dbc/1ff43dbc/playground.jpg" class="" title="playground">

<p>日落时的球场</p>
<img src="/posts/1ff43dbc/1ff43dbc/snow2.jpg" class="" title="snow2">

<img src="/posts/1ff43dbc/1ff43dbc/snow1.jpg" class="" title="snow1">

<p>这照片都是以前朋友拍的， 上次翻相册找到的</p>
</body></html>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>2022年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年第三期</title>
    <url>/posts/dbe4379b.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="2023年第三期"><a href="#2023年第三期" class="headerlink" title="2023年第三期"></a>2023年第三期</h1><p>好久不见， 由于过年好久没更新了， 不过今天我给大家带来了很多好东西， 希望大家能喜欢</p>
<span id="more"></span>

<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol>
<li><p>2022年codepen前一百项目汇总:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://codepen.io/2022/popular/pens/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>前端开源项目推荐：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://awesomeopensource.com/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>一个效果非常不错的css库：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://codeadrian.github.io/clay.css/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>vue的hooks合集</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://vueuse.org/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>推荐一款vscode的正则表达式插件，any rules，使用起来也是非常的方便， 输入要检验的正则表达式， 马上就好跳出结果， 这个时候就可以根据自己的需要进行使用了 ， 非常方便</p>
</li>
<li><p>一些好用的论文检索地址</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1. 国家哲学社会科学文献中心 https://www.ncpssd.org</span><br><span class="line">2. Sci-hub https://sci-hub.st</span><br><span class="line">3. Pubmed https://pubmed.ncbi.nlm.nih.gov</span><br><span class="line">4. MedSci/梅斯 https://www.medsci.cn/sci</span><br><span class="line">5. MDPI/曼迪匹艾 https://www.mdpi.com</span><br><span class="line">6. OA Library https://www.oalib.com</span><br><span class="line">7. Library Genesis/创世纪图书馆 https://libgen.gs</span><br><span class="line">8. 全国图书馆参考咨询联盟 www.ucdrs.superlib.net</span><br><span class="line">9. 科研通 https://www.ablesci.com</span><br></pre></td></tr></tbody></table></figure>

<ol start="6">
<li><p>gpt3的demo,搜集gpt3的一些使用案例</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://gpt3demo.com/map</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>it Tools开发者工具：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://it-tools.tech/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>类似domToCode </p>
<p>前端开发人员使用， 点击浏览器项目的位置， 代码跳转到编辑器的对应位置</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/webfansplz/vite-plugin-vue-inspector)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>一个AI搜索神器：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://www.perplexity.ai/?s=u&amp;uuid=b2fa8536-0173-4741-a217-bd58f02d7b0f</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>chatGPT中文调教指南</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/PlexPt/awesome-chatgpt-prompts-zh</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>最近一个非常流行的react组件库：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://www.radix-ui.com/</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="趣闻"><a href="#趣闻" class="headerlink" title="趣闻"></a>趣闻</h2><p>Elementary OS 7 发布</p>
<p>基于 Ubuntu 的发行版 elementary OS释出了 v7 版本。Elementary OS 7 代号 Horus，开发者侧重的一个方面是帮助用户发现需要的应用。AppCenter 是操作系统的核心，新版本加入了更多信息让应用描述更吸引人，更容易更新到应用的最新版本，改进了侧载和第三方应用商店的支持，改进了其响应速度，改进了大显示屏的空间利用，重写了导航，支持两指滑动手势，应用加载也更快</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><strong>托</strong></p>
<p>小吃店（比如说奶茶、烤串、锅盔、臭豆腐等等）的财富密码不是要味道做得多好而是要店门口有人排队。</p>
<p>咱们说的“托”就是干的这件事，找一堆人来排队但是又不实际消费，只是让这家小店看起来很火。这样才能吸引真正的顾客来排队消费。</p>
<p>除了找托之外，还可以在这方面培训店员，比如说奶茶店，要让店员有意识地调整生产奶茶的速度。看到排队的人少就要慢慢做，延长客户停留在门口的时间，等到队伍稍长一些后就要加快速度。总之就是保持有一条长队在店门口，但又不能让客户等太久，这还是挺考验店员的水平的。</p>
<p>据我观察，有很多小吃店是深谙这个财富密码的。</p>
<p><strong>技术爆炸</strong></p>
<p>古往今来， 任何一个企业， 一个人， 一个国家的成功都是伴随着技术爆炸的实现<br>第一次工业革命<br>鸦片战争<br>德国发动第二次世界大战、<br>alibaba在互联网时代的崛起<br>技术爆炸在人与人之间同样适用<br>中国有一句古话， 叫士别三日， 当刮目相看。和技术爆炸这个概念正好对上了<br>在相同的起跑线上， 我们很长时间没有交流， 你随时可以发生技术爆炸， 一下子远远的走在我的前面， 中国的近代史就是活生生的例子<br>人与人之间也是一样， 不可以以貌取人， 人类蕴含着无限的潜能， 所以今天不代表明天， 更不会代表以后， 我对这类事深有体会<br>有很多这样的情况， 比如说我举个最通俗的例子， 我用的最早的一部手机叫诺基亚， 那时候只有打电话， 发短信的功能。 现在呢， 我们的手机已经发展成了不可分割的一部分，手机支付，听音乐， 看电影， 学习， 交流。已然成为了我们生活中的一个强力的生产工具。非常的好用方便。</p>
<p><strong>人体简史中的有趣知识</strong>（我觉得特别值得分享）</p>
<p>1.人的眼皮每天要眨14000次左右<br>2.人的心脏一辈子做的功相当于把一个1吨重的物体举高一百多KM<br>3.如果把人体内的DNA拧成一条绳，这个长度相当于从地球到冥王星的距离<br>4.发烧是人体抵抗病毒的一种形式，体温每升高1度，病毒的分裂能力相当于原来的1/200<br>5.人体每天都有1-5个细胞发生癌变，相当于你每年都有1000次左右的机会得癌症，但是你的免疫系统成功的发现并解决了这个问题<br>6.一个人每一口呼吸都能吸进一个非常庞大数量的O分子，换个角度思考，你故意的这一口空气含有秦始皇呼吸过的O分子，当然还有拿破仑<br>7.人的1立方毫米的大脑皮层能储备2000TB的东西，大于世界上所有的电子书总和，大于人类葱第一部电影到现在所有电影的总和<br>8.在一秒之间，身体已经制造了100万个红细胞。每个红细胞。都会在你身体里游荡差不多150000次，不停地向你的细胞输送氧气<br>类似的知识还有很多很多，翻开这本书，看看你的身体里藏着多少意想不到的秘密</p>
<p><strong>chatGPT的中美差距究竟有多大？</strong></p>
<p>1、一位百度资深人士：他“没有兴趣”谈论ChatGPT，言语之间，五味杂陈。<br>2、一位人工智能企业创始人：面对ChatGPT的惊艳表现，心痒痒也迷茫，失眠了。他坦承，从模型的规模到效果，差距还比较远。<br>3、国内某厂商的大模型和ChatGPT：ChatGPT从回答的逻辑性和完整度上都远超国内大模型，国内大模型的答案带有明显的拼凑感，夹杂着不少主题之外的胡编内容。而且，在回复速度上，ChatGPT也领先一截。<br>4、从事数字人研发的特看科技CEO：目前全球还没有能跟ChatGPT抗衡的大模型，业界共识是差距在两年以上。国内先不谈弯道超车，趁早追赶反而是更重要的。<br>5、虽然一些人工智能资深人士认为，在ChatGPT所涉及的技术上，中美是“平级”的，但华为诺亚方舟实验室语音语义首席科学家刘群，在黄大年茶思屋的讨论中坦承，中国在技术上还是有差距的。其中一个是基础模型本身的差距，虽然我们训练了很多万亿模型或者是几千亿的模型，但训练的充分程度，是远远不够的。“我估计到现在为止，没有哪个模型能吃GPT那么多数据。”<br>6、清华大学计算机科学与技术系长聘副教授黄民烈提到，在GPT-3之后，OpenAI所有的模型都没有开源，但它提供了API调用。在这个过程中，它干了一件事，就是建立起了真实的用户调用和模型迭代之间的飞轮，它非常重视真实世界数据的调用，以及这些数据对模型的迭代。当然，在此过程中，它也养活了美国一大帮创业公司，建立了一个生态。<br>7、“你看我们国内的大模型研究，是A公司训练了一个，B公司也训练了一个，打个广告就完了，模型开源，你爱用不用。至少目前还没看到一家比较好的公司，把数据和模型的飞轮完整转起来。所以，我觉得这是我们赶超ChatGPT的难点。”一位业内人士坦言。<br>8、业界人士都提到了算力问题。由于GPU芯片等问题，在一定程度上，国内算力已被卡脖子了。即使国内头部公司，从算力上跟谷歌等相比，差距也是比较明显的。<br>有业内人士称：从数据质量来说，整个互联网的中文数据质量，相比于英文还是有明显差距。“我们可能要想办法，做中英文不同语言之间的数据互补。”<br>9、几乎所有受访人士都提到了OpenAI这家人工智能组织，所体现的纯碎创新精神和长期主义。“其实从原理和方法看，他们所做的东西业界都是了解的，倒没有说什么是美国做得了、我们做不了的。”但像OpenAI和DeepMind，他们可能是业界唯二的两家机构，无论在创新性、投入、决心，还是在顶尖人才储备上，都是一如既往坚持的。“我们看到的是成功，但里面可能已经有很多失败的尝试。”<br>10、有资深AI从业者认为，在看不到前景和没有明显效果的阶段，OpenAI非常坚定地做了投入，相反国内倾向于在技术出现突破后，快速追随。“国内大家第一步想的是，我们现在怎么用起来，但在不能用的时候，人家就在长期投入。”</p>
</body></html>]]></content>
      <categories>
        <category>期刊</category>
      </categories>
      <tags>
        <tag>2023第三期</tag>
      </tags>
  </entry>
  <entry>
    <title>2023第一期</title>
    <url>/posts/13d6646a.html</url>
    <content><![CDATA[<html><head></head><body><p>不定期总结并发现一些好用的和值得分享的东西， 希望大家会喜欢，谢谢大家了</p>
<span id="more"></span>

<ol>
<li>一个<a href="https://uiverse.io/?ref=producthunt">UI工具库</a>，里面有各种各样的好看的一些UI设计</li>
</ol>
<img src="/posts/13d6646a/13d6646a/image-20230107125823807.png" class="" title="image-20230107125823807">

<ol start="2">
<li><a href="https://github.com/timqian/chinese-independent-blogs">中文博客列表</a></li>
</ol>
<img src="/posts/13d6646a/13d6646a/image-20230107125903131.png" class="" title="image-20230107125903131">

<ol start="3">
<li><a href="https://playgroundai.com/?ref=producthunt">playgroundAI</a>里面分享一些高质量的图片</li>
</ol>
<img src="/posts/13d6646a/13d6646a/water-bearer-smooth-soft-skin-symmetrical-soft-lighting-detailed-face-concept-art-digital-pain-775658528.png" class="" title="water-bearer-smooth-soft-skin-symmetrical-soft-lighting-detailed-face-concept-art-digital-pain-775658528">

<ol start="4">
<li><a href="https://green-wall.vercel.app/">github贡献图生成器</a></li>
</ol>
<img src="/posts/13d6646a/13d6646a/image-20230102184704062.png" class="" title="image-20230102184704062">

<ol start="5">
<li><a href="https://scrollex-docs.vercel.app/">一个超赞的滚动效果库</a></li>
</ol>
<p>​    Scrollex 可以很方便的实现各种滚动特效，React 生态。 </p>
<img src="/posts/13d6646a/13d6646a/image-20230103133217137.png" class="" title="image-20230103133217137">



<ol start="6">
<li><a href="https://windhawk.net/">风鹰</a>: 一个windows插件商店</li>
</ol>
<img src="/posts/13d6646a/13d6646a/image-20230103134231150.png" class="" title="image-20230103134231150">



<ol start="7">
<li><a href="https://jsoncrack.com/editor">json转化工具</a></li>
</ol>
<p><a href="https://github.com/AykutSarac/jsoncrack.com">repo</a>一个json转化工具， 可以把繁琐的json文档转化成非常清晰的思维导图，目前在github已经有了2w多的stars</p>
<img src="/posts/13d6646a/13d6646a/image-20230105103557084.png" class="" title="image-20230105103557084">



<ol start="8">
<li><a href="https://www.chatbcg.com/">chatBCG</a>一个自动生成PPT的工具</li>
</ol>
<p>这个工具是两位来自斯坦福大学的学生开发的，是一款AI生成PPT的工具，对于简单的PPT， 做起来还是有效果的， 它自动生成的提纲可以进行参考</p>
<p>满江红·和郭沫若同志（毛泽东，1963年）</p>
<p>小小寰球，有几个苍蝇碰壁。<br>嗡嗡叫，几声凄厉，几声抽泣。<br>蚂蚁缘槐夸大国，蚍蜉撼树谈何易。<br>正西风落叶下长安，飞鸣镝。</p>
<p>多少事，从来急；<br>天地转，光阴迫。<br>一万年太久，只争朝夕。<br>四海翻腾云水怒，五洲震荡风雷激。<br>要扫除一切害人虫，全无敌。</p>
<img src="/posts/13d6646a/13d6646a/image-20230102184936072.png" class="" title="image-20230102184936072">







<p>前几天看了刘润老师的一篇<a href="https://mp.weixin.qq.com/s/s5wcbV3MjoIzFWGEA8HNNA?from=timeline&amp;isappinstalled=0&amp;scene=2&amp;clicktime=1672722927&amp;enterid=1672722927">文章</a>：</p>
<p><strong>别轻易用自己的视角，断言别人的生活，尤其是初衷。</strong></p>
<p>太远，会“无视”。太近，会“放大”。太窄，会“诛心”。</p>
<p>也许这是为什么，大家经常在网络上说，理解万岁。</p>
<p>更重要的，不是建议别人，是建议自己。自己在网络上的态度。</p>
<p>也是站在他人的视角，尊重他人的立场和价值观。</p>
<p><a href="https://codechina.org/2023/01/chatgpt-ai-human-principle-and-limitation/">无线猴子定理与人工智能chatGPT</a></p>
<p>让一只猴子在打字机上随机地按键，当按键时间达到无穷时，几乎必然能够打出任何给定的文字，比如莎士比亚的全套著作。</p>
<img src="/posts/13d6646a/13d6646a/image-20230103132046462.png" class="" title="image-20230103132046462">

<p>语言模型可以应用在生活的很多地方，比如：</p>
<img src="/posts/13d6646a/13d6646a/image-20230103132208008.png" class="" title="image-20230103132208008">





<p><a href="https://b23.tv/F7NrLu5">鸡的头为什么这么稳定？</a></p>
<p>这是自然选择的原因，因为鸡的眼球不能像人类那样转动，为了得到稳定的视野， 进化出来的功能。</p>
<img src="/posts/13d6646a/13d6646a/image-20230103132628884.png" class="" title="image-20230103132628884">

<p>有一款产品为帕金森病人设计的防抖勺子也是这个原理</p>
<p><a href="https://mp.weixin.qq.com/s/cIMIvxQ8GouZcvXnrHR3uw">2022年中国新补充10343个物种</a></p>
<p>与2021版对比，中国生物物种名录数据库2022年新增了10343个物种及种下单元，其中节肢动物门昆虫纲新增7498个物种，动物界脊索动物门的哺乳纲、爬行纲、两栖类共新增279个物种，蛛形纲新增119个物种；植物界新增794个物种。</p>
<p>除此之外，我国作为生物多样性大国，每年还有大量新物种被发现和描述，根据《生物多样性杂志》2021年新物种专题统计结果，昆虫纲新物种发表占当年动物新物种发表总数的82%</p>
<p>下面是不周哥的一段话， 我觉得写的很好：</p>
<p>我 20 岁出头的时候，那会大家还在玩 QQ 空间，那会在 QQ 空间流行一些名人名言，但有一句直到今天我才都有印象：有些人 35 岁就死了，但 75 岁才埋。</p>
<p>现在回头看，哪需要 35，25 就够了。</p>
<p>现在认真看这句话，其实是太过于高傲，有一种从上而下的视角。</p>
<p>一个 20 岁的年轻人，刚步入社会，不论是智力还是体力都是最好的阶段，也是最容易碰见新鲜事物，所以学习起来会非常轻松。所以面对比自己年龄大的人，说你们已经死了，不学习不进步，多少有点从上而下的骄傲、我现在看我以前的同学，还在每天学习、看书非常非常少。</p>
<p>“不进步”本质上是人类基因的结果，没什么错。人类最消耗热量的器官是大脑，如果我们的老祖宗每天都在读书、进步，根本不足以支撑打猎的需求，大概率就灭绝了。</p>
<p>老六在《35岁必死》里面，写到：</p>
<p>三十五岁的死亡，有两层含义，一是施耐德老师所说的“心理死亡”，心智停滞，希望不再，知识更新和大脑活性陷于停顿，情感和心灵日趋凉薄，其后走向生理死亡的每一天，貌似虎虎生风，实则行尸走肉</p>
<p>另一种死亡，则是蜕变重生，从旧我中挣脱出来，完成心理重塑和人生重构，哪怕外界和外貌依然故我，大脑和内心已经焕然一新</p>
<p>无论哪种情况 ，横竖都是一个死</p>
<p>欧空局公布一张哈勃望远镜拍摄的螺旋星系「ESO 415-19」的照片。这个星系位于南天星座天炉座，距离地球约4.5亿光年，由于拥有超长的星系旋臂结构而归类为「Arp 特殊星系」。「ESO 415-19」的星系旋臂由恒星和气体组成，推测是星系间引力作用而形成，<a href="https://m.idai.ly/se/dfcln2">地址</a></p>
<img src="/posts/13d6646a/13d6646a/image-20230105105205945.png" class="" title="image-20230105105205945">



<p>如果大家有什么其他意见和看法，欢迎留言哦</p>
</body></html>]]></content>
      <categories>
        <category>期刊</category>
      </categories>
      <tags>
        <tag>2023第一期</tag>
      </tags>
  </entry>
  <entry>
    <title>2023第二期</title>
    <url>/posts/cc02e38c.html</url>
    <content><![CDATA[<html><head></head><body><ol>
<li>一个<a href="https://www.aicodehelper.com/">AI编程助手</a>：</li>
</ol>
<p>就个人使用体验来说， 我觉得完全可以和chatGPT一起使用， 互相参考：</p>
<span id="more"></span>

<img src="/posts/cc02e38c/cc02e38c/image-20230107185702733.png" class="" title="image-20230107185702733">

<figure class="highlight txt"><table><tbody><tr><td class="code"><pre><span class="line">https://www.aicodehelper.com/</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>一个前端优质资源<a href="https://github.com/lxchuan12/awesome-front-end/issues/1">issue</a></li>
</ol>
<p>收集前端优质资料，文章、系列文章、博客等</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/lxchuan12/awesome-front-end/issues/1</span><br></pre></td></tr></tbody></table></figure>



<ol start="3">
<li>一个收集全世界免费API的仓库：</li>
</ol>
<figure class="highlight txt"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/public-apis/public-apis</span><br></pre></td></tr></tbody></table></figure>



<ol start="4">
<li>Lama Cleaner  </li>
</ol>
<p>这是一款完全免费开源，而且没有人分辨率限制的图片去水印、修复工具：Lama Cleaner，内置了多种AI 模型构建，功能相当的齐全。可用于快速去除图像中各种水印、物品、人物、字体、等对象，并支持老照片修复、文本替换图像内容等。</p>
<figure class="highlight txt"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/Sanster/lama-cleaner</span><br></pre></td></tr></tbody></table></figure>



<ol start="5">
<li>NBlog</li>
</ol>
<p>一个前后端分离的开源博客系统，基于 Spring Boot + Vue 技术栈开发，界面清新简洁，拥有多个丰富的博客组件，自带管理后台</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/Naccl/NBlog</span><br></pre></td></tr></tbody></table></figure>



<ol start="6">
<li>Pake</li>
</ol>
<p>一个可将各种网页快速打包成 Mac App 的开源工具。相比 Electron 更加小巧易用，速度更快，同时实现了通用的快捷键透传、沉浸式窗口、拖动、打包样式兼容等特性</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/tw93/Pake</span><br></pre></td></tr></tbody></table></figure>



<ol start="7">
<li>github一些优秀的中文项目</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/GrowingGit/GitHub-Chinese-Top-Charts</span><br></pre></td></tr></tbody></table></figure>



<ol start="8">
<li>一个可扩展的UI框架</li>
</ol>
<p>web版win10</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/yuri2peter/ylui</span><br></pre></td></tr></tbody></table></figure>

<p>demo：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http://demo.ylui.yuri2.cn/?load=ylui-storage</span><br></pre></td></tr></tbody></table></figure>



<ol start="9">
<li>AI模拟人声音</li>
</ol>
<p>如果你想了解 AI 生成人声已经发展到什么地步了，可以在这里试听最新的 Valle 的 demo，只需要3秒的人声输入作为 Prompt 就可以生成同样的人声、而且不光是人声，连背景噪音都能生成，能够模拟人的情绪， 模拟人说话的环境。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">valle-demo.github.io</span><br></pre></td></tr></tbody></table></figure>







<p><strong>中国开发者喜欢star和fork</strong></p>
<p>在前10个国家触发的事件约占GitHub所有事件的23.27%。然而，来自这些国家的开发者的数量只有10%。<br>美国开发者最喜欢审查代码，PullRequestReviewEvent的份额为6.15%。<br>中国开发者喜欢给仓库加星，WatchEvent占17.23%，ForkEvent占2.7%。<br>德国开发者喜欢公开问题和评论，IssueEvent和CommentEvent分别占4.18%和12.66%。<br>韩国开发者喜欢直接推送到存储库（PushEvent）。<br>日本开发者最倾向于通过拉动请求提交代码，PullRequestEvent占10%。</p>
<p><strong>微软计划推出基于ChatGPT的必应搜索 ,该技术还可能用于word，电子邮件中</strong></p>
<p>有很多用户对chatGPT的搜索结果的准确性不太看好， 就是可能会先用chatGPT的答案进行一个参考， 得到答案后， 会去Google再核实一下， 机器人毕竟还是机器人。chatGPT的结果经常是一本正经的胡说八道， 这种情况下， chatGPT应该怎么应对呢？<br>chatGPT可能真的是人工智能界的一个里程碑， 因为这玩意儿从出来到现在热度是越来越高。微软把握这个机会肯定也是必然的。</p>
<p>微软已经讨论在 Word、PowerPoint、Outlook 等应用程序中加入 OpenAI 的人工智能，以便客户能够使用简单的提示自动生成文本。这一举措可能会改变超过 10 亿人编写文档、演示文稿和电子邮件的方式。工程师们正在开发在客户数据上训练这些模型的方法，并保证这些数据不会泄露给其他客户或落入不良分子手中</p>
<p><strong>我们该不该放烟花</strong></p>
<p>走在街上，随便找个00后问问，中国的四大传统节日是什么？能答对的少之又少…….<br>春节的却是个值得庆祝的节日，但是换种思考方式，从宇宙的尺度来看，一颗行星绕他们的恒星转了一圈，一片版块像鸡的土地上，有一些人在外拼搏一年，回家过年。放烟花是他们的一种庆祝方式，和家人坐在一起，聊天庆祝。<br>多地禁止放烟花，临近春节又放开了，我们这种庆祝的方式如果不能得到妥善解决的话，烟花公司也没有存在的必要了<br>放烟花感觉是一种习俗了，如果提到过年，脑海中是不是就这几个画面，红包，团圆饭，烟花，缺少其中任何一个元素，节日便没了感觉。如果端午节没有了粽子，是不是也就没有存在的意义了？<br>期待烟花这类事能得到妥善解决，朋友们可以过一个开开心心的年</p>
<p><strong>在hacker news听到”撞库“一词</strong></p>
<p>撞库的意思是，很多人把密码设置一样，当拥有一份数据库后，把已知的密码库，去撞未知的密码库，就会得到该账号的密码。<br>比如，你的抖音账号密码泄漏后，不法分子会用你该账号信息，去撞你的其他社交账户。唯一的解决办法是，各大平台使用不同的密码</p>
<p><strong>我们的学校到底是训练学生，还是在教育学生？</strong></p>
<p>作者从“学棋”的角度， 过渡到了这个问题</p>
<figure class="highlight txt"><table><tbody><tr><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/ICjgDxw0hkrxAjWiNUEVYQ</span><br></pre></td></tr></tbody></table></figure>





<p><strong>华罗庚读书法</strong></p>
<p>他认为，读一本书，读一本好书，读好一本书，大致需要经历两个过程，第一个过程叫作“把书读厚”，第二个过程叫作“把书读薄“<br>“把书读厚”在于读书的时候对每个章节旁征博引添加引用，对每一页做注释写笔记，这样一来，书自然而然就变厚了。<br>“把书读薄”在于逐渐掌握了书的实质内容，有了更透彻的理解，我们自然也就感觉到书变薄了。</p>
<p><strong>视频网站的“蓝光”是怎么骗你的？——视频画质入门解析</strong></p>
<p>在你斥巨资开通视频网站的会员之后，是不是发现自己终于可以享用“1080P蓝光”画质？然后又发现这个“蓝光”……好像也没有多清晰嘛！</p>
<p>所谓的“1080P蓝光”究竟是怎么回事？为什么有些1080P视频还是那么糊？视频网站的蓝光是真蓝光吗？怎么判断视频画质的好坏？MP4和MKV谁更清晰？为了讲清这些问题，我们做了这期15分钟的视频，相信能和你一起搞清楚这些问题</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1nW4y1V7kR</span><br></pre></td></tr></tbody></table></figure>







<p>一个农夫到城市来，不懂交通规则，他不是蠢，他只是不太理解什么叫交通规则。一个城里人到乡下，分不清麦子和稻子，你也不能说他蠢，他只是没有接触过。所以真心希望各位同学，遇到和自己观点不一样的，能够本着一颗求同存异的心，不要带有知识的优越感 ———罗翔</p>
<p><strong>伦敦地铁无裤日</strong></p>
<p>伦敦「地铁无裤日」（No Trousers Tube Ride），市民们穿着底裤搭乘地铁。1月8日，伦敦举行新冠疫情爆发以来的首次「地铁无裤日」，活动参与者上身需正常着装，下身只穿一件底裤和鞋子，但是禁止穿丁字裤和透视装。「地铁无裤日」2002年始于美国纽约，目的是鼓励人们打破保守思想、尝试自我突破。迄今该活动已在纽约、柏林、伦敦、里斯本、东京、多伦多等全球逾60座城市举办。所以，人类穿衣服还是保守了吗？</p>
<img src="/posts/cc02e38c/cc02e38c/image-20230115083900042.png" class="" title="image-20230115083900042">



</body></html>]]></content>
      <categories>
        <category>期刊</category>
      </categories>
      <tags>
        <tag>2023第二期</tag>
      </tags>
  </entry>
  <entry>
    <title>2023第五期</title>
    <url>/posts/59af9cfc.html</url>
    <content><![CDATA[<html><head></head><body><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol>
<li><p>一个分享健康饮食的网站</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://www.foodwake.com/</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<ol start="2">
<li><p>油管非常好用的一款中英文翻译插件，但是只能电脑用，感觉还是非常好用的、</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://www.languagereactor.com/chat</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>程序员可以用的AI：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://phind.com/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>小林说的一口气说清楚chatGPT</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">可以在b站或油管直接搜到， 个人感觉还是讲的非常不错的</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>chatGPT交流社区：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://www.skool.com/chatgpt</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>一款语音合成项目,值得一看：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/LokerL/tts-vue</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>VueFastDev,VueFastDev是一套基于element-ui、Echarts等二次开发封装、模块化的前端UI组件库。</p>
<p>它是一个低代码的前框框架，它使用JSON配置生成页面，可以减少我们的页面开发工作量，从而提升效率。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://www.npmjs.com/package/vuefastdev</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>ChatGPT个人专用版 基于ChatGPT-3.5-Turbo模型实现-51BuyGPT</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://chat.51buygpt.com</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Chrome ChatGPT 划词翻译插件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/yetone/openai-translator </span><br></pre></td></tr></tbody></table></figure></li>
<li><p>tabby是一款开源且免费的终端连接工具。功能非常强大，不仅支持作为SSH客户端使用，SFTP传输文件、使用PowerShell和Git命令也不在话下。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/Eugeny/tabby/releases</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>推荐一个chatGPT个人专享版</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://chat.51buygpt.com/</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="阅读推荐"><a href="#阅读推荐" class="headerlink" title="阅读推荐"></a>阅读推荐</h2><p><strong>健康的一些小常识:</strong></p>
<p>第一、戒掉碳酸饮料还有奶茶<br>它们真的会胖死你，当你戒饮料和奶茶后，就算你啥都不做，你都不会变胖了甚至还会变瘦。</p>
<p>第二、不要熬夜<br>坚持11点左右睡觉，真的气色变好人也瘦了</p>
<p>第三、吃早餐<br>不吃早餐，体质会变酸，所以你的早餐要吃的丰富，也可以把你想吃而减肥不能吃的早餐适量的吃。</p>
<p>第四、一定不要把自己吃撑了<br>午饭7分饱，晚餐5分饱，吃撑了会加重胃的负担，更难消化了。</p>
<p>第五、尽量选择碱性食物<br>改变酸性易胖体质，就算聚餐吃点也不会迅速长胖。</p>
<p><strong>为什么健康教育要讲无性恋相关的知识？</strong></p>
<p>因为很多无性恋青少年会误以为自己一定是出了什么问题才会感受不到性吸引。健康教育应该要帮TA们破除这样的误解。</p>
<p>实际上，很多无性恋青少年会强迫自己进入和性有关的事情之中，或者因为觉得自己有问题而默默承受伴侣的虐待。我们应该给这些孩子正确的引导，保护这些孩子的健康和安全</p>
<p><strong>心肌梗塞</strong></p>
<p>心肌梗塞（俗称“心脏病发作”）的征兆因性别而异。大多数人只知道男性发病的征兆，对女性发病的征兆不是很了解。请全面了解，并把知识传播给更多女性。</p>
<p>【网评】我外婆去世，有一部分原因就是她心肌梗塞的时候男医生坚称她只是消化不良。</p>
<p>【网评】男性的心肌梗塞征兆往往被认为是“标准”的判断依据，而女性的心肌梗塞征兆如果被提及，也常常仅仅被作为“标准之外的特例”</p>
<p><strong>为确保 Bard 能给出高质量答案，谷歌员工对其进行单条式的评估、修正训练</strong></p>
<p>不久前，谷歌在内部发起了代号为“斗狗”的活动，要求公司所有员工每周用两到四个小时帮助测试和改进其新的人工智能搜索聊天机器人 Bard。</p>
<p>就在 Bard 发布前不久，微软也刚刚发布了采用 ChatGPT 聊天机器人背后技术的新版必应搜索引擎，它允许用户就几乎任何话题进行多轮对话。然而，在 Bard 被发现提供了一个错误的答案后，对于谷歌的质疑也逐渐浮现。同样，随着越来越多的人测试了新必应，他们的聊天机器人也遇到了问题，比如其倾向于好斗的行为。</p>
<p>像 Bard 和 ChatGPT 这样的 AI 聊天机器人，可以通过接受人类编写的文本训练来模仿人类对话，这就解释了为什么必应的回复有时候看起来有些情绪化和不可预测。毕竟，被训练得像人一样的机器人也很容易犯下人类的错误。</p>
<p>这些聊天机器人最初通过摄取大量的训练数据来完成大部分学习。此外，Bard 项目的产品主管杰克・克劳奇克 (Jack Krawczyk) 在一份备忘录中告诉员工，谷歌的研究发现，为用户查询添加高质量的响应“显著”提高了其 AI 模型的质量</p>
<p><strong>冷知识</strong></p>
<p>办理或更换手机号的时候，切记不要选择13号段，谨慎选择15号段，建议选择18等新号段。</p>
<p>因为较老的号段一般是回收号，你可能因此面临垃圾信息或电话骚扰，甚至诉讼风险。理论上你可以证明你跟旧机主无关，但是实际解决起来成本很高</p>
<h2 id="好文章推荐"><a href="#好文章推荐" class="headerlink" title="好文章推荐"></a>好文章推荐</h2><p><strong>生育是地狱， 不生育也是地狱</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s?__biz=MTc5MTU3NTYyMQ==&amp;mid=2651202495&amp;idx=2&amp;sn=616a0a983d5ba4cc558ff83403932796&amp;chksm=590432956e73bb83f2c09f047eb70ab406268cc1691175d82578cd17d281361dba1e81b9afb6#rd</span><br></pre></td></tr></tbody></table></figure>

<p><strong>深度好文推荐。 《ChatGPT Prompt工程：设计、实践与思考》</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/BdaoNsgRcDZH_N502n-kHQ</span><br></pre></td></tr></tbody></table></figure>



<h2 id="趣闻"><a href="#趣闻" class="headerlink" title="趣闻"></a>趣闻</h2><ol>
<li><p>本月收到 500 多篇 ChatGPT 生成的文章，科幻杂志 Clarkesworld 宣布关闭投稿渠道</p>
<p>Clarkesworld (<a href="https://clarkesworldmagazine.com/">https://clarkesworldmagazine.com/</a>) 杂志编辑 Neil Clarke 表示近期收到了大量由 ChatGPT 生成的科幻故事投稿，在今年 2 月份数量激增至 500 多篇，今年 1 月数量为 100 篇，去年 10 月则为 25 篇。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Clarkesworld (https://clarkesworldmagazine.com/)</span><br><span class="line">文章来源</span><br><span class="line">https://clarkesworldmagazine.com/</span><br></pre></td></tr></tbody></table></figure>



<ol start="2">
<li><p>AMD CEO 认为计算机领域的下一个最重要挑战是能效</p>
<p>AMD CEO 苏姿丰（Lisa Su）在 IEEE ISSCC 会议上指出，未来十年计算机领域的最重要挑战将是能效。摩尔定律预测的芯片性能增长速度虽然放缓了，但今天的芯片计算能力仍然能每两年半翻一番，超算翻倍所需的时间更短。然而计算机的能效并没有跟上这一步伐，十年后未来的超算可能需要多达 500 兆瓦的电力。她说，没人真正知道如何实现下一个运算千倍增长的 zetta 级超算，这必定需要全面的改进效率，不仅包括改进芯片的能效，还需要高效的芯片间通信和低功耗的内存访问。苏姿丰谈论了 AMD 在数据中心 APU MI300 上采取的改进能效的众多措施</p>
</li>
</ol>
<ol start="3">
<li><p>TikTok 上出了一个新的「少年滤镜」，能让你看起来像十几岁时的样子‼️<br>大家都在用这个滤镜回忆自己的青春，也有母亲回忆自己去世孩子的样子..</p>
<p>每个人都在重温过去的自己，家人却…….</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://weibo.com/7374814530/MueGN6cmR</span><br></pre></td></tr></tbody></table></figure>

<p>说实话， 想给我的奶奶看看这个滤镜， 真的是非常的不错， 记得去年过年的时候她就哭了， 我当时也很难受</p>
</li>
<li><p>Bing 应用程序的下载量突然开始飚升</p>
<p>Bing 应用程序的下载量猛增至10万。 比前一周的每日平均下载量增加了 758%，这是自 2009 年 Bing首次发布以来的最高每日下载量，这个是来自推特的一条数据</p>
</li>
<li><p>最新研究发现微塑料污染对人类和动物身体造成损害</p>
<p>上周五，伦敦自然历史博物馆的科学家们宣布，他们在澳大利亚豪勋爵岛上的海鸟肉足鹱身上发现了一种仅由摄入塑料引起的新疾病。他们称这种情况为塑料病——一种由微小塑料颗粒引起消化道发炎引起的纤维化疾病。持续的炎症会损害组织，导致疤痕和变形。受感染的鸟类更容易受到感染和寄生虫侵害，同时它们会失去一些消化食物和吸收维生素的能力。</p>
<p>在美国科学促进会的会议上，罗马托尔维尔加塔大学的路易莎•坎帕诺洛概述了意大利科学家最近的研究，他们在从六名正常怀孕的妇女身上收集的人类胎盘中发现了来自不同来源的微小塑料颗粒。</p>
<p>坎帕诺洛说，另一项研究发现，塑料颗粒“不仅存在于胎盘组织中，还存在于胎粪中，即婴儿的第一次粪便中——这意味着这些颗粒可以穿过胎盘进入胎儿体内。”</p>
<p>“我们发现了大量不同类型的塑料颗粒，”她补充说。“最多的是PVC，但基本上所有日常消费品中的其他塑料类型都存在</p>
</li>
<li><p>抖音升级青少年保护措施，每天默认最多使用 40 分钟</p>
<p>抖音宣布升级青少年保护措施，包括上线抖音守护中心，以及对青少年模式、亲子守护平台、使用管理助手三大防沉迷工具进行功能迭代。</p>
<p>抖音守护中心上线后，用户通过搜索“抖音守护中心”便可开启青少年模式及长辈模式。在抖音守护中心的青少年模式下，家长可进行亲子绑定、未成年人充值退款、休息提醒、内容偏好设置、时间锁等功能的设置，以管理孩子在抖音上的使用。</p>
<p>此外，三大防沉迷工具功能均有迭代。青少年模式方面，每日首次启动抖音时，弹窗推送青少年模式引导页。2021 年 9 月起，14 岁以下实名认证用户全部进入青少年模式且无法自行退出。默认每天最多使用 40 分钟，晚上 22 点-次日 6 时无法使用，关闭直播、充值、打赏等功能。</p>
<p>该模式还提供细分年龄段推荐适龄主题、科学科普、兴趣模式素养等内容，退出漏洞防范机制，青少年模式状态下卸载重装、同账号换手机登录均无法退出。开启护眼功能后，设备将弱化有害蓝光，保护孩子视力。</p>
<p>据介绍，亲子守护平台也进行了功能更新。家长可使用该平台绑定最多三个未成年子女抖音账号，并根据需要为孩子开启青少年模式及设置使用时长。同时，平台上线了使用周报功能，家长可定期通过周报了解孩子使用时间和感兴趣的内容。</p>
<p>使用管理助手则在此前设置睡眠提醒和休息提醒等时间管理功能基础上，推出“内容偏好设置”，网友可自主选择感兴趣或不感兴趣的内容，并调整推荐强度。比如网友选取知识类“天文科普”“地理科普”“动物自然”三个标签，选择“增加推荐”，系统将自动推荐更多相关内容</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>期刊</category>
      </categories>
      <tags>
        <tag>2023第五期</tag>
      </tags>
  </entry>
  <entry>
    <title>SPA首屏加载慢怎么办？</title>
    <url>/posts/30272.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="SPA首屏加载慢怎么办？"><a href="#SPA首屏加载慢怎么办？" class="headerlink" title="SPA首屏加载慢怎么办？"></a>SPA首屏加载慢怎么办？</h1><h2 id="面试官：SPA首屏加载速度慢的怎么解决？"><a href="#面试官：SPA首屏加载速度慢的怎么解决？" class="headerlink" title="面试官：SPA首屏加载速度慢的怎么解决？"></a>面试官：SPA首屏加载速度慢的怎么解决？</h2><img src="/posts/30272/30272/image-20221016063624694.png" class="" title="image-20221016063624694">

<h3 id="一、什么是首屏加载"><a href="#一、什么是首屏加载" class="headerlink" title="一、什么是首屏加载"></a>一、什么是首屏加载</h3><p>首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容</p>
<p>首屏加载可以说是用户体验中<strong>最重要</strong>的环节</p>
<span id="more"></span>

<h4 id="关于计算首屏时间"><a href="#关于计算首屏时间" class="headerlink" title="关于计算首屏时间"></a>关于计算首屏时间</h4><p>利用<code>performance.timing</code>提供的数据：</p>
<img src="/posts/30272/30272/image-20221016063716771.png" class="" title="image-20221016063716771">

<p>通过<code>DOMContentLoad</code>或者<code>performance</code>来计算出首屏时间</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 方案一：</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">'DOMContentLoaded'</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'first contentful painting'</span>);</span><br><span class="line">});</span><br><span class="line"><span class="comment">// 方案二：</span></span><br><span class="line">performance.<span class="title function_">getEntriesByName</span>(<span class="string">"first-contentful-paint"</span>)[<span class="number">0</span>].<span class="property">startTime</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// performance.getEntriesByName("first-contentful-paint")[0]</span></span><br><span class="line"><span class="comment">// 会返回一个 PerformancePaintTiming的实例，结构如下：</span></span><br><span class="line">{</span><br><span class="line">  <span class="attr">name</span>: <span class="string">"first-contentful-paint"</span>,</span><br><span class="line">  <span class="attr">entryType</span>: <span class="string">"paint"</span>,</span><br><span class="line">  <span class="attr">startTime</span>: <span class="number">507.80000002123415</span>,</span><br><span class="line">  <span class="attr">duration</span>: <span class="number">0</span>,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="二、加载慢的原因"><a href="#二、加载慢的原因" class="headerlink" title="二、加载慢的原因"></a>二、加载慢的原因</h3><p>在页面渲染的过程，导致加载速度慢的因素可能如下：</p>
<ul>
<li>网络延时问题</li>
<li>资源文件体积是否过大</li>
<li>资源是否重复发送请求去加载了</li>
<li>加载脚本的时候，渲染内容堵塞了</li>
</ul>
<h3 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h3><p>常见的几种SPA首屏优化方式</p>
<ul>
<li>减小入口文件积</li>
<li>静态资源本地缓存</li>
<li>UI框架按需加载</li>
<li>图片资源的压缩</li>
<li>组件重复打包</li>
<li>开启GZip压缩</li>
<li>使用SSR</li>
</ul>
<h4 id="减小入口文件体积"><a href="#减小入口文件体积" class="headerlink" title="减小入口文件体积"></a>减小入口文件体积</h4><p>常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加</p>
<img src="/posts/30272/30272/image-20221016063808361.png" class="" title="image-20221016063808361">

<p>在<code>vue-router</code>配置路由的时候，采用动态加载路由的形式</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[ </span><br><span class="line">    <span class="attr">path</span>: <span class="string">'Blogs'</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">'ShowBlogs'</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'./components/ShowBlogs.vue'</span>)</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件</p>
<h4 id="静态资源本地缓存"><a href="#静态资源本地缓存" class="headerlink" title="静态资源本地缓存"></a>静态资源本地缓存</h4><p>后端返回资源问题：</p>
<ul>
<li>采用<code>HTTP</code>缓存，设置<code>Cache-Control</code>，<code>Last-Modified</code>，<code>Etag</code>等响应头</li>
<li>采用<code>Service Worker</code>离线缓存</li>
</ul>
<p>前端合理利用<code>localStorage</code></p>
<h4 id="UI框架按需加载"><a href="#UI框架按需加载" class="headerlink" title="UI框架按需加载"></a>UI框架按需加载</h4><p>在日常使用<code>UI</code>框架，例如<code>element-UI</code>、或者<code>antd</code>，我们经常性直接引用整个<code>UI</code>库</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ElementUI</span> <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">ElementUI</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { <span class="title class_">Button</span>, <span class="title class_">Input</span>, <span class="title class_">Pagination</span>, <span class="title class_">Table</span>, <span class="title class_">TableColumn</span>, <span class="title class_">MessageBox</span> } <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Button</span>)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Input</span>)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Pagination</span>)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="组件重复打包"><a href="#组件重复打包" class="headerlink" title="组件重复打包"></a>组件重复打包</h4><p>假设<code>A.js</code>文件是一个常用的库，现在有多个路由使用了<code>A.js</code>文件，这就造成了重复下载</p>
<p>解决方案：在<code>webpack</code>的<code>config</code>文件中，修改<code>CommonsChunkPlugin</code>的配置</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">minChunks</span>: <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>minChunks</code>为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件</p>
<h4 id="图片资源的压缩"><a href="#图片资源的压缩" class="headerlink" title="图片资源的压缩"></a>图片资源的压缩</h4><p>图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素</p>
<p>对于所有的图片资源，我们可以进行适当的压缩</p>
<p>对页面上使用到的<code>icon</code>，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻<code>http</code>请求压力。</p>
<h4 id="开启GZip压缩"><a href="#开启GZip压缩" class="headerlink" title="开启GZip压缩"></a>开启GZip压缩</h4><p>拆完包之后，我们再用<code>gzip</code>做一下压缩 安装<code>compression-webpack-plugin</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">cnmp i compression-webpack-plugin -D</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>vue.congig.js</code>中引入并修改<code>webpack</code>配置</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CompressionPlugin</span> = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">configureWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> {</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">'production'</span>) {</span><br><span class="line">            <span class="comment">// 为生产环境修改配置...</span></span><br><span class="line">            config.<span class="property">mode</span> = <span class="string">'production'</span></span><br><span class="line">            <span class="keyword">return</span> {</span><br><span class="line">                <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">CompressionPlugin</span>({</span><br><span class="line">                    <span class="attr">test</span>: <span class="regexp">/\.js$|\.html$|\.css/</span>, <span class="comment">//匹配文件名</span></span><br><span class="line">                    <span class="attr">threshold</span>: <span class="number">10240</span>, <span class="comment">//对超过10k的数据进行压缩</span></span><br><span class="line">                    <span class="attr">deleteOriginalAssets</span>: <span class="literal">false</span> <span class="comment">//是否删除原文件</span></span><br><span class="line">                })]</span><br><span class="line">            }</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<p>在服务器我们也要做相应的配置 如果发送请求的浏览器支持<code>gzip</code>，就发送给它<code>gzip</code>格式的文件 我的服务器是用<code>express</code>框架搭建的 只要安装一下<code>compression</code>就能使用</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">const compression = require('compression')</span><br><span class="line">app.use(compression())  // 在其他中间件使用之前调用</span><br></pre></td></tr></tbody></table></figure>

<h4 id="使用SSR"><a href="#使用SSR" class="headerlink" title="使用SSR"></a>使用SSR</h4><p>SSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器</p>
<p>从头搭建一个服务端渲染是很复杂的，<code>vue</code>应用建议使用<code>Nuxt.js</code>实现服务端渲染</p>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>减少首屏渲染时间的方法有很多，总的来讲可以分成两大部分 ：资源加载优化 和 页面渲染优化</p>
<p>下图是更为全面的首屏优化的方案</p>
<img src="/posts/30272/30272/image-20221016064024827.png" class="" title="image-20221016064024827">

<p>大家可以根据自己项目的情况选择各种方式进行首屏渲染的优化</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/88639980?utm_source=wechat_session">https://zhuanlan.zhihu.com/p/88639980?utm_source=wechat_session</a></li>
<li><a href="https://www.chengrang.com/how-browsers-work.html">https://www.chengrang.com/how-browsers-work.html</a></li>
<li><a href="https://juejin.cn/post/6844904185264095246">https://juejin.cn/post/6844904185264095246</a></li>
<li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>SPA首屏加载慢</tag>
      </tags>
  </entry>
  <entry>
    <title>2023第四期</title>
    <url>/posts/363159bb.html</url>
    <content><![CDATA[<html><head></head><body><p>最近因为有很多事， 耽误更新了， 希望不要介意哈哈哈</p>
<span id="more"></span>

<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol>
<li><p>2700多个开源免费图标Icons库，提供可变笔划 SVG 格式、Web 字体、Figma、React、Vue 和 Flutter 即用型包，支持一键复制直接调用</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://atlasicons.vectopus.com</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>简单分享一下一些AI工具</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">- Galileo AI (https://www.usegalileo.ai/) 用AI设计生成UI设计</span><br><span class="line">- README 生成器 (https://readme.rustc.cloud/zh) 用AI生成完整的GitHub readme</span><br><span class="line">- ChatGPT for StackOverflow (https://stackoverflow.gg/) 查看 ChatGPT 对 StackOverflow 上每个问题的回复，甚至是未回答的问题</span><br><span class="line">- 周报生成器 (https://weeklyreport.avemaria.fun/zh) 简单描述工作内容，帮你生成完整周报</span><br><span class="line">- email-helper (https://email-helper.vercel.app/) AI帮你写邮件</span><br><span class="line">- animeai (https://animeai.app/) AI生成漫画风格图片</span><br><span class="line">- autodraw (https://www.autodraw.com/) AI辅助绘画</span><br><span class="line">- bearly (https://bearly.ai/) AI帮助你阅读、创作，撰写，提高你的工作效率</span><br><span class="line">- poe (https://quorablog.quora.com/Poe-1) quora出品的对话式AI工具</span><br><span class="line">- latentlabs (https://www.latentlabs.art/) 根据文本生成 360 度全景图</span><br><span class="line">- invideo (https://invideo.io/ai/) 根据文本生成视频</span><br><span class="line">- docuchat (https://www.docuchat.io/) 上传文档，AI回答对应的问题</span><br><span class="line">- tweetmonk (https://tweetmonk.com/) AI帮你打理社交网络</span><br><span class="line">- image-to-sound-fx (https://huggingface.co/spaces/fffiloni/image-to-sound-fx) 图片转换为相对应的声音内容</span><br><span class="line">- murf (https://murf.ai/) AI生成真人演讲视频</span><br><span class="line">- stockimg (https://stockimg.ai/) AI设计图标</span><br><span class="line">- playgroudai (https://playgroundai.com/) 获取AI绘图提示词，帮助你编辑图片</span><br><span class="line">- MetaVoice Studio (https://studio.themetavoice.xyz/) AI声音编辑平台</span><br><span class="line">- campbell (https://review.gobudapest.io/) AI生成评语</span><br><span class="line">- penlope (https://penelopeai.com/) AI辅助markdown编辑器</span><br><span class="line">- ChatGPT Detector (https://huggingface.co/spaces/Hello-SimpleAI/chatgpt-detector-single) 判断文本是否是AI生成</span><br><span class="line">- humata (https://app.humata.ai/signin) 利用AI来分析论文内容</span><br><span class="line">- tosummary (https://tosummary.com/) 利用AI提取书籍、YouTube视频摘要</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>一个网页设计灵感库</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://refero.design/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>一个分享chatGPt提示的网站</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://flowgpt.com/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>模仿手写软件,在线手写字体转换器,AI生成专属手写字体,制作自己笔迹的字体,打印出以假乱真的模拟手写文档,让打印出的字看上去像手写的软件,模拟抄写软件,代替抄写,抄写神器软件。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http://www.beautifulcarrot.com/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>开源字体图标库</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://atlasicons.vectopus.com</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>找到个ts-challenges 详解</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/type-challenges/type-challenges/issues/21338</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>react后台管理系统组件库</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://www.tremor.so/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>基于gpt3的AI</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://www.teach-anything.com</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<ol start="10">
<li>论文降重查重</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://www.xiegelunwen.com</span><br></pre></td></tr></tbody></table></figure>



<ol start="11">
<li><p>久坐的危害【久坐对身体下半身影响巨大-哔哩哔哩】 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://b23.tv/2Nlz8G6</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>文章总结器:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://labs.kagi.com/ai/sum_</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>输入代码片段，顷刻间Grep便可以从50 万个开源仓库中检索出结果<br>搜索时可选区分大小写、正则表达式以及单词搜索</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://grep.app/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>AI 工具的清单列表</p>
</li>
</ol>
  <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://spectacular-party-fc2.notion.site/An-Ultimate-list-of-500-AI-tools-8f737bef33af49fc97336dc9c819c695</span><br></pre></td></tr></tbody></table></figure>



<ol start="15">
<li><p>网页打包成apk</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://wwry.lanzoum.com/iXw6f0ntmeod</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="趣闻"><a href="#趣闻" class="headerlink" title="趣闻"></a>趣闻</h2><p><strong>必应 ChatGPT 功能短暂亮相</strong></p>
<p>微软据报道正致力于在必应搜索引擎中整合 OpenAI 的聊天机器人 ChatGPT，计划未来几周内推出。上周五，多名必应用户通过社交媒体披露 ChatGPT 功能短暂出现在搜索引擎界面中。必应的新搜索引擎界面显示在搜索旁的菜单栏中出现了一个新的“聊天”选项。点击该选项，会被引入一个聊天界面，上面写着：“欢迎来到新必应。你的 AI 回答引擎”。微软拒绝对这一报道置评</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://www.theverge.com/2023/2/3/23584675/microsoft-ai-bing-chatgpt-screenshots-leak</span><br><span class="line">https://www.solidot.org/story?sid=74048</span><br></pre></td></tr></tbody></table></figure>



<p><strong>ChatGPT 通过了 Google 18.3 万美元年薪 3 级工程师的编程面试考验</strong></p>
<p>根据一份内部文件，Google 向 ChatGPT 输入了其编程面试问题，然而根据其回答，聘请它为 L3 级工程师，这是一个入门级工程师职位但薪水并不低。ChatGPT 是否会取代软件工程师或至少是初级的工程师？ChatGPT 自己给出的答案是不会，声明自己是一个能帮助完成部分任务的工具，不能完全取代一位具有创造力、问题解决能力和批判性思维的人类软件工程师。它也需要人类的监督和指导才能有效运作。那么 20 年后呢？ChatGPT 承认也许那时候会影响初级职位，但重申不会完全人类软件工程师。ChatGPT 回答问题能力已经让搜索巨人倍感警惕，它正在加快测试基于 LaMDA 的 AI 聊天机器人</p>
<p>在叙利亚阿勒颇震区，救援人员正在将一名不幸去世的男子挖了出来，他仍保持着跪姿，突然，救援人群传出呼喊声！原来这名父亲一直保护着怀抱内的儿子，而他儿子还活着</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">视频地址：https://weibo.com/1760189314/MsgSodG1n</span><br></pre></td></tr></tbody></table></figure>





<h2 id="好文章推荐"><a href="#好文章推荐" class="headerlink" title="好文章推荐"></a>好文章推荐</h2><ol>
<li><p>教育的本质：“差生”、理想主义和命运</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/LB1KNlfPtZU2BxncIEhARQ</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>《三体》漂流记：争夺，死亡，人性残酷</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/Fu7R_3uRq6KJt6f-Y0xELQ</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>出走硅谷，和谷歌程序员聊聊他们在海外办公室的生活</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/hb2dvblHWahkIYZsI39L-w</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>中国的种族歧视问题</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/nv82R5s2a-aI4XhMktx0Aw</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>从18楼失踪的猫， 被chatGPT救了</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/8f45s6W9PFjgWpMw8f1Tsg</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol>
<li>看到一个鸡汤</li>
</ol>
<p>​        每个人的成长速度略有不同，或快或慢，但都不会影响我们朝着最好的自己奔去，慢慢成长，遇见最好的自己，善良不失锋芒，温柔而有骨气，坚韧并且执着。</p>
<ol start="2">
<li><p>心流</p>
<p>什么是心流？维基百科的解释：描述人类一种完全沉浸和完全投入于活动本身的心智状态的振奋状态。在适当的条件下，心流状态可以变成催眠或欣喜若狂的恍惚状态。</p>
<p>我自己理解的状态是，听不见嘈杂的声音，忘记时间，不在乎周围的一切，全心于注意力于手头的写作。当写作完成，才发现几个小时过去。有一点像睡觉，我们从晚上睡觉，到白天起床，不会体验到时间的流失。不同于睡觉的是，一个是被动，一个是主动。</p>
<p>我觉得我需要这种状态，无论是工作，听音乐，锻炼，那种沉浸式的体验让我感觉非常爽，我自己在写东西的时候，也是经常忘了时间，这样确实是让自己非常的陶醉</p>
</li>
<li><p>各大公司推出自己的AI</p>
<p>我之前看各大公司都在生产自己的AI，还以为这是蹭chatGPT的热度， 我们都知道， chatGPT的百万用户增长的速度确实惊人， 直到最近看到类似的新闻。。。。</p>
<p>alibaba</p>
<p>刚刚看到新闻， 说阿里也在研究自己的类chatGPT产品， 目前已经进入内测阶段<br>阿里确认正开发类 ChatGPT 产品，已进入内测阶段<br>据 21 世纪财经报道，阿里巴巴一名资深技术专家对外爆料，阿里达摩院正在研发类 ChatGPT 的对话机器人，目前已开放给公司内员工测试。从曝光截图来看，阿里巴巴可能将 AI 大模型技术与钉钉生产力工具深度结合。据此消息，阿里巴巴美股盘前短线拉升，涨近 2%。<br>阿里方面回应表示，确实在研发中，目前处于内测阶段。后续如有更多信息，会第一时间和媒体同步。<br>钉钉近期还表示，有用户已把 ChatGPT 机器人搬上了钉钉。在钉钉中，可自定义创建一个 ChatGPT 机器人（需自行开发）</p>
<p>baidu</p>
<p>网传百度也在效仿bing， 研究开发自己的AI产品， 效果不知， 但是个人是不太看好的， 因为我平时都不会百度， 这次如果拿不出亮眼的东西， 我大概率还是不会使用的</p>
<p>google</p>
<p>Google自然不用多说， 浏览器界首屈一指的大哥大， 也是开发出了自己的Bard， 我很期待， 目前这款产品正在内测中，<br>谷歌公司 CEO 桑达尔・皮查伊 (Sundar Pichai) 周一在内部备忘录中告诉员工，公司将需要所有人都来测试其新推出的 ChatGPT 竞争对手“巴德”(Bard)，员工们要拿出在内部进行黑客马拉松的精神来测试它<br>不过对于大公司来说， 每走一步就得更加的小心翼翼， 因为这个时候Google有了非常大的压力， 它的产品必须要做的更好才能更好的满足用户的需要， 比如如果你在发布会上回答的答案不正确， 这个时候大家都会很失望， 而一些chatGPt的就会更倾向Bing这边， 如果你的这个语言模型出现什么极端的言论，比如反人类， 种族歧视等敏感话题， 大家往往都会非常介意， 严重情况下还会上法庭<br>压力真的是给满了， 从股票的涨跌就能看出来</p>
<p>chatGPT的出现确实使得人工智能火了一把， 本人也是在一些特殊的问题上会问问chatGPT， 比如帮我写文章， 请教正则表达式的问题等， 以后可能会用到github出品的copliet， 但是，谁知道呢？chatGPT毫无疑问地影响到了我们的生活，慢慢地我们就会感受到。<strong>提出一个好问题比找到真正地答案更加的重要</strong></p>
</li>
</ol>
<h2 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h2><p>《狂飙》电视剧版本的还是少了一些被删减的细节， 总归来说还是拍的太保守了</p>
<p>《血色浪漫》钟跃民的故事成为了一个时代的记忆， 我随时00后， 但是很喜欢这个任务形象</p>
<p>《遗言图书馆》里面记录了一些名人的临终遗言， 我感觉写的很好</p>
<h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><p>如果你家的冲水箱有声音，或者上水很慢，可以参考这两个视频。<br><a href="https://www.bilibili.com/video/BV1EX4y1M7YJ/">https://www.bilibili.com/video/BV1EX4y1M7YJ/</a><br><a href="https://youtu.be/DsO0mZdd9uw">https://youtu.be/DsO0mZdd9uw</a></p>
</body></html>]]></content>
      <categories>
        <category>期刊</category>
      </categories>
      <tags>
        <tag>2023第四期</tag>
      </tags>
  </entry>
  <entry>
    <title>axios发送请求过程详解</title>
    <url>/posts/41828.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="axios发送请求过程详解"><a href="#axios发送请求过程详解" class="headerlink" title="axios发送请求过程详解"></a>axios发送请求过程详解</h1><p>先来看一下axios的一个基本的使用</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// axios的发送请求</span></span><br><span class="line">      <span class="title function_">axios</span>({</span><br><span class="line">          <span class="attr">method</span>: <span class="string">"GET"</span>,</span><br><span class="line">          <span class="attr">url</span>:<span class="string">"http://localhost:3000/posts"</span></span><br><span class="line">      }).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> {</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">      }).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> {</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">      })</span><br></pre></td></tr></tbody></table></figure>

<p>我们还是按照之前创建的本地服务作为例子来进行一个说明，下面这幅图是返回的结果：</p>
<span id="more"></span>

<img src="/posts/41828/41828/image-20221004070833641.png" class="" title="image-20221004070833641">

<p>我们知道axios的创建过程， axios是由Axios.prototype.request这个函数通过bind创建而来的，所以说axios和request的功能都是一样的， 都是函数，这里用axios调用在一定程度上就像是request函数在调用，我们来演示一下这个过程：</p>
<p>在Axios.js中：</p>
<img src="/posts/41828/41828/image-20221004071633706.png" class="" title="image-20221004071633706">

<p>我们可以看到30行有一个config参数，这个参数就是我们在调用axios的时候传进来的：</p>
<img src="/posts/41828/41828/image-20221004071839656.png" class="" title="image-20221004071839656">

<p>按照逻辑往下走， 它会判断这个config的值是不是空， 为啥有两个参数， configOrUrl和config呢， 这个axios内部的一种原理， 允许你第一个参数可以传字符串， 第二个参数传config，实现的就是如果你的第一个参数是字符串的话，他就把第二个参数作为config</p>
<img src="/posts/41828/41828/image-20221004072332665.png" class="" title="image-20221004072332665">

<p>40行this.defaults是axios默认的配置对象，而mergeconfig是作对象合并的一个方法， 这行代码就是将默认的配置对象和传进来的配置对象合并，我们配置的如果在默认中已经有了， 这个时候是会覆盖的</p>
<img src="/posts/41828/41828/image-20221004073021591.png" class="" title="image-20221004073021591">

<p>这个是请求方法的判断， 如果你没传的话 ，axios会默认设置为get请求</p>
<img src="/posts/41828/41828/image-20221004073509024.png" class="" title="image-20221004073509024">

<p>看看81行， 如果没有涉及到拦截器的话， 会执行下面的逻辑， 先会创建一个chain，是由dispatchRequest创建的，dispatchRequest是会发送请求的，它会调用http和xhr这两个适配器</p>
<p>然后用promise.resolve带着传进来的config创建了一个promise对象，由于config是一个普通对象， 并不是promise对象，所以说这个时候的promise是一个成功的promise ，即它的状态就是fulfilled</p>
<p>接着到了一个循环当中， chain有两个元素， length就为2， 由于此时promise是一个成功的promise ， 然后promise.then就是会执行它的第一个回调函数的， 而不是执行第二个</p>
<img src="/posts/41828/41828/image-20221004074310401.png" class="" title="image-20221004074310401">

<p>chain.shift 得到的就是dispatchRequest函数，这个函数的执行结果决定着promise</p>
<p>整个过程就是request 调用dispatch 之后调用xhr， 最终在返回给request</p>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>axios发送请求过程详解</tag>
      </tags>
  </entry>
  <entry>
    <title>axios对象创建过程模拟实现</title>
    <url>/posts/13502.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="axios对象创建过程模拟实现"><a href="#axios对象创建过程模拟实现" class="headerlink" title="axios对象创建过程模拟实现"></a>axios对象创建过程模拟实现</h1><p>我们要想用axios对象创建过程模拟实现，可以直接看下面代码</p>
<span id="more"></span>

<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 先来一个构造函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">Axios</span> (config) {</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">defaults</span> = config;   <span class="comment">// 问了创建default默认属性</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">intercepters</span> = {</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">request</span>: {}, </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">response</span>: {}</span></span><br><span class="line"><span class="language-javascript">            }</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 原型添加相关的方法</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'发送AJAX的请求类型是'</span> + config.<span class="property">method</span>)</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span> (<span class="params">config</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>({method : <span class="string">"GET"</span>})</span></span><br><span class="line"><span class="language-javascript">        } </span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">post</span> = <span class="keyword">function</span> (<span class="params">config</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>({method : <span class="string">"POST"</span>})</span></span><br><span class="line"><span class="language-javascript">        } </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//声明函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">createInstance</span>(<span class="params">config</span>) {</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//实例化一个对象</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(config)<span class="comment">//  context.get()  context.post() 但是不能当成函数使用</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//创建请求函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> instance = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(context)<span class="comment">//instance是一个函数， 但是instance是不能当作对象使用的</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//将Axios.prototype对象中方法添加到instance函数对象中</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">                instance[key] = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[key].<span class="title function_">bind</span>(context)  <span class="comment">//this.default和this.interceptors就可以获取到这些属性</span></span></span><br><span class="line"><span class="language-javascript">            })</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//为instance函数对象添加属性default和interceptors</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Object</span>.<span class="title function_">keys</span>(context).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">                instance[key] = context[key]</span></span><br><span class="line"><span class="language-javascript">            })</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">dir</span>(instance)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> instance</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> axios = <span class="title function_">createInstance</span>({method : <span class="string">"GET"</span>})</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">axios</span>({method : <span class="string">"POST"</span>}) <span class="comment">// 当函数用没问题</span></span></span><br><span class="line"><span class="language-javascript">        axios.<span class="title function_">get</span>({})</span></span><br><span class="line"><span class="language-javascript">        axios.<span class="title function_">post</span>({})  <span class="comment">// 当对象调用方法也没问题</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<img src="/posts/13502/13502/image-20221209152610205.png" class="" title="image-20221209152610205">

<p>这样instance上面什么都有了，这个就是axios对象创建过程模拟实现</p>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>axios对象创建过程模拟实现</tag>
      </tags>
  </entry>
  <entry>
    <title>axios的基本知识</title>
    <url>/posts/56140.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="axios的基本使用"><a href="#axios的基本使用" class="headerlink" title="axios的基本使用"></a>axios的基本使用</h1><h2 id="什么是axios？"><a href="#什么是axios？" class="headerlink" title="什么是axios？"></a>什么是axios？</h2><ol>
<li><p>前端最流行的ajax请求库（轻量级）</p>
</li>
<li><p>react/vue都推荐的方法（绝对靠谱好用）</p>
</li>
<li><p>文档： <a href="https://github.com/axios/axios">https://github.com/axios/axios</a></p>
<span id="more"></span>

<h2 id="axios的特点"><a href="#axios的特点" class="headerlink" title="axios的特点"></a>axios的特点</h2></li>
<li><p>基本promise的异步ajax请求库</p>
</li>
<li><p>浏览器和node都能使用</p>
</li>
<li><p>支持请求和响应拦截器（为我们书写更多逻辑提供方便）</p>
</li>
<li><p>支持请求取消</p>
</li>
<li><p>请求和响应数据转换</p>
</li>
<li><p>批量发送多个请求</p>
</li>
</ol>
<h3 id="axios的常用方法"><a href="#axios的常用方法" class="headerlink" title="axios的常用方法"></a>axios的常用方法</h3><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">##### axios.<span class="title function_">request</span>(config)  等同于 axios（config）</span><br><span class="line"></span><br><span class="line">##### axios.<span class="title function_">get</span>(url[, config])    发get请求</span><br><span class="line"></span><br><span class="line">##### axios.<span class="title function_">delete</span>(url[, config])     发<span class="keyword">delete</span>请求</span><br><span class="line"></span><br><span class="line">##### axios.<span class="title function_">head</span>(url[, config])    </span><br><span class="line"></span><br><span class="line">##### axios.<span class="title function_">options</span>(url[, config])</span><br><span class="line"></span><br><span class="line">##### axios.<span class="title function_">post</span>(url[, data[, config]])    发post请求</span><br><span class="line">     </span><br><span class="line">##### axios.<span class="title function_">put</span>(url[, data[, config]])      发put请求</span><br><span class="line"></span><br><span class="line">##### axios.<span class="title function_">patch</span>(url[, data[, config]])</span><br></pre></td></tr></tbody></table></figure>

<h3 id="axios-create"><a href="#axios-create" class="headerlink" title="axios.create()"></a>axios.create()</h3><ol>
<li>根据指定配置创建一个新的axios, 也就是每个新axios都有自己的配置</li>
<li>新axios没有取消请求和批量发请求的方法， 其他所有的语法都是一致的</li>
<li>为什么要设计这个语法？<ol>
<li>需求： 项目中有部分接口与另一部分接口需要的配置不太一样</li>
<li>解决： 创建2个新axios， 每个都有自己特有的配置， 分别应用到不同要求的接口请求中</li>
</ol>
</li>
</ol>
<p>创建一个axios实例：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>({</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">headers</span>: {<span class="string">'X-Custom-Header'</span>: <span class="string">'foobar'</span>}</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>instance是一个函数， 并不是一个对象， 如果大家学完源码就可以很清晰的了解它了</p>
<p><img src="/posts/56140/image-20220930105930304.png" alt="axios的基本知识"></p>
<h3 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h3><p>在请求或响应被 then 或 catch 处理前拦截它们。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) {</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  }, <span class="keyword">function</span> (<span class="params">error</span>) {</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) {</span><br><span class="line">    <span class="comment">// 2xx 范围内的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  }, <span class="keyword">function</span> (<span class="params">error</span>) {</span><br><span class="line">    <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure>

<p>如果你稍后需要移除拦截器，可以这样：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myInterceptor = axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params"></span>) {<span class="comment">/*...*/</span>});</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">eject</span>(myInterceptor);</span><br></pre></td></tr></tbody></table></figure>

<p>可以给自定义的 axios 实例添加拦截器。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>();</span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params"></span>) {<span class="comment">/*...*/</span>});</span><br></pre></td></tr></tbody></table></figure>

<p>以上就是axios基本的使用。</p>
<p>接下来我们开始测试，</p>
<p>参考地址：<a href="https://github.com/typicode/json-server">https://github.com/typicode/json-server</a></p>
<p> 先创建一个json-server的文件， 进入该文件夹， </p>
<p>执行：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">npm i -g json-server</span><br></pre></td></tr></tbody></table></figure>

<p>接着就是在json-server文件夹下面创建一个db.json,在该文件中加入以下内容：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"posts"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">{</span> <span class="attr">"id"</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">"title"</span><span class="punctuation">:</span> <span class="string">"json-server"</span><span class="punctuation">,</span> <span class="attr">"author"</span><span class="punctuation">:</span> <span class="string">"typicode"</span> <span class="punctuation">}</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"comments"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">{</span> <span class="attr">"id"</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">"body"</span><span class="punctuation">:</span> <span class="string">"some comment"</span><span class="punctuation">,</span> <span class="attr">"postId"</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">}</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"profile"</span><span class="punctuation">:</span> <span class="punctuation">{</span> <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"typicode"</span> <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后就是启动服务：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">json-server --watch db.json</span><br></pre></td></tr></tbody></table></figure>

<p>值得注意的是， 执行这个命令的时候， 必须要在db.json文件夹下， 不然会启动失败</p>
<p><img src="/posts/56140/image-20221002071632112.png"></p>
<p>之后你就可以直接在本地访问到信息了</p>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>axios的基本使用</tag>
      </tags>
  </entry>
  <entry>
    <title>axios源码分析</title>
    <url>/posts/37630.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="axios源码分析"><a href="#axios源码分析" class="headerlink" title="axios源码分析"></a>axios源码分析</h1><p>打开之后， 它算是一个工程，里面有很多文件夹和文件，同学们可以一边看源码一边看我的分析。</p>
<span id="more"></span>

<img src="/posts/37630/37630/image-20220930144530311.png" class="" title="image-20220930144530311">

<p>我这里列出一些重点的：</p>
<img src="/posts/37630/37630/image-20220930144954851.png" class="" title="image-20220930144954851">

<p>先看看axios.js文件中的内容</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line">启用严格模式</span><br><span class="line">axios入口文件</span><br><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'./utils.js'</span>;</span><br><span class="line">引入工具</span><br><span class="line"><span class="keyword">import</span> bind <span class="keyword">from</span> <span class="string">'./helpers/bind.js'</span>;</span><br><span class="line">引入绑定函数， 创建函数</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Axios</span> <span class="keyword">from</span> <span class="string">'./core/Axios.js'</span>;</span><br><span class="line">引入<span class="title class_">Axios</span>主文件</span><br><span class="line"><span class="keyword">import</span> mergeConfig <span class="keyword">from</span> <span class="string">'./core/mergeConfig.js'</span>;</span><br><span class="line">引入合并配置的函数</span><br><span class="line"><span class="keyword">import</span> defaults <span class="keyword">from</span> <span class="string">'./defaults/index.js'</span>;</span><br><span class="line">导入默认配置</span><br></pre></td></tr></tbody></table></figure>

<p>axios怎么来的，我们可以清楚， axios是通过createInstance创建而来的，下面我们来看看createInstance是怎么运作的</p>
<p>我们先打开lib/core/Axios.js文件：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'./../utils.js'</span>;</span><br><span class="line"><span class="keyword">import</span> buildURL <span class="keyword">from</span> <span class="string">'../helpers/buildURL.js'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">InterceptorManager</span> <span class="keyword">from</span> <span class="string">'./InterceptorManager.js'</span>;</span><br><span class="line"><span class="keyword">import</span> dispatchRequest <span class="keyword">from</span> <span class="string">'./dispatchRequest.js'</span>;</span><br><span class="line"><span class="keyword">import</span> mergeConfig <span class="keyword">from</span> <span class="string">'./mergeConfig.js'</span>;</span><br><span class="line"><span class="keyword">import</span> buildFullPath <span class="keyword">from</span> <span class="string">'./buildFullPath.js'</span>;</span><br><span class="line"><span class="keyword">import</span> validator <span class="keyword">from</span> <span class="string">'../helpers/validator.js'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AxiosHeaders</span> <span class="keyword">from</span> <span class="string">'./AxiosHeaders.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validators = validator.<span class="property">validators</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new instance of Axios</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">Object</span>} instanceConfig The default config for the instance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">Axios</span>} A new instance of Axios</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">开始对axios进行构造</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Axios</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">instanceConfig</span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">defaults</span> = instanceConfig;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">interceptors</span> = {</span><br><span class="line">      <span class="attr">request</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>(),</span><br><span class="line">      <span class="attr">response</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>()</span><br><span class="line">    };</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Dispatch a request</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> {<span class="type">String|Object</span>} configOrUrl The config specific for this request (merged with this.defaults)</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> {<span class="type">?Object</span>} <span class="variable">config</span></span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> {<span class="type">Promise</span>} The Promise to be fulfilled</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">request</span>(<span class="params">configOrUrl, config</span>) {</span><br><span class="line">    <span class="comment">/*eslint no-param-reassign:0*/</span></span><br><span class="line">    <span class="comment">// Allow for axios('example/url'[, config]) a la fetch API</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> configOrUrl === <span class="string">'string'</span>) {</span><br><span class="line">      config = config || {};</span><br><span class="line">      config.<span class="property">url</span> = configOrUrl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      config = configOrUrl || {};</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    config = <span class="title function_">mergeConfig</span>(<span class="variable language_">this</span>.<span class="property">defaults</span>, config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> transitional = config.<span class="property">transitional</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transitional !== <span class="literal">undefined</span>) {</span><br><span class="line">      validator.<span class="title function_">assertOptions</span>(transitional, {</span><br><span class="line">        <span class="attr">silentJSONParsing</span>: validators.<span class="title function_">transitional</span>(validators.<span class="property">boolean</span>),</span><br><span class="line">        <span class="attr">forcedJSONParsing</span>: validators.<span class="title function_">transitional</span>(validators.<span class="property">boolean</span>),</span><br><span class="line">        <span class="attr">clarifyTimeoutError</span>: validators.<span class="title function_">transitional</span>(validators.<span class="property">boolean</span>)</span><br><span class="line">      }, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set config.method</span></span><br><span class="line">    config.<span class="property">method</span> = (config.<span class="property">method</span> || <span class="variable language_">this</span>.<span class="property">defaults</span>.<span class="property">method</span> || <span class="string">'get'</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flatten headers</span></span><br><span class="line">    <span class="keyword">const</span> defaultHeaders = config.<span class="property">headers</span> &amp;&amp; utils.<span class="title function_">merge</span>(</span><br><span class="line">      config.<span class="property">headers</span>.<span class="property">common</span>,</span><br><span class="line">      config.<span class="property">headers</span>[config.<span class="property">method</span>]</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    defaultHeaders &amp;&amp; utils.<span class="title function_">forEach</span>(</span><br><span class="line">      [<span class="string">'delete'</span>, <span class="string">'get'</span>, <span class="string">'head'</span>, <span class="string">'post'</span>, <span class="string">'put'</span>, <span class="string">'patch'</span>, <span class="string">'common'</span>],</span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">cleanHeaderConfig</span>(<span class="params">method</span>) {</span><br><span class="line">        <span class="keyword">delete</span> config.<span class="property">headers</span>[method];</span><br><span class="line">      }</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    config.<span class="property">headers</span> = <span class="keyword">new</span> <span class="title class_">AxiosHeaders</span>(config.<span class="property">headers</span>, defaultHeaders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// filter out skipped interceptors</span></span><br><span class="line">    <span class="keyword">const</span> requestInterceptorChain = [];</span><br><span class="line">    <span class="keyword">let</span> synchronousRequestInterceptors = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> <span class="title function_">unshiftRequestInterceptors</span>(<span class="params">interceptor</span>) {</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> interceptor.<span class="property">runWhen</span> === <span class="string">'function'</span> &amp;&amp; interceptor.<span class="title function_">runWhen</span>(config) === <span class="literal">false</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      synchronousRequestInterceptors = synchronousRequestInterceptors &amp;&amp; interceptor.<span class="property">synchronous</span>;</span><br><span class="line"></span><br><span class="line">      requestInterceptorChain.<span class="title function_">unshift</span>(interceptor.<span class="property">fulfilled</span>, interceptor.<span class="property">rejected</span>);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> responseInterceptorChain = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> <span class="title function_">pushResponseInterceptors</span>(<span class="params">interceptor</span>) {</span><br><span class="line">      responseInterceptorChain.<span class="title function_">push</span>(interceptor.<span class="property">fulfilled</span>, interceptor.<span class="property">rejected</span>);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!synchronousRequestInterceptors) {</span><br><span class="line">      <span class="keyword">const</span> chain = [dispatchRequest.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="literal">undefined</span>];</span><br><span class="line">      chain.<span class="property">unshift</span>.<span class="title function_">apply</span>(chain, requestInterceptorChain);</span><br><span class="line">      chain.<span class="property">push</span>.<span class="title function_">apply</span>(chain, responseInterceptorChain);</span><br><span class="line">      len = chain.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">      promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(config);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (i &lt; len) {</span><br><span class="line">        promise = promise.<span class="title function_">then</span>(chain[i++], chain[i++]);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> promise;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    len = requestInterceptorChain.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newConfig = config;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) {</span><br><span class="line">      <span class="keyword">const</span> onFulfilled = requestInterceptorChain[i++];</span><br><span class="line">      <span class="keyword">const</span> onRejected = requestInterceptorChain[i++];</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        newConfig = <span class="title function_">onFulfilled</span>(newConfig);</span><br><span class="line">      } <span class="keyword">catch</span> (error) {</span><br><span class="line">        onRejected.<span class="title function_">call</span>(<span class="variable language_">this</span>, error);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      promise = dispatchRequest.<span class="title function_">call</span>(<span class="variable language_">this</span>, newConfig);</span><br><span class="line">    } <span class="keyword">catch</span> (error) {</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    len = responseInterceptorChain.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) {</span><br><span class="line">      promise = promise.<span class="title function_">then</span>(responseInterceptorChain[i++], responseInterceptorChain[i++]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    往axios原型上添加getUri方法</span><br><span class="line">  <span class="title function_">getUri</span>(<span class="params">config</span>) {</span><br><span class="line">    config = <span class="title function_">mergeConfig</span>(<span class="variable language_">this</span>.<span class="property">defaults</span>, config);</span><br><span class="line">    <span class="keyword">const</span> fullPath = <span class="title function_">buildFullPath</span>(config.<span class="property">baseURL</span>, config.<span class="property">url</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">buildURL</span>(fullPath, config.<span class="property">params</span>, config.<span class="property">paramsSerializer</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide aliases for supported request methods</span></span><br><span class="line">utils.<span class="property">forEach</span>是专门用来遍历数组的</span><br><span class="line">utils.<span class="title function_">forEach</span>([<span class="string">'delete'</span>, <span class="string">'get'</span>, <span class="string">'head'</span>, <span class="string">'options'</span>], <span class="keyword">function</span> <span class="title function_">forEachMethodNoData</span>(<span class="params">method</span>) {</span><br><span class="line">  <span class="comment">/*eslint func-names:0*/</span></span><br><span class="line">    往axios原型上面加方法，分别是<span class="keyword">delete</span>，get， head，options</span><br><span class="line">  <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[method] = <span class="keyword">function</span>(<span class="params">url, config</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(<span class="title function_">mergeConfig</span>(config || {}, {</span><br><span class="line">      method,</span><br><span class="line">      url,</span><br><span class="line">      <span class="attr">data</span>: (config || {}).<span class="property">data</span></span><br><span class="line">    }));</span><br><span class="line">  };</span><br><span class="line">});</span><br><span class="line">我们这里的post， put ，patch也是如此</span><br><span class="line">utils.<span class="title function_">forEach</span>([<span class="string">'post'</span>, <span class="string">'put'</span>, <span class="string">'patch'</span>], <span class="keyword">function</span> <span class="title function_">forEachMethodWithData</span>(<span class="params">method</span>) {</span><br><span class="line">  <span class="comment">/*eslint func-names:0*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">generateHTTPMethod</span>(<span class="params">isForm</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">httpMethod</span>(<span class="params">url, data, config</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(<span class="title function_">mergeConfig</span>(config || {}, {</span><br><span class="line">        method,</span><br><span class="line">        <span class="attr">headers</span>: isForm ? {</span><br><span class="line">          <span class="string">'Content-Type'</span>: <span class="string">'multipart/form-data'</span></span><br><span class="line">        } : {},</span><br><span class="line">        url,</span><br><span class="line">        data</span><br><span class="line">      }));</span><br><span class="line">    };</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[method] = <span class="title function_">generateHTTPMethod</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[method + <span class="string">'Form'</span>] = <span class="title function_">generateHTTPMethod</span>(<span class="literal">true</span>);</span><br><span class="line">});</span><br><span class="line">运行完该文件后， axios原型上面就多了很多方法，之后我们axios的实例对象就可以调用这些方法，接着就是导出这个原型对象</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Axios</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>再来看看lib/axios.js</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'./utils.js'</span>;</span><br><span class="line"><span class="keyword">import</span> bind <span class="keyword">from</span> <span class="string">'./helpers/bind.js'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Axios</span> <span class="keyword">from</span> <span class="string">'./core/Axios.js'</span>;</span><br><span class="line"><span class="keyword">import</span> mergeConfig <span class="keyword">from</span> <span class="string">'./core/mergeConfig.js'</span>;</span><br><span class="line"><span class="keyword">import</span> defaults <span class="keyword">from</span> <span class="string">'./defaults/index.js'</span>;</span><br><span class="line"><span class="keyword">import</span> formDataToJSON <span class="keyword">from</span> <span class="string">'./helpers/formDataToJSON.js'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CanceledError</span> <span class="keyword">from</span> <span class="string">'./cancel/CanceledError.js'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CancelToken</span> <span class="keyword">from</span><span class="string">'./cancel/CancelToken.js'</span>;</span><br><span class="line"><span class="keyword">import</span> isCancel <span class="keyword">from</span><span class="string">'./cancel/isCancel.js'</span>;</span><br><span class="line"><span class="keyword">import</span> {<span class="variable constant_">VERSION</span>} <span class="keyword">from</span> <span class="string">'./env/data.js'</span>;</span><br><span class="line"><span class="keyword">import</span> toFormData <span class="keyword">from</span> <span class="string">'./helpers/toFormData.js'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AxiosError</span> <span class="keyword">from</span> <span class="string">'./core/AxiosError.js'</span>;</span><br><span class="line"><span class="keyword">import</span> spread <span class="keyword">from</span> <span class="string">'./helpers/spread.js'</span>;</span><br><span class="line"><span class="keyword">import</span> isAxiosError <span class="keyword">from</span> <span class="string">'./helpers/isAxiosError.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an instance of Axios</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">Object</span>} defaultConfig The default config for the instance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> {<span class="type">Axios</span>} A new instance of Axios</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createInstance</span>(<span class="params">defaultConfig</span>) {</span><br><span class="line">  <span class="keyword">const</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(defaultConfig);</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="title function_">bind</span>(<span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy axios.prototype to instance</span></span><br><span class="line">  utils.<span class="title function_">extend</span>(instance, <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>, context, {<span class="attr">allOwnKeys</span>: <span class="literal">true</span>});</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy context to instance</span></span><br><span class="line">  utils.<span class="title function_">extend</span>(instance, context, <span class="literal">null</span>, {<span class="attr">allOwnKeys</span>: <span class="literal">true</span>});</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Factory for creating new instances</span></span><br><span class="line">  instance.<span class="property">create</span> = <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">instanceConfig</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createInstance</span>(<span class="title function_">mergeConfig</span>(defaultConfig, instanceConfig));</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the default instance to be exported</span></span><br><span class="line"><span class="keyword">const</span> axios = <span class="title function_">createInstance</span>(defaults);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose Axios class to allow class inheritance</span></span><br><span class="line">axios.<span class="property">Axios</span> = <span class="title class_">Axios</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose Cancel &amp; CancelToken</span></span><br><span class="line">axios.<span class="property">CanceledError</span> = <span class="title class_">CanceledError</span>;</span><br><span class="line">axios.<span class="property">CancelToken</span> = <span class="title class_">CancelToken</span>;</span><br><span class="line">axios.<span class="property">isCancel</span> = isCancel;</span><br><span class="line">axios.<span class="property">VERSION</span> = <span class="variable constant_">VERSION</span>;</span><br><span class="line">axios.<span class="property">toFormData</span> = toFormData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose AxiosError class</span></span><br><span class="line">axios.<span class="property">AxiosError</span> = <span class="title class_">AxiosError</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alias for CanceledError for backward compatibility</span></span><br><span class="line">axios.<span class="property">Cancel</span> = axios.<span class="property">CanceledError</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose all/spread</span></span><br><span class="line">axios.<span class="property">all</span> = <span class="keyword">function</span> <span class="title function_">all</span>(<span class="params">promises</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">axios.<span class="property">spread</span> = spread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose isAxiosError</span></span><br><span class="line">axios.<span class="property">isAxiosError</span> = isAxiosError;</span><br><span class="line"></span><br><span class="line">axios.<span class="property">formToJSON</span> = <span class="function"><span class="params">thing</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">formDataToJSON</span>(utils.<span class="title function_">isHTMLForm</span>(thing) ? <span class="keyword">new</span> <span class="title class_">FormData</span>(thing) : thing);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<img src="/posts/37630/37630/image-20221002153656425.png" class="" title="image-20221002153656425">

<p>换句话说， 当Axios.js执行完之后， context  = new Axios(defaultConfig)这里的context就已经有了上面配置的对象和方法</p>
<img src="/posts/37630/37630/image-20221002154145857.png" class="" title="image-20221002154145857">

<p>这就是为什么我们在使用axios的时候， 既可以把他当成函数去用， 也可以直接调用上面的方法，我们可以直接去axios.post()或者是axios.requst()， 这个就是原因。</p>
<img src="/posts/37630/37630/image-20221002154532596.png" class="" title="image-20221002154532596">

<p>utils.extend()这个是精髓， 它可以将对象的方法进行复制，图中，utils.extend(instance, context),就是将实例对象的方法拓展到instance身上,我们刚才看了，Axios.prototype上面有着很多的方法， 而我们instance这里是一个函数， 然后给他上面添加这些方法， 就是我们在创建instace实例的时候 ， 我们一直强调， 它是一个函数并非对象， 这样就解释的通了</p>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>axios源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>composition ApI 和 options API 的区别</title>
    <url>/posts/2660.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="composition-ApI-和-options-API-的区别"><a href="#composition-ApI-和-options-API-的区别" class="headerlink" title="composition ApI 和 options API 的区别"></a>composition ApI 和 options API 的区别</h1><h2 id="面试官：Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#面试官：Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="面试官：Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>面试官：Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h2><img src="/posts/2660/2660/image-20221209153316265.png" class="" title="image-20221209153316265">

<span id="more"></span>

<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p><code>Composition API</code> 可以说是<code>Vue3</code>的最大特点，那么为什么要推出<code>Composition Api</code>，解决了什么问题？</p>
<p>通常使用<code>Vue2</code>开发的项目，普遍会存在以下问题：</p>
<ul>
<li>代码的可读性随着组件变大而变差</li>
<li>每一种代码复用的方式，都存在缺点</li>
<li>TypeScript支持有限</li>
</ul>
<p>以上通过使用<code>Composition Api</code>都能迎刃而解</p>
<!-- more -->

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一、Options-Api"><a href="#一、Options-Api" class="headerlink" title="一、Options Api"></a>一、Options Api</h3><p><code>Options API</code>，即大家常说的选项API，即以<code>vue</code>为后缀的文件，通过定义<code>methods</code>，<code>computed</code>，<code>watch</code>，<code>data</code>等属性与方法，共同处理页面逻辑</p>
<p>如下图：</p>
<img src="/posts/2660/2660/image-20221209153357215.png" class="" title="image-20221209153357215">

<p>可以看到<code>Options</code>代码编写方式，如果是组件状态，则写在<code>data</code>属性上，如果是方法，则写在<code>methods</code>属性上…</p>
<p>用组件的选项 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组织逻辑在大多数情况下都有效</p>
<p>然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解</p>
<h3 id="二、Composition-Api"><a href="#二、Composition-Api" class="headerlink" title="二、Composition Api"></a>二、Composition Api</h3><p>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p>
<p>即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API</p>
<img src="/posts/2660/2660/image-20221209153423908.png" class="" title="image-20221209153423908">

<h3 id="三、对比"><a href="#三、对比" class="headerlink" title="三、对比"></a>三、对比</h3><p>下面对<code>Composition Api</code>与<code>Options Api</code>进行两大方面的比较</p>
<ul>
<li>逻辑组织</li>
<li>逻辑复用</li>
</ul>
<h4 id="逻辑组织"><a href="#逻辑组织" class="headerlink" title="逻辑组织"></a>逻辑组织</h4><h5 id="Options-API"><a href="#Options-API" class="headerlink" title="Options API"></a>Options API</h5><p>假设一个组件是一个大型组件，其内部有很多处理逻辑关注点（对应下图不用颜色）</p>
<img src="/posts/2660/2660/image-20221209153447661.png" class="" title="image-20221209153447661">

<p>可以看到，这种碎片化使得理解和维护复杂组件变得困难</p>
<p>选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块</p>
<h5 id="Compostion-API"><a href="#Compostion-API" class="headerlink" title="Compostion API"></a>Compostion API</h5><p>而<code>Compositon API</code>正是解决上述问题，将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去</p>
<p>下面举个简单例子，将处理<code>count</code>属性相关的代码放在同一个函数了</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useCount</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">let</span> count = <span class="title function_">ref</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="keyword">return</span> count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleConut</span> = (<span class="params"></span>) =&gt; {</span><br><span class="line">        count.<span class="property">value</span> = count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">        count,</span><br><span class="line">        double,</span><br><span class="line">        handleConut,</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>组件上中使用<code>count</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>({</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">const</span> { count, double, handleConut } = <span class="title function_">useCount</span>();</span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">            count,</span><br><span class="line">            double,</span><br><span class="line">            handleConut</span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>再来一张图进行对比，可以很直观地感受到 <code>Composition API</code>在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可</p>
<img src="/posts/2660/2660/image-20221209153504853.png" class="" title="image-20221209153504853">

<h4 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h4><p>在<code>Vue2</code>中，我们是用过<code>mixin</code>去复用相同的逻辑</p>
<p>下面举个例子，我们会另起一个<code>mixin.js</code>文件</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MoveMixin</span> = {</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">    };</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  <span class="attr">methods</span>: {</span><br><span class="line">    <span class="title function_">handleKeyup</span>(<span class="params">e</span>) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">      <span class="comment">// 上下左右 x y</span></span><br><span class="line">      <span class="keyword">switch</span> (e.<span class="property">code</span>) {</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ArrowUp"</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ArrowDown"</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ArrowLeft"</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ArrowRight"</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">"keyup"</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">"keyup"</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>然后在组件中使用</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Mouse position: x {{ x }} / y {{ y }}</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> mousePositionMixin <span class="keyword">from</span> <span class="string">'./mouse'</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">mixins</span>: [mousePositionMixin]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">}</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>使用单个<code>mixin</code>似乎问题不大，但是当我们一个组件混入大量不同的 <code>mixins</code> 的时候</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">mixins</span>: [mousePositionMixin, fooMixin, barMixin, otherMixin]</span><br></pre></td></tr></tbody></table></figure>

<p>会存在两个非常明显的问题：</p>
<ul>
<li>命名冲突</li>
<li>数据来源不清晰</li>
</ul>
<p>现在通过<code>Compositon API</code>这种方式改写上面的代码</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { onMounted, onUnmounted, reactive } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useMove</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">const</span> position = <span class="title function_">reactive</span>({</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleKeyup</span> = (<span class="params">e</span>) =&gt; {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">    <span class="comment">// 上下左右 x y</span></span><br><span class="line">    <span class="keyword">switch</span> (e.<span class="property">code</span>) {</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"ArrowUp"</span>:</span><br><span class="line">        <span class="comment">// y.value--;</span></span><br><span class="line">        position.<span class="property">y</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"ArrowDown"</span>:</span><br><span class="line">        <span class="comment">// y.value++;</span></span><br><span class="line">        position.<span class="property">y</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"ArrowLeft"</span>:</span><br><span class="line">        <span class="comment">// x.value--;</span></span><br><span class="line">        position.<span class="property">x</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"ArrowRight"</span>:</span><br><span class="line">        <span class="comment">// x.value++;</span></span><br><span class="line">        position.<span class="property">x</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">"keyup"</span>, handleKeyup);</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">"keyup"</span>, handleKeyup);</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> { position };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在组件中使用</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Mouse position: x {{ x }} / y {{ y }}</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> { useMove } <span class="keyword">from</span> <span class="string">"./useMove"</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> { toRefs } <span class="keyword">from</span> <span class="string">"vue"</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> { position } = <span class="title function_">useMove</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> { x, y } = <span class="title function_">toRefs</span>(position);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      x,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      y,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    };</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  },</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">};</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>在逻辑组织和逻辑复用方面，<code>Composition API</code>是优于<code>Options API</code></li>
<li>因为<code>Composition API</code>几乎是函数，会有更好的类型推断。</li>
<li><code>Composition API</code>对 <code>tree-shaking</code> 友好，代码也更容易压缩</li>
<li><code>Composition API</code>中见不到<code>this</code>的使用，减少了<code>this</code>指向不明的情况</li>
<li>如果是小型组件，可以继续使用<code>Options API</code>，也是十分友好的</li>
</ul>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p>​    @js语音答题社区</p>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>composition ApI 和 options API 的区别</tag>
      </tags>
  </entry>
  <entry>
    <title>axios拦截器实现原理</title>
    <url>/posts/5590.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="axios拦截器实现原理"><a href="#axios拦截器实现原理" class="headerlink" title="axios拦截器实现原理"></a>axios拦截器实现原理</h1><p>先用拦截器实现下面这个案例：</p>
<span id="more"></span>

<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'请求拦截器1 成功'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> config;</span></span><br><span class="line"><span class="language-javascript">        },<span class="keyword">function</span> (<span class="params">error</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'请求拦截器1 失败'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span></span><br><span class="line"><span class="language-javascript">        })</span></span><br><span class="line"><span class="language-javascript">        axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'请求拦截器2 成功'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> config;</span></span><br><span class="line"><span class="language-javascript">        },<span class="keyword">function</span> (<span class="params">error</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'请求拦截器2 失败'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span></span><br><span class="line"><span class="language-javascript">        })</span></span><br><span class="line"><span class="language-javascript">        axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'响应拦截器1 成功'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> response;</span></span><br><span class="line"><span class="language-javascript">        },<span class="keyword">function</span> (<span class="params">error</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'响应拦截器1 失败'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span></span><br><span class="line"><span class="language-javascript">        })</span></span><br><span class="line"><span class="language-javascript">        axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'响应拦截器2 成功'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> response;</span></span><br><span class="line"><span class="language-javascript">        },<span class="keyword">function</span> (<span class="params">error</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'响应拦截器2 失败'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span></span><br><span class="line"><span class="language-javascript">        })</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 发送请求</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">axios</span>({</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">method</span>: <span class="string">"GET"</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>:<span class="string">"http://localhost:3000/posts"</span></span></span><br><span class="line"><span class="language-javascript">        }).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span></span><br><span class="line"><span class="language-javascript">        }).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span></span><br><span class="line"><span class="language-javascript">        })</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果一切正常的话， 它的打印结果应该是这样的：</p>
<img src="/posts/5590/5590/image-20221004132401288.png" class="" title="image-20221004132401288">

<img src="/posts/5590/5590/image-20221004132758252.png" class="" title="image-20221004132758252">

<p>我们来解释一下这个axios上面的interceptors是哪里来的，我们打开Axios.js文件， 如图</p>
<img src="/posts/5590/5590/image-20221004132954521.png" class="" title="image-20221004132954521">

<p>因为里面有this.interceptors来进行构造，里面又有一个request对象，所以：、</p>
<p>axios.interceptors.request = new InterceptorManager ()</p>
<p>而axios.interceptoes.request.use = new InterceptorManager().use()</p>
<p>接着， 我们来到了这里</p>
<img src="/posts/5590/5590/image-20221004133521420.png" class="" title="image-20221004133521420">

<p>这里的this.hanlders是当你new InterceptorManager()的时候创建的一个空数组：</p>
<img src="/posts/5590/5590/image-20221004133800774.png" class="" title="image-20221004133800774">

<p>然后你调用上面的use方法的时候：就给this.handlers上面push了一些东西：</p>
<img src="/posts/5590/5590/image-20221004133944352.png" class="" title="image-20221004133944352">

<p>接着往下执行， 你会看到：</p>
<img src="/posts/5590/5590/image-20221004134318706.png" class="" title="image-20221004134318706">

<p>此时。halders上面已经有数据了，当执行到第二个拦截器的时候：</p>
<img src="/posts/5590/5590/image-20221004135627537.png" class="" title="image-20221004135627537">

<p>handlers又变了，接着往下执行：</p>
<img src="/posts/5590/5590/image-20221004140014732.png" class="" title="image-20221004140014732">

<p>这是响应拦截器添加的回调，同理：</p>
<img src="/posts/5590/5590/image-20221004140106265.png" class="" title="image-20221004140106265">

<p>和请求拦截器是同样的原理。</p>
<p>为什么请求拦截器顺序是倒着的， 也就是如图所示这个样子？</p>
<img src="/posts/5590/5590/image-20221004141149745.png" class="" title="image-20221004141149745">

<p>原因就是 在请求拦截器中， requestInterceptorChain使用了unshift方法， 而在响应拦截器中使用了push方法</p>
<p>use在使用的时候只是进行了一个保存， 就是把回调保存在了request.handlers上面</p>
<p>以上就是拦截器的工作原理</p>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>axios拦截器实现原理</tag>
      </tags>
  </entry>
  <entry>
    <title>css框架的选择</title>
    <url>/posts/45331.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="Bootstrap-vs-Tailwind-CSS-你需要哪一个？"><a href="#Bootstrap-vs-Tailwind-CSS-你需要哪一个？" class="headerlink" title="Bootstrap vs Tailwind CSS | 你需要哪一个？"></a>Bootstrap vs Tailwind CSS | 你需要哪一个？</h1><p>CSS 框架已经在 web 开发中流行了10多年，新的框架不断涌现。当然，如果有“最好的”，这当然是一个可以接受的问题。在本文中，我们将研究最流行的 CSS 框架 Bootstrap 和 Tailwind CSS。</p>
<span id="more"></span>

<img src="/posts/45331/45331/image-20221023171003026.png" class="" title="image-20221023171003026">

<p>在探讨这个问题之前， 我们先来谈谈为什么需要css框架</p>
<h2 id="为什么需要css框架？"><a href="#为什么需要css框架？" class="headerlink" title="为什么需要css框架？"></a>为什么需要css框架？</h2><p>96.2% 的在线网站使用 CSS。然而，在一个新的网站或者应用程序上编写 CSS 会让你觉得自己是个重造轮子。程序员应该让生活变得更简单，所以，不能每天做同样的事情，对吗？</p>
<p>如果你喜欢在每个单独的项目中使用普通的 CSS，这意味着你将花费大量的时间用 CSS 重写相同的东西。因此，人们有这个问题，并选择了一些简单的方法。这里我们开始使用 CSS 框架。使用 CSS 框架，我们可以更快地编写设计代码。在这里，时间等于金钱。如果您可以在约70% 的时间内以可接受的性能创建相同的设计，难道不值得吗？</p>
<h2 id="什么是Bootstrap？"><a href="#什么是Bootstrap？" class="headerlink" title="什么是Bootstrap？"></a>什么是Bootstrap？</h2><img src="/posts/45331/45331/image-20221023171520762.png" class="" title="image-20221023171520762">

<p>Bootstrap 是目前使用时间最长的 CSS 框架之一。它是2011年由 Twitter 创建的。我们大多数人使用 Bootstrap 是因为它为通用组件提供了基于 CSS 的模板和类。因此，您可以只复制和粘贴所有常见的组件与 Bootstrap 和使用所有响应性和移动优先的设计。</p>
<p>例如，我们几乎无法想象一个没有导航栏的网站，对吗？使用 Bootstrap，我们不需要从头开始编写。我们可以从模板中选择并使用它们。如果您愿意，您可以根据自己的需要对其进行定制。</p>
<h2 id="什么是Tailwind-CSS"><a href="#什么是Tailwind-CSS" class="headerlink" title="什么是Tailwind CSS?"></a>什么是Tailwind CSS?</h2><img src="/posts/45331/45331/image-20221023171819064.png" class="" title="image-20221023171819064">

<p>另一方面，TailwindCSS 是由 Adam Wathan 和 Steve Schoger 在2017年创建的。他们将 Tailwind CSS 描述为“实用优先的 CSS 框架，包含了构建任何设计的类”。与 Bootstrap 不同，TailwindCSS 不提供任何一次单击即可使用的预构建组件。它们只是提供了有用的工具和 CSS 类来尽可能快地构建我们的设计。</p>
<p>另外，还有一个额外的 Tailwind CSS的功能是，它监视你写了什么，并删除你没有使用的一切。因此，与 Bootstrap 不同，您的项目不会有任何未使用的 CSS 类，并且由于这个原因性能会降低。在这种情况下使用 TailwindCSS 没有任何负面影响。</p>
<p>最后，Tailwind 团队还创建了可以使用的预构建组件和页面。他们中的大多数是付费的，但他们提供完全可定制的现成的使用组件在可承受的价格。点击</p>
<p>查看Tailwind UI。</p>
<h2 id="Tailwind-CSS-与-Bootstrap-的相似之处"><a href="#Tailwind-CSS-与-Bootstrap-的相似之处" class="headerlink" title="Tailwind CSS 与 Bootstrap 的相似之处"></a>Tailwind CSS 与 Bootstrap 的相似之处</h2><img src="/posts/45331/45331/image-20221023172901949.png" class="" title="image-20221023172901949">

<p>如果我们比较 Bootstrap 和 Tailwind CSS，我们必须知道它们的相似之处。这两个框架都可以帮助您编写大量的 CSS。因此，既然您不需要从头开始编写太多的 CSS，那么您可以将更多的精力放在构建 UI 及其功能上。</p>
<p>但是有时候，在 HTML 中编写所有这些预构建的 CSS 类可能很困难。因为 HTML 中的太多类可能看起来有点像忙碌的标记。无论如何，很难反驳这样一个事实，即这些框架既简化了构建 UI 的过程，又加快了构建 UI 的速度。</p>
<h2 id="哪些公司使用-Bootstrap？"><a href="#哪些公司使用-Bootstrap？" class="headerlink" title="哪些公司使用 Bootstrap？"></a>哪些公司使用 Bootstrap？</h2><img src="/posts/45331/45331/image-20221023173302066.png" class="" title="image-20221023173302066">

<p>Bootstrap 是一个开放源码工具，包含160K GitHub stars和77.4 K GitHub forks。随着这种流行，有这么多流行的公司和网站创建与 Bootstrap。</p>
<p>万事达、 Spotify、 LinkedIn、 Twitter、 Lyft、 Snapchat、 Udemy、 Upwork、 Duolingo、邮递员、甚至彭博，以及其他更喜欢 Bootstrap 的网站。</p>
<h2 id="哪些公司使用-Tailwind-CSS"><a href="#哪些公司使用-Tailwind-CSS" class="headerlink" title="哪些公司使用 Tailwind CSS?"></a>哪些公司使用 Tailwind CSS?</h2><img src="/posts/45331/45331/image-20221023173514822.png" class="" title="image-20221023173514822">

<p>Tailwind 也是一个开源工具，拥有61.5 K 的 GitHub stars 和3.1 K 的 GitHub forks 。当然，它不如 Bootstrap 流行，但是越来越多的公司和网站使用 Tailwind CSS。</p>
<p>来自 Buzzfeed、 Shed、 TED、 Stripe、 media、 Meetup、 Kickstarter、 Twitch、 Heroku、星巴克、必胜客、 NBA 网站、欧洲电视台、俱乐部、 gitHub CoPilot、 React Beta Documents、 Netflix 的十佳网站，以及更多喜欢 Tailwind CSS 的网站和项目。</p>
<h2 id="哪个更好？"><a href="#哪个更好？" class="headerlink" title="哪个更好？"></a>哪个更好？</h2><p>好吧，让我们回到真正的问题上来，你来到这个岗位的原因。TailwindCSS 的 Bootstrap 是否比另一个更好？在我看来，两者都是项目的有效选择。因此，没有“更好的框架”。而且，除了这两者之外，根本就没有“最好的 CSS 框架”。</p>
<p>如果您喜欢从头开始制作完全自定义的组件和设计的自由，但是您不想编写 Vanilla CSS 并担心小的细节，那么 Tailwind 是您的最佳选择。</p>
<p>另一方面，如果设计不是你的强项，你宁愿不去想它，Bootstrap 是一个更好的选择与预构建 UI 组件和更多</p>
<h2 id="2023年的Vanilla-CSS-怎么样？"><a href="#2023年的Vanilla-CSS-怎么样？" class="headerlink" title="2023年的Vanilla CSS 怎么样？"></a>2023年的Vanilla CSS 怎么样？</h2><img src="/posts/45331/45331/image-20221023173824218.png" class="" title="image-20221023173824218">

<p>当然，有一个选项我应该提到，那就是根本不使用 CSS 框架。仅仅因为 CSS 框架现在很流行，并不意味着您必须使用其中之一。CSS 本身仍然是一个有效的选择</p>
<p>当然，根据项目的不同，您必须更喜欢使用可以使用的框架，或者甚至不使用任何框架。Vanilla CSS 仍然是一个强大的工具，如果您需要处理项目的毫秒，那么您不必担心性能问题。</p>
<h2 id="最后的想法"><a href="#最后的想法" class="headerlink" title="最后的想法"></a>最后的想法</h2><img src="/posts/45331/45331/image-20221023174108912.png" class="" title="image-20221023174108912">

<p>您可能已经猜到了这篇文章的结论，但是您所使用的 CSS 框架取决于您自己、您的经验和您的项目。如果你不是一个设计师，只是想尽快把东西放在一起，那么 Bootstrap 可能是你的选择。但是如果您想要自定义设计的完全自由，那么 TailwindCSS 可能是您的更好选择。</p>
<p>就个人而言，我更倾向于 Tailwind CSS 阵营。我绝对不是一个获奖的设计师，可能永远也不会是。但是，由于 Tailwind CSS 的逻辑，我不需要考虑浏览器兼容性或其他问题。我可以专注于设计什么是在我的头上充分自由，这让我觉得很舒服。</p>
<p>那你呢，你属于哪个阵营？你是使用 CSS 框架还是更喜欢普通的版本？如果使用其中之一，哪一个是你最喜欢的？请在评论中告诉我！</p>
</body></html>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css框架的选择</tag>
      </tags>
  </entry>
  <entry>
    <title>data属性为什么是一个函数并非对象</title>
    <url>/posts/43499.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="面试官：为什么data属性是一个函数而不是一个对象？"><a href="#面试官：为什么data属性是一个函数而不是一个对象？" class="headerlink" title="面试官：为什么data属性是一个函数而不是一个对象？"></a>面试官：为什么data属性是一个函数而不是一个对象？</h1><img src="/posts/43499/43499/image-20221017055354871.png" class="" title="image-20221017055354871">

<h2 id="一、实例和组件定义data的区别"><a href="#一、实例和组件定义data的区别" class="headerlink" title="一、实例和组件定义data的区别"></a>一、实例和组件定义data的区别</h2><p><code>vue</code>实例的时候定义<code>data</code>属性既可以是一个对象，也可以是一个函数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>({</span><br><span class="line">    <span class="attr">el</span>:<span class="string">"#app"</span>,</span><br><span class="line">    <span class="comment">// 对象格式</span></span><br><span class="line">    <span class="attr">data</span>:{</span><br><span class="line">        <span class="attr">foo</span>:<span class="string">"foo"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 函数格式</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>){</span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">             <span class="attr">foo</span>:<span class="string">"foo"</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>组件中定义<code>data</code>属性，只能是一个函数</p>
<span id="more"></span>

<p>如果为组件<code>data</code>直接定义为一个对象</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">'component1'</span>,{</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`&lt;div&gt;组件&lt;/div&gt;`</span>,</span><br><span class="line">    <span class="attr">data</span>:{</span><br><span class="line">        <span class="attr">foo</span>:<span class="string">"foo"</span></span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>则会得到警告信息</p>
<img src="/posts/43499/43499/image-20221017055513161.png" class="" title="image-20221017055513161">

<p>警告说明：返回的<code>data</code>应该是一个函数在每一个组件实例中</p>
<h2 id="二、组件data定义函数与对象的区别"><a href="#二、组件data定义函数与对象的区别" class="headerlink" title="二、组件data定义函数与对象的区别"></a>二、组件data定义函数与对象的区别</h2><p>上面讲到组件<code>data</code>必须是一个函数，不知道大家有没有思考过这是为什么呢？</p>
<p>在我们定义好一个组件的时候，<code>vue</code>最终都会通过<code>Vue.extend()</code>构成组件实例</p>
<p>这里我们模仿组件构造函数，定义<code>data</code>属性，采用对象的形式</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>){</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">data</span> = {</span><br><span class="line">	count : <span class="number">0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建两个组件实例</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">const componentA = new Component()</span><br><span class="line">const componentB = new Component()</span><br></pre></td></tr></tbody></table></figure>

<p>修改<code>componentA</code>组件<code>data</code>属性的值，<code>componentB</code>中的值也发生了改变</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 0</span></span><br><span class="line">componentA.<span class="property">data</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure>

<p>产生这样的原因这是两者共用了同一个内存地址，<code>componentA</code>修改的内容，同样对<code>componentB</code>产生了影响</p>
<p>如果我们采用函数的形式，则不会出现这种情况（函数返回的对象内存地址并不相同）</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>){</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">data</span> = <span class="variable language_">this</span>.<span class="title function_">data</span>()</span><br><span class="line">}</span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">data</span> = <span class="keyword">function</span> (<span class="params"></span>){</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">   		count : <span class="number">0</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>修改<code>componentA</code>组件<code>data</code>属性的值，<code>componentB</code>中的值不受影响</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 0</span></span><br><span class="line">componentA.<span class="property">data</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 0</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>vue</code>组件可能会有很多个实例，采用函数返回一个全新<code>data</code>形式，使每个实例对象的数据不会受到其他实例对象数据的污染</p>
<h2 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a>三、原理分析</h2><p>首先可以看看<code>vue</code>初始化<code>data</code>的代码，<code>data</code>的定义可以是函数也可以是对象</p>
<p>源码位置：<code>/vue-dev/src/core/instance/state.js</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) {</span><br><span class="line">  <span class="keyword">let</span> data = vm.<span class="property">$options</span>.<span class="property">data</span></span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="keyword">typeof</span> data === <span class="string">'function'</span></span><br><span class="line">    ? <span class="title function_">getData</span>(data, vm)</span><br><span class="line">    : data || {}</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>data</code>既能是<code>object</code>也能是<code>function</code>，那为什么还会出现上文警告呢？</p>
<p>别急，继续看下文</p>
<p>组件在创建的时候，会进行选项的合并</p>
<p>源码位置：<code>/vue-dev/src/core/util/options.js</code></p>
<p>自定义组件会进入<code>mergeOptions</code>进行选项合并</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) {</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options.<span class="property">_isComponent</span>) {</span><br><span class="line">      <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">      <span class="title function_">initInternalComponent</span>(vm, options)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">        <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span>),</span><br><span class="line">        options || {},</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>定义<code>data</code>会进行数据校验</p>
<p>源码位置：<code>/vue-dev/src/core/instance/init.js</code></p>
<p>这时候<code>vm</code>实例为<code>undefined</code>，进入<code>if</code>判断，若<code>data</code>类型不是<code>function</code>，则出现警告提示</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">strats.<span class="property">data</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  parentVal: any,</span></span><br><span class="line"><span class="params">  childVal: any,</span></span><br><span class="line"><span class="params">  vm?: Component</span></span><br><span class="line"><span class="params"></span>): ?<span class="title class_">Function</span> {</span><br><span class="line">  <span class="keyword">if</span> (!vm) {</span><br><span class="line">    <span class="keyword">if</span> (childVal &amp;&amp; <span class="keyword">typeof</span> childVal !== <span class="string">"function"</span>) {</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">"production"</span> &amp;&amp;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">'The "data" option should be a function '</span> +</span><br><span class="line">            <span class="string">"that returns a per-instance value in component "</span> +</span><br><span class="line">            <span class="string">"definitions."</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> parentVal;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mergeDataOrFn</span>(parentVal, childVal);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mergeDataOrFn</span>(parentVal, childVal, vm);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h2><ul>
<li>根实例对象<code>data</code>可以是对象也可以是函数（根实例是单例），不会产生数据污染情况</li>
<li>组件实例对象<code>data</code>必须为函数，目的是为了防止多个组件实例对象之间共用一个<code>data</code>，产生数据污染。采用函数的形式，<code>initData</code>时会将其作为工厂函数都会返回全新<code>data</code>对象</li>
</ul>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p>@js语音答题社区</p>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>data属性</tag>
      </tags>
  </entry>
  <entry>
    <title>es6新增数据结构</title>
    <url>/posts/49882.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="es6新增数据结构"><a href="#es6新增数据结构" class="headerlink" title="es6新增数据结构"></a>es6新增数据结构</h1><h2 id="面试官：你是怎么理解ES6新增Set、Map两种数据结构的？"><a href="#面试官：你是怎么理解ES6新增Set、Map两种数据结构的？" class="headerlink" title="面试官：你是怎么理解ES6新增Set、Map两种数据结构的？"></a>面试官：你是怎么理解ES6新增Set、Map两种数据结构的？</h2><img src="/posts/49882/49882/image-20221122074456512.png" class="" title="image-20221122074456512">

<p>如果要用一句来描述，我们可以说</p>
<p><code>Set</code>是一种叫做集合的数据结构，<code>Map</code>是一种叫做字典的数据结构</p>
<span id="more"></span>

<p>什么是集合？什么又是字典？</p>
<ul>
<li>集合<br>是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合</li>
<li>字典<br>是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同</li>
</ul>
<p>区别？</p>
<ul>
<li>共同点：集合、字典都可以存储不重复的值</li>
<li>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储</li>
</ul>
<h3 id="一、Set"><a href="#一、Set" class="headerlink" title="一、Set"></a>一、Set</h3><p><code>Set</code>是<code>es6</code>新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合</p>
<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br></pre></td></tr></tbody></table></figure>

<h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p><code>Set</code>的实例关于增删改查的方法：</p>
<ul>
<li>add()</li>
<li>delete()</li>
<li>has()</li>
<li>clear()</li>
</ul>
<h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><p>添加某个值，返回 <code>Set</code> 结构本身</p>
<p>当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">add</span>(<span class="number">2</span>); <span class="comment">// 2只被添加了一次</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h5><p>删除某个值，返回一个布尔值，表示删除是否成功</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">s.<span class="title function_">delete</span>(<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<h5 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h5><p>返回一个布尔值，判断该值是否为<code>Set</code>的成员</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>

<h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><p>清除所有成员，没有返回值</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">s.<span class="title function_">clear</span>()</span><br></pre></td></tr></tbody></table></figure>

<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p><code>Set</code>实例遍历的方法有如下：</p>
<p>关于遍历的方法，有如下：</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<p><code>Set</code>的遍历顺序就是插入顺序</p>
<p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">keys</span>()) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">values</span>()) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">entries</span>()) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// ["red", "red"]</span></span><br><span class="line"><span class="comment">// ["green", "green"]</span></span><br><span class="line"><span class="comment">// ["blue", "blue"]</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">forEach</span>()<span class="string">`用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的`</span>forEach<span class="string">`方法有第二个参数，用于绑定处理函数的`</span><span class="variable language_">this</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">' : '</span> + value))</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></tbody></table></figure>

<p>扩展运算符和<code>Set</code> 结构相结合实现数组或字符串去重</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]; <span class="comment">// [3, 5, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"352255"</span>;</span><br><span class="line"><span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(str)].<span class="title function_">join</span>(<span class="string">""</span>); <span class="comment">// "352"</span></span><br></pre></td></tr></tbody></table></figure>

<p>实现并集、交集、和差集</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set {1, 2, 3, 4}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> b.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="comment">// set {2, 3}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !b.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="comment">// Set {1}</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h3><p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p>
<p><code>Map</code>本身是一个构造函数，用来生成 <code>Map</code> 数据结构</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br></pre></td></tr></tbody></table></figure>

<h4 id="增删改查-1"><a href="#增删改查-1" class="headerlink" title="增删改查"></a>增删改查</h4><p><code>Map</code> 结构的实例针对增删改查有以下属性和操作方法：</p>
<ul>
<li>size 属性</li>
<li>set()</li>
<li>get()</li>
<li>has()</li>
<li>delete()</li>
<li>clear()</li>
</ul>
<h5 id="size"><a href="#size" class="headerlink" title="size"></a>size</h5><p><code>size</code>属性返回 Map 结构的成员总数。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">'foo'</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">'bar'</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h5><p>设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构</p>
<p>如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键</p>
<p>同时返回的是当前<code>Map</code>对象，可采用链式写法</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">'edition'</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">'standard'</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">'nah'</span>)    <span class="comment">// 键是 undefined</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">'a'</span>).<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">'b'</span>).<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">'c'</span>) <span class="comment">// 链式操作</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h5><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">get<span class="string">`方法读取`</span>key<span class="string">`对应的键值，如果找不到`</span>key<span class="string">`，返回`</span><span class="literal">undefined</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = <span class="keyword">function</span>(<span class="params"></span>) {<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'hello'</span>);};</span><br><span class="line">m.<span class="title function_">set</span>(hello, <span class="string">'Hello ES6!'</span>) <span class="comment">// 键是函数</span></span><br><span class="line"></span><br><span class="line">m.<span class="title function_">get</span>(hello)  <span class="comment">// Hello ES6!</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="has-1"><a href="#has-1" class="headerlink" title="has()"></a>has()</h5><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">'edition'</span>, <span class="number">6</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">'standard'</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">'nah'</span>);</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">'edition'</span>)     <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">'years'</span>)       <span class="comment">// false</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="number">262</span>)           <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="delete-1"><a href="#delete-1" class="headerlink" title="delete()"></a>delete()</h5><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span><span class="string">`方法删除某个键，返回`</span><span class="literal">true</span><span class="string">`。如果删除失败，返回`</span><span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">'nah'</span>);</span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="literal">undefined</span>)</span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)       <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="clear-1"><a href="#clear-1" class="headerlink" title="clear()"></a>clear()</h5><p><code>clear</code>方法清除所有成员，没有返回值</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">'foo'</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">'bar'</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">map.<span class="title function_">clear</span>()</span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 0</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><p><code>Map</code>结构原生提供三个遍历器生成函数和一个遍历方法：</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回所有成员的遍历器</li>
<li>forEach()：遍历 Map 的所有成员</li>
</ul>
<p>遍历顺序就是插入顺序</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">'F'</span>, <span class="string">'no'</span>],</span><br><span class="line">  [<span class="string">'T'</span>,  <span class="string">'yes'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>()) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// "F"</span></span><br><span class="line"><span class="comment">// "T"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>()) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// "no"</span></span><br><span class="line"><span class="comment">// "yes"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.<span class="title function_">entries</span>()) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Key: %s, Value: %s"</span>, key, value);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h3 id="三、WeakSet-和-WeakMap"><a href="#三、WeakSet-和-WeakMap" class="headerlink" title="三、WeakSet 和 WeakMap"></a>三、WeakSet 和 WeakMap</h3><h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p>创建<code>WeakSet</code>实例</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br></pre></td></tr></tbody></table></figure>

<p><code>WeakSet</code>可以接受一个具有 <code>Iterable</code>接口的对象作为参数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(a);</span><br><span class="line"><span class="comment">// WeakSet {[1, 2], [3, 4]}</span></span><br></pre></td></tr></tbody></table></figure>

<p>在<code>API</code>中<code>WeakSet</code>与<code>Set</code>有两个区别：</p>
<ul>
<li>没有遍历操作的<code>API</code></li>
<li>没有<code>size</code>属性</li>
</ul>
<p><code>WeakSet</code>只能成员只能是引用类型，而不能是其他类型的值</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ws=<span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员不是引用类型</span></span><br><span class="line"><span class="keyword">let</span> weakSet=<span class="keyword">new</span> <span class="title class_">WeakSet</span>([<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakSet) <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员为引用类型</span></span><br><span class="line"><span class="keyword">let</span> obj1={<span class="attr">name</span>:<span class="number">1</span>}</span><br><span class="line"><span class="keyword">let</span> obj2={<span class="attr">name</span>:<span class="number">1</span>}</span><br><span class="line"><span class="keyword">let</span> ws=<span class="keyword">new</span> <span class="title class_">WeakSet</span>([obj1,obj2]); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ws) <span class="comment">//WeakSet {{…}, {…}}</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>WeakSet</code>里面的引用只要在外部消失，它在 <code>WeakSet</code>里面的引用就会自动消失</p>
<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合</p>
<p>在<code>API</code>中<code>WeakMap</code>与<code>Map</code>有两个区别：</p>
<ul>
<li>没有遍历操作的<code>API</code></li>
<li>没有<code>clear</code>清空方法</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// WeakMap 可以使用 set 方法添加成员</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = {<span class="attr">foo</span>: <span class="number">1</span>};</span><br><span class="line">wm1.<span class="title function_">set</span>(key, <span class="number">2</span>);</span><br><span class="line">wm1.<span class="title function_">get</span>(key) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMap 也可以接受一个数组，</span></span><br><span class="line"><span class="comment">// 作为构造函数的参数</span></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([[k1, <span class="string">'foo'</span>], [k2, <span class="string">'bar'</span>]]);</span><br><span class="line">wm2.<span class="title function_">get</span>(k2) <span class="comment">// "bar"</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="title class_">Symbol</span>(), <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>WeakMap</code>的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用</p>
<p>举个场景例子：</p>
<p>在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构，当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">wm.<span class="title function_">set</span>(element, <span class="string">'some information'</span>);</span><br><span class="line">wm.<span class="title function_">get</span>(element) <span class="comment">// "some information"</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意：<code>WeakMap</code> 弱引用的只是键名，而不是键值。键值依然是正常引用</p>
<p>下面代码中，键值<code>obj</code>会在<code>WeakMap</code>产生新的引用，当你修改<code>obj</code>不会影响到内部</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = {};</span><br><span class="line"><span class="keyword">let</span> obj = {<span class="attr">foo</span>: <span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">wm.<span class="title function_">set</span>(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.<span class="title function_">get</span>(key)</span><br><span class="line"><span class="comment">// Object {foo: 1}</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://es6.ruanyifeng.com/#docs/set-map">https://es6.ruanyifeng.com/#docs/set-map</a></li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>es6新增数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript是单线程吗？</title>
    <url>/posts/25490.html</url>
    <content><![CDATA[<html><head></head><body><p><strong>因为说JavaScript是单线程语言， 我被嘲笑了</strong></p>
<p>那JavaScript到底是不是单线程，我们来一探究竟。</p>
<h1 id="js到底是不是单线程？"><a href="#js到底是不是单线程？" class="headerlink" title="js到底是不是单线程？"></a>js到底是不是单线程？</h1><p>虽然“ Javascript 是单线程语言”是众所周知的事实，但对于这一点总是存在一些疑问。如果 Javascript 是单线程的，它如何支持异步调用？为什么基于 javascript 运行时的 Node.js 是非阻塞的？这是我想到的一些有趣的问题。我决定在这里捕捉我的思路，将理解 Javascript 基本原理所涉及的各个点连接起来。</p>
<span id="more"></span>

<p>Q:  单线程是什么意思？</p>
<p>A:  只有一个线程(进程)可用于执行指令</p>
<p>Q: Javascript 是单线程的吗？</p>
<p>A: 是的，<strong>Javascript“运行时”是单线程的</strong>。它执行 javascript 程序。它维护一个单独的堆栈，在这个堆栈中，指令被推送以控制执行的顺序，然后弹出以执行。以及存储对象引用和收集垃圾的堆空间。</p>
<p>所以说， JavaScript是单线程的，同一时刻只能执行特定的任务， 这句话是错误的， 严格来说的话， 应该这样说， JavaScript在运行的时候， 也就是runtime是单线程的， 单线程是用来形容运行环境的， 不是用来形容这门语言的</p>
</body></html>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的数据类型</title>
    <url>/posts/46984.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="js中的数据类型"><a href="#js中的数据类型" class="headerlink" title="js中的数据类型"></a>js中的数据类型</h1><h2 id="面试官：说说JavaScript中的数据类型？存储上的差别？"><a href="#面试官：说说JavaScript中的数据类型？存储上的差别？" class="headerlink" title="面试官：说说JavaScript中的数据类型？存储上的差别？"></a>面试官：说说JavaScript中的数据类型？存储上的差别？</h2><img src="/posts/46984/46984/image-20221127084309003.png" class="" title="image-20221127084309003">

<span id="more"></span>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在<code>JavaScript</code>中，我们可以分成两种类型：</p>
<ul>
<li>基本类型</li>
<li>复杂类型</li>
</ul>
<p>两种类型的区别是：存储位置不同</p>
<h3 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="一、基本类型"></a>一、基本类型</h3><p>基本类型主要为以下6种：</p>
<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Undefined</li>
<li>null</li>
<li>symbol</li>
</ul>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>数值最常见的整数类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x开头）</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intNum = <span class="number">55</span> <span class="comment">// 10进制的55</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">070</span> <span class="comment">// 8进制的56</span></span><br><span class="line"><span class="keyword">let</span> hexNum1 = <span class="number">0xA</span> <span class="comment">//16进制的10</span></span><br></pre></td></tr></tbody></table></figure>

<p>浮点类型则在数值汇总必须包含小数点，还可通过科学计数法表示</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum3 = <span class="number">.1</span>; <span class="comment">// 有效，但不推荐</span></span><br><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于 31250000</span></span><br></pre></td></tr></tbody></table></figure>

<p>在数值类型中，存在一个特殊数值<code>NaN</code>，意为“不是数值”，用于表示本来要返回数值的操作失败了（而不是抛出错误）</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>/<span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span>/+<span class="number">0</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h4><p><code>Undefined</code> 类型只有一个值，就是特殊值 <code>undefined</code>。当使用 <code>var</code>或 <code>let</code>声明了变量但没有初始化时，就相当于给变量赋予了 <code>undefined</code>值</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<p>包含<code>undefined</code> 值的变量跟未定义变量是有区别的</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// "undefined"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 没有声明过这个变量，报错</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>字符串可以使用双引号（”）、单引号（’）或反引号（`）标示</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">"John"</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">'Jacob'</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">`Jingleheimerschmidt`</span></span><br></pre></td></tr></tbody></table></figure>

<p>字符串是不可变的，意思是一旦创建，它们的值就不能变了</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">"Java"</span>;</span><br><span class="line">lang = lang + <span class="string">"Script"</span>;  <span class="comment">// 先销毁再创建</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Null`类型同样只有一个值，即特殊值 `null</span><br></pre></td></tr></tbody></table></figure>

<p>逻辑上讲， null 值表示一个空对象指针，这也是给<code>typeof</code>传一个 <code>null</code> 会返回 <code>"object"</code> 的原因</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> car); <span class="comment">// "object"</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>undefined</code> 值是由 <code>null</code>值派生而来</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<p>只要变量要保存对象，而当时又没有那个对象可保存，就可用 <code>null</code>来填充该变量</p>
<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Boolean`（布尔值）类型有两个字面值： `true` 和`false</span><br></pre></td></tr></tbody></table></figure>

<p>通过<code>Boolean</code>可以将其他类型的数据转化成布尔值</p>
<p>规则如下：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">数据类型      				转换为 <span class="literal">true</span> 的值      				转换为 <span class="literal">false</span> 的值</span><br><span class="line"> <span class="title class_">String</span>        				 非空字符串          					<span class="string">""</span> </span><br><span class="line"> <span class="title class_">Number</span> 				非零数值（包括无穷值）						<span class="number">0</span> 、 <span class="title class_">NaN</span> </span><br><span class="line"> <span class="title class_">Object</span> 					 任意对象 							   <span class="literal">null</span></span><br><span class="line"><span class="title class_">Undefined</span> 					N/A （不存在） 						<span class="literal">undefined</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>Symbol （符号）是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> otherGenericSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(genericSymbol == otherGenericSymbol); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="title class_">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="title class_">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooSymbol == otherFooSymbol); <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="二、引用类型"><a href="#二、引用类型" class="headerlink" title="二、引用类型"></a>二、引用类型</h3><p>复杂类型统称为<code>Object</code>，我们这里主要讲述下面三种：</p>
<ul>
<li>Object</li>
<li>Array</li>
<li>Function</li>
</ul>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>创建<code>object</code>常用方式为对象字面量表示法，属性名可以是字符串或数值</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = {</span><br><span class="line">    <span class="attr">name</span>: <span class="string">"Nicholas"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="literal">true</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p><code>JavaScript</code>数组是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。并且，数组也是动态大小的，会随着数据添加而自动增长</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="number">2</span>, {<span class="attr">age</span>: <span class="number">20</span> }]</span><br><span class="line">colors.<span class="title function_">push</span>(<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p>函数实际上是对象，每个函数都是 <code>Function</code>类型的实例，而 <code>Function</code>也有属性和方法，跟其他引用类型一样</p>
<p>函数存在三种常见的表达方式：</p>
<ul>
<li>函数声明</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span> (num1, num2) {</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>函数表达式</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) {</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>箭头函数</li>
</ul>
<p>函数声明和函数表达式两种方式</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; {</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="其他引用类型"><a href="#其他引用类型" class="headerlink" title="其他引用类型"></a>其他引用类型</h4><p>除了上述说的三种之外，还包括<code>Date</code>、<code>RegExp</code>、<code>Map</code>、<code>Set</code>等……</p>
<h3 id="三、存储区别"><a href="#三、存储区别" class="headerlink" title="三、存储区别"></a>三、存储区别</h3><p>基本数据类型和引用数据类型存储在内存中的位置不同：</p>
<ul>
<li>基本数据类型存储在栈中</li>
<li>引用类型的对象存储于堆中</li>
</ul>
<p>当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值</p>
<p>下面来举个例子</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = a; <span class="comment">// 赋值操作</span></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10值</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>a</code>的值为一个基本类型，是存储在栈中，将<code>a</code>的值赋给<code>b</code>，虽然两个变量的值相等，但是两个变量保存了两个不同的内存地址</p>
<p>下图演示了基本类型赋值的过程：</p>
<img src="/posts/46984/46984/906ffb90-6463-11eb-85f6-6fac77c0c9b3.png" class="" title="img">

<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = {}</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">"Xxx"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">name</span>); <span class="comment">// xxx</span></span><br></pre></td></tr></tbody></table></figure>

<p>引用类型数据存放在堆中，每个堆内存对象都有对应的引用地址指向它，引用地址存放在栈中。</p>
<p><code>obj1</code>是一个引用类型，在赋值操作过程汇总，实际是将堆内存对象在栈内存的引用地址复制了一份给了<code>obj2</code>，实际上他们共同指向了同一个堆内存对象，所以更改<code>obj2</code>会对<code>obj1</code>产生影响</p>
<p>下图演示这个引用类型赋值过程</p>
<img src="/posts/46984/46984/image-20221127084348348.png" class="" title="image-20221127084348348">

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>声明变量时不同的内存地址分配：<ul>
<li>简单类型的值存放在栈中，在栈中存放的是对应的值</li>
<li>引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址</li>
</ul>
</li>
<li>不同的类型数据导致赋值变量时的不同：<ul>
<li>简单类型赋值，是生成相同的值，两个对象对应不同的地址</li>
<li>复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象</li>
</ul>
</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>js中的数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>js字符串常用方法</title>
    <url>/posts/12202.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="js字符串常用方法"><a href="#js字符串常用方法" class="headerlink" title="js字符串常用方法"></a>js字符串常用方法</h1><h1 id="面试官：JavaScript字符串的常用方法有哪些？"><a href="#面试官：JavaScript字符串的常用方法有哪些？" class="headerlink" title="面试官：JavaScript字符串的常用方法有哪些？"></a>面试官：JavaScript字符串的常用方法有哪些？</h1><img src="/posts/12202/12202/ceb6ebc0-65c1-11eb-ab90-d9ae814b240d.png" class="" title="img">

<h2 id="一、操作方法"><a href="#一、操作方法" class="headerlink" title="一、操作方法"></a>一、操作方法</h2><p>我们也可将字符串常用的操作方法归纳为增、删、改、查，需要知道字符串的特点是一旦创建了，就不可变</p>
<span id="more"></span>

<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>这里增的意思并不是说直接增添内容，而是创建字符串的一个副本，再进行操作</p>
<p>除了常用<code>+</code>以及<code>${}</code>进行字符串拼接之外，还可通过<code>concat</code></p>
<h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>用于将一个或多个字符串拼接成一个新字符串</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello "</span>;</span><br><span class="line"><span class="keyword">let</span> result = stringValue.<span class="title function_">concat</span>(<span class="string">"world"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// "hello world"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// "hello"</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>这里的删的意思并不是说删除原字符串的内容，而是创建字符串的一个副本，再进行操作</p>
<p>常见的有：</p>
<ul>
<li>slice()</li>
<li>substr()</li>
<li>substring()</li>
</ul>
<p>这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>)); <span class="comment">// "lo world"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>)); <span class="comment">// "lo world"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>)); <span class="comment">// "lo world"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// "lo w"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// "lo w"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// "lo worl"</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>这里改的意思也不是改变原字符串，而是创建字符串的一个副本，再进行操作</p>
<p>常见的有：</p>
<ul>
<li>trim()、trimLeft()、trimRight()</li>
<li>repeat()</li>
<li>padStart()、padEnd()</li>
<li>toLowerCase()、 toUpperCase()</li>
</ul>
<h4 id="trim-、trimLeft-、trimRight"><a href="#trim-、trimLeft-、trimRight" class="headerlink" title="trim()、trimLeft()、trimRight()"></a>trim()、trimLeft()、trimRight()</h4><p>删除前、后或前后所有空格符，再返回新的字符串</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">" hello world "</span>;</span><br><span class="line"><span class="keyword">let</span> trimmedStringValue = stringValue.<span class="title function_">trim</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// " hello world "</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(trimmedStringValue); <span class="comment">// "hello world"</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p>接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"na "</span>;</span><br><span class="line"><span class="keyword">let</span> copyResult = stringValue.<span class="title function_">repeat</span>(<span class="number">2</span>) <span class="comment">// na na </span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="padEnd"><a href="#padEnd" class="headerlink" title="padEnd()"></a>padEnd()</h4><p>复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"foo"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">6</span>)); <span class="comment">// " foo"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">9</span>, <span class="string">"."</span>)); <span class="comment">// "......foo"</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="toLowerCase-、-toUpperCase"><a href="#toLowerCase-、-toUpperCase" class="headerlink" title="toLowerCase()、 toUpperCase()"></a>toLowerCase()、 toUpperCase()</h3><p>大小写转化</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">toUpperCase</span>()); <span class="comment">// "HELLO WORLD"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">toLowerCase</span>()); <span class="comment">// "hello world"</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>除了通过索引的方式获取字符串的值，还可通过：</p>
<ul>
<li>chatAt()</li>
<li>indexOf()</li>
<li>startWith()</li>
<li>includes()</li>
</ul>
<h4 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h4><p>返回给定索引位置的字符，由传给方法的整数参数指定</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"abcde"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">2</span>)); <span class="comment">// "c"</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h4><p>从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">"o"</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="startWith-、includes"><a href="#startWith-、includes" class="headerlink" title="startWith()、includes()"></a>startWith()、includes()</h4><p>从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"foobarbaz"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">"foo"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">"bar"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">"bar"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">"qux"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="二、转换方法"><a href="#二、转换方法" class="headerlink" title="二、转换方法"></a>二、转换方法</h2><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>把字符串按照指定的分割符，拆分成数组中的每一项</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"12+23+34"</span></span><br><span class="line"><span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">"+"</span>) <span class="comment">// [12,23,34]</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="三、模板匹配方法"><a href="#三、模板匹配方法" class="headerlink" title="三、模板匹配方法"></a>三、模板匹配方法</h2><p>针对正则表达式，字符串设计了几个方法：</p>
<ul>
<li>match()</li>
<li>search()</li>
<li>replace()</li>
</ul>
<h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><p>接收一个参数，可以是一个正则表达式字符串，也可以是一个<code>RegExp</code>对象，返回数组</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> matches = text.<span class="title function_">match</span>(pattern);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// "cat"</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p>接收一个参数，可以是一个正则表达式字符串，也可以是一个<code>RegExp</code>对象，找到则返回匹配索引，否则返回 -1</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">let</span> pos = text.<span class="title function_">search</span>(<span class="regexp">/at/</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pos); <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可用函数）</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">let</span> result = text.<span class="title function_">replace</span>(<span class="string">"at"</span>, <span class="string">"ond"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// "cond, bat, sat, fat"</span></span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>js字符串常用方法</tag>
      </tags>
  </entry>
  <entry>
    <title>js类型转换机制</title>
    <url>/posts/17077.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="js类型转换机制"><a href="#js类型转换机制" class="headerlink" title="js类型转换机制"></a>js类型转换机制</h1><h1 id="面试官：谈谈-JavaScript-中的类型转换机制"><a href="#面试官：谈谈-JavaScript-中的类型转换机制" class="headerlink" title="面试官：谈谈 JavaScript 中的类型转换机制"></a>面试官：谈谈 JavaScript 中的类型转换机制</h1><img src="/posts/17077/17077/2abd00a0-6692-11eb-85f6-6fac77c0c9b3.png" class="" title="img">

<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>前面我们讲到，<code>JS</code>中有六种简单数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>string</code>、<code>number</code>、<code>symbol</code>，以及引用类型：<code>object</code></p>
<p>但是我们在声明的时候只有一种数据类型，只有到运行期间才会确定当前类型</p>
<span id="more"></span>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = y ? <span class="number">1</span> : a;</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码中，<code>x</code>的值在编译阶段是无法获取的，只有等到程序运行时才能知道</p>
<p>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的，如果运算子的类型与预期不符合，就会触发类型转换机制</p>
<p>常见的类型转换有：</p>
<ul>
<li>强制转换（显示转换）</li>
<li>自动转换（隐式转换）</li>
</ul>
<h2 id="二、显示转换"><a href="#二、显示转换" class="headerlink" title="二、显示转换"></a>二、显示转换</h2><p>显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有：</p>
<ul>
<li>Number()</li>
<li>parseInt()</li>
<li>String()</li>
<li>Boolean()</li>
</ul>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><p>将任意类型的值转化为数值</p>
<p>先给出类型转换规则：</p>
<img src="/posts/17077/17077/915b7300-6692-11eb-ab90-d9ae814b240d.png" class="" title="img">

<p>实践一下：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="number">324</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">'324'</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果不可以被解析为数值，返回 NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">'324abc'</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空字符串转为0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">''</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值：true 转成 1，false 转成 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined：转成 NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null：转成0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象：通常转换成NaN(除了只包含单个数值的数组)</span></span><br><span class="line"><span class="title class_">Number</span>({<span class="attr">a</span>: <span class="number">1</span>}) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>([<span class="number">5</span>]) <span class="comment">// 5</span></span><br></pre></td></tr></tbody></table></figure>

<p>从上面可以看到，<code>Number</code>转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code></p>
<h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><p><code>parseInt</code>相比<code>Number</code>，就没那么严格了，<code>parseInt</code>函数逐个解析字符，遇到不能转换的字符就停下来</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'32a3'</span>) <span class="comment">//32</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><p>可以将任意类型的值转化成字符串</p>
<p>给出转换规则图：</p>
<img src="/posts/17077/17077/48dd8eb0-6692-11eb-85f6-6fac77c0c9b3.png" class="" title="img">

<p>实践一下：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 数值：转为相应的字符串</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">1</span>) <span class="comment">// "1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串：转换后还是原来的值</span></span><br><span class="line"><span class="title class_">String</span>(<span class="string">"a"</span>) <span class="comment">// "a"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔值：true转为字符串"true"，false转为字符串"false"</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>) <span class="comment">// "true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//undefined：转为字符串"undefined"</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">undefined</span>) <span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//null：转为字符串"null"</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">null</span>) <span class="comment">// "null"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="title class_">String</span>({<span class="attr">a</span>: <span class="number">1</span>}) <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="title class_">String</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// "1,2,3"</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h3><p>可以将任意类型的值转为布尔值，转换规则如下：</p>
<img src="/posts/17077/17077/53bdad10-6692-11eb-ab90-d9ae814b240d.png" class="" title="img">

<p>实践一下：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="title class_">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">''</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>({}) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>)) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="三、隐式转换"><a href="#三、隐式转换" class="headerlink" title="三、隐式转换"></a>三、隐式转换</h2><p>在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？</p>
<p>我们这里可以归纳为两种情况发生隐式转换的场景：</p>
<ul>
<li>比较运算（<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>）、<code>if</code>、<code>while</code>需要布尔值地方</li>
<li>算术运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>）</li>
</ul>
<p>除了上面的场景，还要求运算符两边的操作数不是同一类型</p>
<h3 id="自动转换为布尔值"><a href="#自动转换为布尔值" class="headerlink" title="自动转换为布尔值"></a>自动转换为布尔值</h3><p>在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用<code>Boolean</code>函数</p>
<p>可以得出个小结：</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>+0</li>
<li>-0</li>
<li>NaN</li>
<li>“”</li>
</ul>
<p>除了上面几种会被转化成<code>false</code>，其他都换被转化成<code>true</code></p>
<h3 id="自动转换成字符串"><a href="#自动转换成字符串" class="headerlink" title="自动转换成字符串"></a>自动转换成字符串</h3><p>遇到预期为字符串的地方，就会将非字符串的值自动转为字符串</p>
<p>具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串</p>
<p>常发生在<code>+</code>运算中，一旦存在字符串，则会进行字符串拼接操作</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">'5'</span> + <span class="number">1</span> <span class="comment">// '51'</span></span><br><span class="line"><span class="string">'5'</span> + <span class="literal">true</span> <span class="comment">// "5true"</span></span><br><span class="line"><span class="string">'5'</span> + <span class="literal">false</span> <span class="comment">// "5false"</span></span><br><span class="line"><span class="string">'5'</span> + {} <span class="comment">// "5[object Object]"</span></span><br><span class="line"><span class="string">'5'</span> + [] <span class="comment">// "5"</span></span><br><span class="line"><span class="string">'5'</span> + <span class="keyword">function</span> (<span class="params"></span>){} <span class="comment">// "5function (){}"</span></span><br><span class="line"><span class="string">'5'</span> + <span class="literal">undefined</span> <span class="comment">// "5undefined"</span></span><br><span class="line"><span class="string">'5'</span> + <span class="literal">null</span> <span class="comment">// "5null"</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="自动转换成数值"><a href="#自动转换成数值" class="headerlink" title="自动转换成数值"></a>自动转换成数值</h3><p>除了<code>+</code>有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">'5'</span> - <span class="string">'2'</span> <span class="comment">// 3</span></span><br><span class="line"><span class="string">'5'</span> * <span class="string">'2'</span> <span class="comment">// 10</span></span><br><span class="line"><span class="literal">true</span> - <span class="number">1</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> - <span class="number">1</span> <span class="comment">// -1</span></span><br><span class="line"><span class="string">'1'</span> - <span class="number">1</span>   <span class="comment">// 0</span></span><br><span class="line"><span class="string">'5'</span> * []    <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> / <span class="string">'5'</span> <span class="comment">// 0</span></span><br><span class="line"><span class="string">'abc'</span> - <span class="number">1</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> + <span class="number">1</span> <span class="comment">// 1</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="number">1</span> <span class="comment">// NaN</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="literal">null</span><span class="string">`转为数值时，值为`</span><span class="number">0</span><span class="string">` 。`</span><span class="literal">undefined</span><span class="string">`转为数值时，值为`</span><span class="title class_">NaN</span></span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>js类型转换机制</tag>
      </tags>
  </entry>
  <entry>
    <title>treeshaking的特性</title>
    <url>/posts/50738.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="treeshaking的特性"><a href="#treeshaking的特性" class="headerlink" title="treeshaking的特性"></a>treeshaking的特性</h1><h2 id="面试官：说说Vue-3-0中Treeshaking特性？举例说明一下？"><a href="#面试官：说说Vue-3-0中Treeshaking特性？举例说明一下？" class="headerlink" title="面试官：说说Vue 3.0中Treeshaking特性？举例说明一下？"></a>面试官：说说Vue 3.0中Treeshaking特性？举例说明一下？</h2><img src="/posts/50738/50738/image-20221117083332200.png" class="" title="image-20221117083332200">

<h3 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h3><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Tree</span> shaking<span class="string">` 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 `</span><span class="title class_">Dead</span> code elimination</span><br></pre></td></tr></tbody></table></figure>

<p>简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码</p>
<span id="more"></span>

<p>如果把代码打包比作制作蛋糕，传统的方式是把鸡蛋（带壳）全部丢进去搅拌，然后放入烤箱，最后把（没有用的）蛋壳全部挑选并剔除出去</p>
<p>而<code>treeshaking</code>则是一开始就把有用的蛋白蛋黄（import）放入搅拌，最后直接作出蛋糕</p>
<p>也就是说 ，<code>tree shaking</code> 其实是找出使用的代码</p>
<p>在<code>Vue2</code>中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是<code>Vue</code>实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> {})</span><br></pre></td></tr></tbody></table></figure>

<p>而<code>Vue3</code>源码引入<code>tree shaking</code>特性，将全局 API 进行分块。如果您不使用其某些功能，它们将不会包含在您的基础包中</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { nextTick, observable } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> {})</span><br></pre></td></tr></tbody></table></figure>

<h3 id="二、如何做"><a href="#二、如何做" class="headerlink" title="二、如何做"></a>二、如何做</h3><p><code>Tree shaking</code>是基于<code>ES6</code>模板语法（<code>import</code>与<code>exports</code>），主要是借助<code>ES6</code>模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
<p><code>Tree shaking</code>无非就是做了两件事：</p>
<ul>
<li>编译阶段利用<code>ES6 Module</code>判断哪些模块已经加载</li>
<li>判断那些模块和变量未被使用或者引用，进而删除对应代码</li>
</ul>
<p>下面就来举个例子：</p>
<p>通过脚手架<code>vue-cli</code>安装<code>Vue2</code>与<code>Vue3</code>项目</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">vue create vue-demo</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Vue2-项目"><a href="#Vue2-项目" class="headerlink" title="Vue2 项目"></a>Vue2 项目</h4><p>组件中使用<code>data</code>属性</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default {</span><br><span class="line">        data: () =&gt; ({</span><br><span class="line">            count: 1,</span><br><span class="line">        }),</span><br><span class="line">    };</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>对项目进行打包，体积如下图</p>
<img src="/posts/50738/50738/image-20221117083500912.png" class="" title="image-20221117083500912">

<p>为组件设置其他属性（<code>compted</code>、<code>watch</code>）</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">    <span class="attr">data</span>: <span class="function">() =&gt;</span> ({</span><br><span class="line">        <span class="attr">question</span>:<span class="string">""</span>, </span><br><span class="line">        <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    }),</span><br><span class="line">    <span class="attr">computed</span>: {</span><br><span class="line">        <span class="attr">double</span>: <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> * <span class="number">2</span>;</span><br><span class="line">        },</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">watch</span>: {</span><br><span class="line">        <span class="attr">question</span>: <span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) {</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">'xxxx'</span></span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>再一次打包，发现打包出来的体积并没有变化</p>
<img src="/posts/50738/50738/image-20221117083541303.png" class="" title="image-20221117083541303">

<h4 id="Vue3-项目"><a href="#Vue3-项目" class="headerlink" title="Vue3 项目"></a>Vue3 项目</h4><p>组件中简单使用</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { reactive, defineComponent } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>({</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>({</span><br><span class="line">      <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      state,</span><br><span class="line">    };</span><br><span class="line">  },</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>将项目进行打包</p>
<img src="/posts/50738/50738/image-20221117083612396.png" class="" title="image-20221117083612396">

<p>在组件中引入<code>computed</code>和<code>watch</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { reactive, defineComponent, computed, watch } <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>({</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>({</span><br><span class="line">      <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">const</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span> * <span class="number">2</span>;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> state.<span class="property">count</span>,</span><br><span class="line">      <span class="function">(<span class="params">count, preCount</span>) =&gt;</span> {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(preCount);</span><br><span class="line">      }</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      state,</span><br><span class="line">      double,</span><br><span class="line">    };</span><br><span class="line">  },</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>再次对项目进行打包，可以看到在引入<code>computer</code>和<code>watch</code>之后，项目整体体积变大了</p>
<img src="/posts/50738/50738/image-20221117083641013.png" class="" title="image-20221117083641013">

<h3 id="三、作用"><a href="#三、作用" class="headerlink" title="三、作用"></a>三、作用</h3><p>通过<code>Tree shaking</code>，<code>Vue3</code>给我们带来的好处是：</p>
<ul>
<li>减少程序体积（更小）</li>
<li>减少程序执行时间（更快）</li>
<li>便于将来对程序架构进行优化（更友好）</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://segmentfault.com/a/1190000038962700">https://segmentfault.com/a/1190000038962700</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>treeshaking特性</tag>
      </tags>
  </entry>
  <entry>
    <title>v-if和v-show</title>
    <url>/posts/37259.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="面试官：v-show和v-if有什么区别？使用场景分别是什么？"><a href="#面试官：v-show和v-if有什么区别？使用场景分别是什么？" class="headerlink" title="面试官：v-show和v-if有什么区别？使用场景分别是什么？"></a>面试官：v-show和v-if有什么区别？使用场景分别是什么？</h1><img src="/posts/37259/37259/image-20221012082812636.png" class="" title="image-20221012082812636">

<h2 id="一、v-show与v-if的共同点"><a href="#一、v-show与v-if的共同点" class="headerlink" title="一、v-show与v-if的共同点"></a>一、v-show与v-if的共同点</h2><p>我们都知道在 <code>vue</code> 中 <code>v-show</code> 与 <code>v-if</code> 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示</p>
<p>在用法上也是相同的</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;Model v-show="isShow" /&gt;</span><br><span class="line">&lt;Model v-if="isShow" /&gt;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>当表达式为<code>true</code>的时候，都会占据页面的位置</li>
<li>当表达式都为<code>false</code>时，都不会占据页面位置</li>
</ul>
<h2 id="二、v-show与v-if的区别"><a href="#二、v-show与v-if的区别" class="headerlink" title="二、v-show与v-if的区别"></a>二、v-show与v-if的区别</h2><ul>
<li>控制手段不同</li>
<li>编译过程不同</li>
<li>编译条件不同</li>
</ul>
<p>控制手段：<code>v-show</code>隐藏则是为该元素添加<code>css--display:none</code>，<code>dom</code>元素依旧还在。<code>v-if</code>显示隐藏是将<code>dom</code>元素整个添加或删除</p>
<p>编译过程：<code>v-if</code>切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；<code>v-show</code>只是简单的基于css切换</p>
<p>编译条件：<code>v-if</code>是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染</p>
<ul>
<li><code>v-show</code> 由<code>false</code>变为<code>true</code>的时候不会触发组件的生命周期</li>
<li><code>v-if</code>由<code>false</code>变为<code>true</code>的时候，触发组件的<code>beforeCreate</code>、<code>create</code>、<code>beforeMount</code>、<code>mounted</code>钩子，由<code>true</code>变为<code>false</code>的时候触发组件的<code>beforeDestory</code>、<code>destoryed</code>方法</li>
</ul>
<p>性能消耗：<code>v-if</code>有更高的切换消耗；<code>v-show</code>有更高的初始渲染消耗；</p>
<h2 id="三、v-show与v-if原理分析"><a href="#三、v-show与v-if原理分析" class="headerlink" title="三、v-show与v-if原理分析"></a>三、v-show与v-if原理分析</h2><p>具体解析流程这里不展开讲，大致流程如下</p>
<ul>
<li>将模板<code>template</code>转为<code>ast</code>结构的<code>JS</code>对象</li>
<li>用<code>ast</code>得到的<code>JS</code>对象拼装<code>render</code>和<code>staticRenderFns</code>函数</li>
<li><code>render</code>和<code>staticRenderFns</code>函数被调用后生成虚拟<code>VNODE</code>节点，该节点包含创建<code>DOM</code>节点所需信息</li>
<li><code>vm.patch</code>函数通过虚拟<code>DOM</code>算法利用<code>VNODE</code>节点创建真实<code>DOM</code>节点</li>
</ul>
<h3 id="v-show原理"><a href="#v-show原理" class="headerlink" title="v-show原理"></a>v-show原理</h3><p>不管初始条件是什么，元素总是会被渲染</p>
<p>我们看一下在<code>vue</code>中是如何实现的</p>
<p>代码很好理解，有<code>transition</code>就执行<code>transition</code>，没有就直接设置<code>display</code>属性</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// https://github.com/vuejs/vue-next/blob/3cd30c5245da0733f9eb6f29d220f39c46518162/packages/runtime-dom/src/directives/vShow.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">vShow</span>: <span class="title class_">ObjectDirective</span>&lt;<span class="title class_">VShowElement</span>&gt; = {</span><br><span class="line">  <span class="title function_">beforeMount</span>(<span class="params">el, { value }, { transition }</span>) {</span><br><span class="line">    el.<span class="property">_vod</span> = el.<span class="property">style</span>.<span class="property">display</span> === <span class="string">'none'</span> ? <span class="string">''</span> : el.<span class="property">style</span>.<span class="property">display</span></span><br><span class="line">    <span class="keyword">if</span> (transition &amp;&amp; value) {</span><br><span class="line">      transition.<span class="title function_">beforeEnter</span>(el)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="title function_">setDisplay</span>(el, value)</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, { value }, { transition }</span>) {</span><br><span class="line">    <span class="keyword">if</span> (transition &amp;&amp; value) {</span><br><span class="line">      transition.<span class="title function_">enter</span>(el)</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">updated</span>(<span class="params">el, { value, oldValue }, { transition }</span>) {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">beforeUnmount</span>(<span class="params">el, { value }</span>) {</span><br><span class="line">    <span class="title function_">setDisplay</span>(el, value)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="v-if原理"><a href="#v-if原理" class="headerlink" title="v-if原理"></a>v-if原理</h3><p><code>v-if</code>在实现上比<code>v-show</code>要复杂的多，因为还有<code>else</code> <code>else-if</code> 等条件需要处理，这里我们也只摘抄源码中处理 <code>v-if</code> 的一小部分</p>
<p>返回一个<code>node</code>节点，<code>render</code>函数通过表达式的值来决定是否生成<code>DOM</code></p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// https://github.com/vuejs/vue-next/blob/cdc9f336fd/packages/compiler-core/src/transforms/vIf.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> transformIf = <span class="title function_">createStructuralDirectiveTransform</span>(</span><br><span class="line">  <span class="regexp">/^(if|else|else-if)$/</span>,</span><br><span class="line">  <span class="function">(<span class="params">node, dir, context</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">processIf</span>(node, dir, context, <span class="function">(<span class="params">ifNode, branch, isRoot</span>) =&gt;</span> {</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="keyword">if</span> (isRoot) {</span><br><span class="line">          ifNode.<span class="property">codegenNode</span> = <span class="title function_">createCodegenNodeForBranch</span>(</span><br><span class="line">            branch,</span><br><span class="line">            key,</span><br><span class="line">            context</span><br><span class="line">          ) <span class="keyword">as</span> <span class="title class_">IfConditionalExpression</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="comment">// attach this branch's codegen node to the v-if root.</span></span><br><span class="line">          <span class="keyword">const</span> parentCondition = <span class="title function_">getParentCondition</span>(ifNode.<span class="property">codegenNode</span>!)</span><br><span class="line">          parentCondition.<span class="property">alternate</span> = <span class="title function_">createCodegenNodeForBranch</span>(</span><br><span class="line">            branch,</span><br><span class="line">            key + ifNode.<span class="property">branches</span>.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">            context</span><br><span class="line">          )</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="四、v-show与v-if的使用场景"><a href="#四、v-show与v-if的使用场景" class="headerlink" title="四、v-show与v-if的使用场景"></a>四、v-show与v-if的使用场景</h2><p><code>v-if</code> 与 <code>v-show</code> 都能控制<code>dom</code>元素在页面的显示</p>
<p><code>v-if</code> 相比 <code>v-show</code> 开销更大的（直接操作<code>dom</code>节点增加与删除）</p>
<p>如果需要非常频繁地切换，则使用 v-show 较好</p>
<p>如果在运行时条件很少改变，则使用 v-if 较好</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.jianshu.com/p/7af8554d8f08">https://www.jianshu.com/p/7af8554d8f08</a></li>
<li><a href="https://juejin.cn/post/6897948855904501768">https://juejin.cn/post/6897948855904501768</a></li>
<li><a href="https://vue3js/docs/zh">https://vue3js/docs/zh</a></li>
<li>@js语言答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>v-if和v-show</tag>
      </tags>
  </entry>
  <entry>
    <title>vite的基本使用</title>
    <url>/posts/53565.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vite的基本使用"><a href="#vite的基本使用" class="headerlink" title="vite的基本使用"></a>vite的基本使用</h1><p>vite是下一代的前端构建工具</p>
<p>vite是一个法语单词，它的意思就是quick， 翻译过来就是快的意思；vite是一个被强烈建议的web开发工具， 通过ES  module的这种方式来导入。</p>
<p>官网文档地址： <a href="https://vitejs.dev/guide">https://vitejs.dev/guide</a></p>
<span id="more"></span>

<p>npm : </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm create vite@latest</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>yarn: </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">yarn create vite</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>pnpm:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">pnpm create vite</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>当然你在创建的时候后面可以加上项目的名字：</p>
<p>接着根据你的需要在窗口选择不同的选项 ， 这时候虽然是创建了项目， 但是它并没有安装任何的依赖， 这个时候就需要你亲自动手去做。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cd your-project</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></tbody></table></figure>

<p>vite 设计的时候主要是和vue3一起使用的， 但是它也是可以支持其他的框架的，比如说常见的react，想了解的可以去看官方文档， 这里我不多说</p>
<h2 id="vite的其他搭建方案："><a href="#vite的其他搭建方案：" class="headerlink" title="vite的其他搭建方案："></a>vite的其他搭建方案：</h2><p>这种搭建方案有点像外部的开发服务器的搭建方法，如果你不想等待新版本的释放，你可以自己去克隆一份：</p>
<p>我们安装官网的步骤来：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git clone https://github.com/vitejs/vite.git</span><br><span class="line">cd vite</span><br><span class="line">pnpm install 或者是yarn  安装依赖</span><br><span class="line">cd packages/vite</span><br><span class="line">yarn build 先进行项目打包，生成一个dist目录</span><br><span class="line">最后link一下</span><br><span class="line">yarn link </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>执行完之后， 如果出现了success</p>
<p>然后：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">yarn link vite</span><br></pre></td></tr></tbody></table></figure>

<p>当终端弹出success之后 ，</p>
<p>在package.json中把”script“中的test替换成下面的代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">"script": {</span><br><span class="line">	"dev": "vite",</span><br><span class="line">	"build": "vite build"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样就是在外部搭建了一个vite，就是把vite作为了一个外部服务器和我自己的项目进行关联， 当然如果你还有一个项目的话， 那么你就可以再进行一次关联</p>
<h3 id="vite对编译的支持："><a href="#vite对编译的支持：" class="headerlink" title="vite对编译的支持："></a>vite对编译的支持：</h3><p>vite支持importing</p>
<h3 id="vite支持css和json"><a href="#vite支持css和json" class="headerlink" title="vite支持css和json"></a>vite支持css和json</h3><p>支持css和json热更新</p>
<h3 id="vite支持Asset-url-handing"><a href="#vite支持Asset-url-handing" class="headerlink" title="vite支持Asset url handing"></a>vite支持Asset url handing</h3><p>有一句重要的话， 就是说所有的使用绝对路径的文档都会copy到dist中去进行哈希化， 就是在生产环境中打包，如果你没有引用这些资源的话， 它是不会被copy的，就像是vue-cli，图片如果小于4kb就自动转化成64位格式</p>
<h3 id="vite支持postcss"><a href="#vite支持postcss" class="headerlink" title="vite支持postcss"></a>vite支持postcss</h3><p>可以自己去配置</p>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vite</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode中八个封神的快捷键</title>
    <url>/posts/4dba0f11.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vscode中八个封神的快捷键"><a href="#vscode中八个封神的快捷键" class="headerlink" title="vscode中八个封神的快捷键"></a>vscode中八个封神的快捷键</h1><img src="/posts/4dba0f11/4dba0f11/image-20221212183442490.png" class="" title="image-20221212183442490">

<p>了解如何在 VS 代码中快速执行特定操作是增强编程体验和加快编码过程的保证方法。同时编辑更多行或在文件之间切换对于编写更快的代码来说是必不可少的。</p>
<span id="more"></span>

<h2 id="1-上下移动一行代码"><a href="#1-上下移动一行代码" class="headerlink" title="1. 上下移动一行代码"></a>1. 上下移动一行代码</h2><p>如果你想在鼠标和键盘之间不断切换的情况下上下移动一行代码，这个快捷键可以节省你的时间ー Alt + Up/Down 箭头</p>
<img src="/posts/4dba0f11/4dba0f11/demo1.gif" class="" title="图片1">



<h2 id="2-多个光标"><a href="#2-多个光标" class="headerlink" title="2. 多个光标"></a>2. 多个光标</h2><p>当你需要处理文档中大量重复内容的行时，多个光标可能会派上用场，并且需要以类似的方式编辑所有行——Windows 设备上的 Ctrl + Alt + Up/Down 箭头或者是Mac设备上的 ⌥ + commend + Up/Down 箭头。</p>
<img src="/posts/4dba0f11/4dba0f11/demo2.gif" class="" title="图片2">

<h2 id="3-在文件之间切换"><a href="#3-在文件之间切换" class="headerlink" title="3. 在文件之间切换"></a>3. 在文件之间切换</h2><p>如果您正在一个庞大的项目目录中工作，并且需要通过在 Windows 设备和 Mac something P 上以模式ー Ctrl + P 输入文件名来快速导航文件，那么这个特性可能对您非常有用。</p>
<img src="/posts/4dba0f11/4dba0f11/demo3.gif" class="" title="图片3">

<h2 id="4-格式化文件"><a href="#4-格式化文件" class="headerlink" title="4. 格式化文件"></a>4. 格式化文件</h2><p>格式化文件对于您或您的团队保持文件的清晰性和可读性非常重要。VS Code 支持许多编程语言，使用这种快捷键会很好的节省您的时间，您可以在windows上使用Ctrl + K Ctrl + F  来格式化您的文件， 或者在Mac设备上使用⌘K ⌘F</p>
<img src="/posts/4dba0f11/4dba0f11/demo4.gif" class="" title="图片4">

<h2 id="5-选择一个主题"><a href="#5-选择一个主题" class="headerlink" title="5. 选择一个主题"></a>5. 选择一个主题</h2><p>选择一个配色方案或主题可能是 VS Code 不适合你的原因，你可以设置一个不同的主题并使你的编辑器发光。新的主题可以直接下载到这个软件在 VS 代码市场，在那里你可以搜索术语主题。您可以通过在 Windows 设备使用Ctrl + K Ctrl + T 或者是在Mac设备上使用⌘K ⌘T  来设置它</p>
<img src="/posts/4dba0f11/4dba0f11/demo5.gif" class="" title="图片5">

<h2 id="6-删除代码行"><a href="#6-删除代码行" class="headerlink" title="6. 删除代码行"></a>6. 删除代码行</h2><p>为了更快地进行代码操作，您可以使用删除光标所在位置的一行代码特性ーー Windows 设备您可以使用Ctrl + Shift + K ，而在Mac设备上您可以使用 ⌘ + Shift + K</p>
<img src="/posts/4dba0f11/4dba0f11/demo6.gif" class="" title="图片6">

<h2 id="7-注释和取消注释代码行"><a href="#7-注释和取消注释代码行" class="headerlink" title="7. 注释和取消注释代码行"></a>7. 注释和取消注释代码行</h2><p>注释一行或几行代码可能是更快地管理文件和尝试新功能的一个很好的工具，总的来说，在 Windows 设备使用Ctrl + K Ctrl + C ， 在Mac设备上使用⌘K ⌘C 是一个很棒的技能。</p>
<img src="/posts/4dba0f11/4dba0f11/demo7.gif" class="" title="图片7">

<h2 id="8-上下复制一行代码"><a href="#8-上下复制一行代码" class="headerlink" title="8.上下复制一行代码"></a>8.上下复制一行代码</h2><p>例如，如果您需要向上或向下复制几行代码，因为有大量的行重复，您可以使用这个特性。在windows上您可以使用 <code>Shift + Alt + Up/Down arrow</code> ，在Mac上您可以使用  <code>⌥ + Shift + Up/Down arrow</code>来完成这样的一个操作</p>
<img src="/posts/4dba0f11/4dba0f11/demo8.gif" class="" title="图片8">

<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>我认为这些快捷方式是 VS Code 中最有用的。我希望您能从本文中获得一些有价值的东西，并从现在开始使用这些快捷方式。</p>
</body></html>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vscode中八个封神的快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2和vue3</title>
    <url>/posts/39274.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="面试官：vue2-和-vue3-的区别有哪些？"><a href="#面试官：vue2-和-vue3-的区别有哪些？" class="headerlink" title="面试官：vue2 和 vue3 的区别有哪些？"></a>面试官：vue2 和 vue3 的区别有哪些？</h1><h2 id="一、vue3-和-vue2-区别详述"><a href="#一、vue3-和-vue2-区别详述" class="headerlink" title="一、vue3 和 vue2 区别详述"></a>一、vue3 和 vue2 区别详述</h2><h3 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title="1. 生命周期"></a>1. 生命周期</h3><p>对于生命周期来说，整体上变化不大，只是大部分生命周期钩子名称上 + “on”，功能上是类似的。不过有一点需要注意，Vue3 在组合式 API（Composition API，下面展开）中使用生命周期钩子时需要先引入，而 Vue2 在选项 API（Options API）中可以直接调用生命周期钩子，如下所示。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// vue3</span><br><span class="line">&lt;script setup&gt;     </span><br><span class="line">import { onMounted } from 'vue';   // 使用前需引入生命周期钩子</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; {</span><br><span class="line">  // ...</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">// 可将不同的逻辑拆开成多个onMounted，依然按顺序执行，不会被覆盖</span><br><span class="line">onMounted(() =&gt; {</span><br><span class="line">  // ...</span><br><span class="line">});</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// vue2</span><br><span class="line">&lt;script&gt;     </span><br><span class="line">export default {           mounted() {   // 直接调用生命周期钩子            </span><br><span class="line">    // ...         </span><br><span class="line">  },           }</span><br><span class="line">&lt;/script&gt; </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>常用生命周期对比如下表所示。</p>
<p>Tips： setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地去定义。</p>
<h3 id="2-多根节点"><a href="#2-多根节点" class="headerlink" title="2. 多根节点"></a>2. 多根节点</h3><p>熟悉 Vue2 的朋友应该清楚，在模板中如果使用多个根节点时会报错，如下所示。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// vue2中在template里存在多个根节点会报错</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;header&gt;&lt;/header&gt;</span><br><span class="line">  &lt;main&gt;&lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;&lt;/footer&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 只能存在一个根节点，需要用一个&lt;div&gt;来包裹着</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;header&gt;&lt;/header&gt;</span><br><span class="line">    &lt;main&gt;&lt;/main&gt;</span><br><span class="line">    &lt;footer&gt;&lt;/footer&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>但是，Vue3 支持多个根节点，也就是 fragment。即以下多根节点的写法是被允许的。它会把多余的根节点转化为虚拟节点，所以这样一来 ，它就被允许了。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;header&gt;&lt;/header&gt;</span><br><span class="line">  &lt;main&gt;&lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;&lt;/footer&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-Composition-API"><a href="#3-Composition-API" class="headerlink" title="3. Composition API"></a>3. Composition API</h3><p>Vue2 是选项 API（Options API），一个逻辑会散乱在文件不同位置（data、props、computed、watch、生命周期钩子等），导致代码的可读性变差。当需要修改某个逻辑时，需要上下来回跳转文件位置。这一点我深有感触</p>
<p>Vue3 组合式 API（Composition API）则很好地解决了这个问题，可将同一逻辑的内容写到一起，增强了代码的可读性、内聚性，其还提供了较为完美的逻辑复用性方案。就像是组件的概念一样</p>
<p>composition api 的简单使用：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">export default {</span><br><span class="line">  	setup() {</span><br><span class="line">    	const count = ref(0)</span><br><span class="line">    	const double = computed(() =&gt; count.value * 2)</span><br><span class="line">    	function increment() {</span><br><span class="line">        	count.value++</span><br><span class="line">    	}</span><br><span class="line">    	onMounted(() =&gt; console.log('component mounted!'))</span><br><span class="line">    	return {</span><br><span class="line">        	count,</span><br><span class="line">        	double,</span><br><span class="line">        	increment</span><br><span class="line">    	}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="4-异步组件（Suspense）"><a href="#4-异步组件（Suspense）" class="headerlink" title="4. 异步组件（Suspense）"></a>4. 异步组件（Suspense）</h3><p>Vue3 提供 Suspense 组件，允许程序在等待异步组件加载完成前渲染兜底的内容，如 loading ，使用户的体验更平滑。使用它，需在模板中声明，并包括两个命名插槽：default 和 fallback。Suspense 确保加载完异步内容时显示默认插槽，并将 fallback 插槽用作加载状态。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;tempalte&gt;</span><br><span class="line">  &lt;suspense&gt;</span><br><span class="line">    &lt;template #default&gt;</span><br><span class="line">      &lt;List /&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;template #fallback&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Loading...      &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/suspense&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure>


<p>在 List 组件（有可能是异步组件，也有可能是组件内部处理逻辑或查找操作过多导致加载过慢等）未加载完成前，显示 Loading…（即 fallback 插槽内容），加载完成时显示自身（即 default 插槽内容）。</p>
<h3 id="5-Teleport"><a href="#5-Teleport" class="headerlink" title="5. Teleport"></a>5. Teleport</h3><p>Vue3 提供 Teleport 组件可将部分 DOM 移动到 Vue app 之外的位置。比如项目中常见的 Dialog 弹窗。</p>
<p>在 vue2 中，像 modals，toast 等这样的元素，如果我们嵌套在 Vue 的某个组件内部，那么处理嵌套组件的定位、z-index 和样式就会变得很困难。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;button @click="dialogVisible = true"&gt;显示弹窗&lt;/button&gt;</span><br><span class="line">&lt;teleport to="body"&gt;</span><br><span class="line">  &lt;div class="dialog" v-if="dialogVisible"&gt;</span><br><span class="line">    我是弹窗，我直接移动到了body标签下  &lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-响应式原理"><a href="#6-响应式原理" class="headerlink" title="6. 响应式原理"></a>6. 响应式原理</h3><p>Vue2 响应式原理基础是 Object.defineProperty；Vue3 响应式原理基础是 Proxy。</p>
<ul>
<li>Object.defineProperty 基本用法：直接在一个对象上定义新的属性或修改现有的属性，并返回对象。</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = {};</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'leo'</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">'name'</span>, {</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,   <span class="comment">// 可枚举（是否可通过 for...in 或 Object.keys() 进行访问）</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,   <span class="comment">// 可配置（是否可使用 delete 删除，是否可再次设置属性）</span></span><br><span class="line">  <span class="comment">// value: '',   // 任意类型的值，默认undefined</span></span><br><span class="line">  <span class="comment">// writable: true,   // 可重写</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">value</span>) {</span><br><span class="line">    name = value;</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>Tips： <code>writable</code> 和 <code>value</code> 与 <code>getter</code> 和 <code>setter</code> 不共存。</p>
<p>搬运 Vue2 核心源码，略删减。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) {</span><br><span class="line">  <span class="comment">// 一 key 一个 dep</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 key 的属性描述符，发现它是不可配置对象的话直接 return</span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.<span class="property">configurable</span> === <span class="literal">false</span>) { <span class="keyword">return</span> }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 getter 和 setter，并获取 val 值</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.<span class="property">get</span></span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.<span class="property">set</span></span><br><span class="line">  <span class="keyword">if</span>((!getter || setter) &amp;&amp; <span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) { val = obj[key] }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归处理，保证对象中所有 key 被观察</span></span><br><span class="line">  <span class="keyword">let</span> childOb = <span class="title function_">observe</span>(val)</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, {</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// get 劫持 obj[key] 的 进行依赖收集</span></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span>(<span class="params"></span>) {</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>) {</span><br><span class="line">        <span class="comment">// 依赖收集</span></span><br><span class="line">        dep.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">if</span>(childOb) {</span><br><span class="line">          <span class="comment">// 针对嵌套对象，依赖收集</span></span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="comment">// 触发数组响应式</span></span><br><span class="line">          <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) {</span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  })</span><br><span class="line">  <span class="comment">// set 派发更新 obj[key]</span></span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span>(<span class="params">newVal</span>) {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(setter) {</span><br><span class="line">      setter.<span class="title function_">call</span>(obj, newVal)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      val = newVal</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 新值设置响应式</span></span><br><span class="line">    childOb = <span class="title function_">observe</span>(val)</span><br><span class="line">    <span class="comment">// 依赖通知更新</span></span><br><span class="line">    dep.<span class="title function_">notify</span>()</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>那 Vue3 为何会抛弃它呢？那肯定是因为它存在某些局限性。</p>
<p>主要原因：无法监听对象或数组新增、删除的元素。</p>
<p>Vue2 相应解决方案：针对常用数组原型方法 push、pop、shift、unshift、splice、sort、reverse 进行了 hack 处理；提供 Vue.set 监听对象/数组新增属性。对象的新增/删除响应，还可以 new 个新对象，新增则合并新属性和旧对象；删除则将删除属性后的对象深拷贝给新对象。</p>
<ul>
<li>ProxyProxy 是 ES6 新特性，通过第 2 个参数 handler 拦截目标对象的行为。相较于 Object.defineProperty 提供语言全范围的响应能力，消除了局限性。</li>
</ul>
<p>局限性：</p>
<p>(1)、对象/数组的新增、删除</p>
<p>(2)、监测 .length 修改</p>
<p>(3)、Map、Set、WeakMap、WeakSet 的支持</p>
<p>基本用法：创建对象的代理，从而实现基本操作的拦截和自定义操作。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> handler = {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">obj, prop</span>) {</span><br><span class="line">    <span class="keyword">return</span> prop <span class="keyword">in</span> obj ? obj[prop] : <span class="string">''</span>;</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  },</span><br><span class="line">  ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>搬运 vue3 的源码 reactive.ts 文件。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params">target, isReadOnly, baseHandlers, collectionHandlers, proxyMap</span>) {</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// collectionHandlers: 处理Map、Set、WeakMap、WeakSet</span></span><br><span class="line">  <span class="comment">// baseHandlers: 处理数组、对象</span></span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">    target,</span><br><span class="line">    targetType === <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class="line">  )</span><br><span class="line">  proxyMap.<span class="title function_">set</span>(target, proxy)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-虚拟-DOM"><a href="#7-虚拟-DOM" class="headerlink" title="7. 虚拟 DOM"></a>7. 虚拟 DOM</h3><p>Vue3 相比于 Vue2，虚拟 DOM 上增加 patchFlag 字段。我们借助 Vue3 Template Explorer 来看。</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>vue3虚拟DOM讲解<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>今天天气真不错<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{name}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>渲染函数如下所示。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { createElementVNode <span class="keyword">as</span> _createElementVNode, toDisplayString <span class="keyword">as</span> _toDisplayString, openBlock <span class="keyword">as</span> _openBlock, createElementBlock <span class="keyword">as</span> _createElementBlock, pushScopeId <span class="keyword">as</span> _pushScopeId, popScopeId <span class="keyword">as</span> _popScopeId } <span class="keyword">from</span> vue</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">_withScopeId</span> = n =&gt; (<span class="title function_">_pushScopeId</span>(scope-id),n=<span class="title function_">n</span>(),<span class="title function_">_popScopeId</span>(),n)</span><br><span class="line"><span class="keyword">const</span> _hoisted_1 = { <span class="attr">id</span>: app }</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span> <span class="title function_">_withScopeId</span>(<span class="function">() =&gt;</span> <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(h1, <span class="literal">null</span>, vue3虚拟<span class="variable constant_">DOM</span>讲解, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>))</span><br><span class="line"><span class="keyword">const</span> _hoisted_3 = <span class="comment">/*#__PURE__*/</span> <span class="title function_">_withScopeId</span>(<span class="function">() =&gt;</span> <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(p, <span class="literal">null</span>, 今天天气真不错, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) {</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(div, _hoisted_1, [</span><br><span class="line">    _hoisted_2,</span><br><span class="line">    _hoisted_3,</span><br><span class="line">    <span class="title function_">_createElementVNode</span>(div, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">name</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ]))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意第 3 个_createElementVNode 的第 4 个参数即 patchFlag 字段类型。</p>
<p>字段类型情况：1 代表节点为动态文本节点，那在 diff 过程中，只需比对文本对容，无需关注 class、style 等。除此之外，发现所有的静态节点（HOISTED 为 -1），都保存为一个变量进行静态提升，可在重新渲染时直接引用，无需重新创建。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// patchFlags 字段类型列举</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> enum <span class="title class_">PatchFlags</span> { </span><br><span class="line">  <span class="variable constant_">TEXT</span> = <span class="number">1</span>,   <span class="comment">// 动态文本内容</span></span><br><span class="line">  <span class="variable constant_">CLASS</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,   <span class="comment">// 动态类名</span></span><br><span class="line">  <span class="variable constant_">STYLE</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,   <span class="comment">// 动态样式</span></span><br><span class="line">  <span class="variable constant_">PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,   <span class="comment">// 动态属性，不包含类名和样式</span></span><br><span class="line">  <span class="variable constant_">FULL_PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,   <span class="comment">// 具有动态 key 属性，当 key 改变，需要进行完整的 diff 比较</span></span><br><span class="line">  <span class="variable constant_">HYDRATE_EVENTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,   <span class="comment">// 带有监听事件的节点</span></span><br><span class="line">  <span class="variable constant_">STABLE_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,   <span class="comment">// 不会改变子节点顺序的 fragment</span></span><br><span class="line">  <span class="variable constant_">KEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,   <span class="comment">// 带有 key 属性的 fragment 或部分子节点</span></span><br><span class="line">  <span class="variable constant_">UNKEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,   <span class="comment">// 子节点没有 key 的fragment</span></span><br><span class="line">  <span class="variable constant_">NEED_PATCH</span> = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,   <span class="comment">// 只会进行非 props 的比较</span></span><br><span class="line">  <span class="variable constant_">DYNAMIC_SLOTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,   <span class="comment">// 动态的插槽</span></span><br><span class="line">  <span class="variable constant_">HOISTED</span> = -<span class="number">1</span>,   <span class="comment">// 静态节点，diff阶段忽略其子节点</span></span><br><span class="line">  <span class="variable constant_">BAIL</span> = -<span class="number">2</span>   <span class="comment">// 代表 diff 应该结束</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-事件缓存"><a href="#8-事件缓存" class="headerlink" title="8. 事件缓存"></a>8. 事件缓存</h3><p>Vue3 的<code>cacheHandler</code>可在第一次渲染后缓存我们的事件。相比于 Vue2 无需每次渲染都传递一个新函数。加一个 click 事件。</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>vue3事件缓存讲解<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>今天天气真不错<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>{{name}}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">onCLick</span>=<span class="string">()</span> =&gt;</span> {}&gt;<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>渲染函数如下所示。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { createElementVNode <span class="keyword">as</span> _createElementVNode, toDisplayString <span class="keyword">as</span> _toDisplayString, openBlock <span class="keyword">as</span> _openBlock, createElementBlock <span class="keyword">as</span> _createElementBlock, pushScopeId <span class="keyword">as</span> _pushScopeId, popScopeId <span class="keyword">as</span> _popScopeId } <span class="keyword">from</span> vue</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">_withScopeId</span> = n =&gt; (<span class="title function_">_pushScopeId</span>(scope-id),n=<span class="title function_">n</span>(),<span class="title function_">_popScopeId</span>(),n)</span><br><span class="line"><span class="keyword">const</span> _hoisted_1 = { <span class="attr">id</span>: app }</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span> <span class="title function_">_withScopeId</span>(<span class="function">() =&gt;</span> <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(h1, <span class="literal">null</span>, vue3事件缓存讲解, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>))</span><br><span class="line"><span class="keyword">const</span> _hoisted_3 = <span class="comment">/*#__PURE__*/</span> <span class="title function_">_withScopeId</span>(<span class="function">() =&gt;</span> <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(p, <span class="literal">null</span>, 今天天气真不错, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>))</span><br><span class="line"><span class="keyword">const</span> _hoisted_4 = <span class="comment">/*#__PURE__*/</span> <span class="title function_">_withScopeId</span>(<span class="function">() =&gt;</span> <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(span, { <span class="attr">onCLick</span>: <span class="function">() =&gt;</span> {} }, [</span><br><span class="line">  <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(span)</span><br><span class="line">], -<span class="number">1</span> <span class="comment">/* HOISTED */</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) {</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(div, _hoisted_1, [</span><br><span class="line">    _hoisted_2,</span><br><span class="line">    _hoisted_3,</span><br><span class="line">    <span class="title function_">_createElementVNode</span>(div, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">name</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>),</span><br><span class="line">    _hoisted_4</span><br><span class="line">  ]))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>观察以上渲染函数，你会发现 click 事件节点为静态节点（HOISTED 为 -1），即不需要每次重新渲染。</p>
<h3 id="9-Diff-算法优化"><a href="#9-Diff-算法优化" class="headerlink" title="9. Diff 算法优化"></a>9. Diff 算法优化</h3><p>搬运 Vue3 patchChildren 源码。结合上文与源码，patchFlag 帮助 diff 时区分静态节点，以及不同类型的动态节点。一定程度地减少节点本身及其属性的比对。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchChildren</span>(<span class="params">n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) {</span><br><span class="line">  <span class="comment">// 获取新老孩子节点</span></span><br><span class="line">  <span class="keyword">const</span> c1 = n1 &amp;&amp; n1.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> c2 = n2.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> prevShapeFlag = n1 ? n1.<span class="property">shapeFlag</span> : <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> { patchFlag, shapeFlag } = n2</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 patchFlag 大于 0 </span></span><br><span class="line">  <span class="keyword">if</span>(patchFlag &gt; <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">if</span>(patchFlag &amp;&amp; <span class="title class_">PatchFlags</span>.<span class="property">KEYED_FRAGMENT</span>) {</span><br><span class="line">      <span class="comment">// 存在 key</span></span><br><span class="line">      <span class="title function_">patchKeyedChildren</span>()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    } els <span class="keyword">if</span>(patchFlag &amp;&amp; <span class="title class_">PatchFlags</span>.<span class="property">UNKEYED_FRAGMENT</span>) {</span><br><span class="line">      <span class="comment">// 不存在 key</span></span><br><span class="line">      <span class="title function_">patchUnkeyedChildren</span>()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 匹配是文本节点（静态）：移除老节点，设置文本节点</span></span><br><span class="line">  <span class="keyword">if</span>(shapeFlag &amp;&amp; <span class="title class_">ShapeFlags</span>.<span class="property">TEXT_CHILDREN</span>) {</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) {</span><br><span class="line">      <span class="title function_">unmountChildren</span>(c1 <span class="keyword">as</span> <span class="title class_">VNode</span>[], parentComponent, parentSuspense)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (c2 !== c1) {</span><br><span class="line">      <span class="title function_">hostSetElementText</span>(container, c2 <span class="keyword">as</span> string)</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 匹配新老 Vnode 是数组，则全量比较；否则移除当前所有的节点</span></span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) {</span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) {</span><br><span class="line">        <span class="title function_">patchKeyedChildren</span>(c1, c2, container, anchor, parentComponent, parentSuspense,...)</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="title function_">unmountChildren</span>(c1 <span class="keyword">as</span> <span class="title class_">VNode</span>[], parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(prevShapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">TEXT_CHILDREN</span>) {</span><br><span class="line">        <span class="title function_">hostSetElementText</span>(container, <span class="string">''</span>)</span><br><span class="line">      } </span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) {</span><br><span class="line">        <span class="title function_">mountChildren</span>(c2 <span class="keyword">as</span> <span class="title class_">VNodeArrayChildren</span>, container,anchor,parentComponent,...)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>patchUnkeyedChildren 源码如下所示。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchUnkeyedChildren</span>(<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) {</span><br><span class="line">  c1 = c1 || <span class="variable constant_">EMPTY_ARR</span></span><br><span class="line">  c2 = c2 || <span class="variable constant_">EMPTY_ARR</span></span><br><span class="line">  <span class="keyword">const</span> oldLength = c1.<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> newLength = c2.<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> commonLength = <span class="title class_">Math</span>.<span class="title function_">min</span>(oldLength, newLength)</span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; commonLength; i++) {</span><br><span class="line">    <span class="comment">// 如果新 Vnode 已经挂载，则直接 clone 一份，否则新建一个节点</span></span><br><span class="line">    <span class="keyword">const</span> nextChild = (c2[i] = optimized ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">Vnode</span>)) : <span class="title function_">normalizeVnode</span>(c2[i])</span><br><span class="line">    <span class="title function_">patch</span>()</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(oldLength &gt; newLength) {</span><br><span class="line">    <span class="comment">// 移除多余的节点</span></span><br><span class="line">    <span class="title function_">unmountedChildren</span>()</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 创建新的节点</span></span><br><span class="line">    <span class="title function_">mountChildren</span>()</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-打包优化"><a href="#10-打包优化" class="headerlink" title="10. 打包优化"></a>10. 打包优化</h3><p>Tree-shaking：模块打包 webpack、rollup 等中的概念。移除 JavaScript 上下文中未引用的代码。主要依赖于 import 和 export 语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用。</p>
<p>以 nextTick 为例子，在 Vue2 中，全局 API 暴露在 Vue 实例上，即使未使用，也无法通过 tree-shaking 进行消除。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="comment">// 一些和DOM有关的东西</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>Vue3 中针对全局和内部的 API 进行了重构，并考虑到 tree-shaking 的支持。因此，全局 API 现在只能作为 ES 模块构建的命名导出进行访问。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { nextTick } <span class="keyword">from</span> <span class="string">'vue'</span>;   <span class="comment">// 显式导入</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="comment">// 一些和DOM有关的东西</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>通过这一更改，只要模块绑定器支持 tree-shaking，则 Vue 应用程序中未使用的 api 将从最终的捆绑包中消除，获得最佳文件大小。</p>
<p>受此更改影响的全局 API 如下所示。</p>
<ul>
<li>Vue.nextTick</li>
<li>Vue.observable （用 Vue.reactive 替换）</li>
<li>Vue.version</li>
<li>Vue.compile （仅全构建）</li>
<li>Vue.set （仅兼容构建）</li>
<li>Vue.delete （仅兼容构建）</li>
</ul>
<p>内部 API 也有诸如 transition、v-model 等标签或者指令被命名导出。只有在程序真正使用才会被捆绑打包。Vue3 将所有运行功能打包也只有约 22.5kb，比 Vue2 轻量很多。</p>
<h3 id="11-TypeScript-支持"><a href="#11-TypeScript-支持" class="headerlink" title="11. TypeScript 支持"></a>11. TypeScript 支持</h3><p>Vue3 由 TypeScript 重写，相对于 Vue2 有更好的 TypeScript 支持。</p>
<ul>
<li>Vue2 Options API 中 option 是个简单对象，而 TypeScript 是一种类型系统，面向对象的语法，不是特别匹配。</li>
<li>Vue2 需要 vue-class-component 强化 vue 原生组件，也需要 vue-property-decorator 增加更多结合 Vue 特性的装饰器，写法比较繁琐。</li>
</ul>
<h3 id="12-移除API"><a href="#12-移除API" class="headerlink" title="12. 移除API"></a>12. 移除API</h3><ul>
<li><code>keyCode</code> 支持作为 <code>v-on</code> 的修饰符。</li>
<li><code>$on</code>，<code>$off</code> 和 <code>$once</code> 实例方法。</li>
<li>过滤 <code>filter</code> 。</li>
<li>内联模板 <code>attribute</code> 。</li>
<li><code>$destroy</code> 实例方法。用户不应再手动管理单个 Vue 组件的生命周期。</li>
</ul>
<h2 id="二、Options-API-与-Composition-API"><a href="#二、Options-API-与-Composition-API" class="headerlink" title="二、Options API 与 Composition API"></a>二、Options API 与 Composition API</h2><p>Vue 组件可以用两种不同的 API 风格编写：Options API 和 Composition API。</p>
<h3 id="1-Options-API"><a href="#1-Options-API" class="headerlink" title="1. Options API"></a>1. Options API</h3><p>使用 Options API，我们使用选项对象定义组件的逻辑，例如 data、methods 和 mounted。由选项定义的属性在 this 内部函数中公开，指向组件实例，如下所示。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increment"</span>&gt;</span>count is: {{ count }}<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> {  <span class="title function_">data</span>(<span class="params"></span>) {    <span class="keyword">return</span> {      <span class="attr">count</span>: <span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    }  },  <span class="attr">methods</span>: {    <span class="title function_">increment</span>(<span class="params"></span>) {      <span class="variable language_">this</span>.<span class="property">count</span>++;    }  },  <span class="title function_">mounted</span>(<span class="params"></span>) {    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The initial count is <span class="subst">${<span class="variable language_">this</span>.count}</span>.`</span>);  }}</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-Composition-API"><a href="#2-Composition-API" class="headerlink" title="2. Composition API"></a>2. Composition API</h3><p>使用 Composition API，我们使用导入的 API 函数定义组件的逻辑。在 SFC 中，Composition API 通常使用</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click="increment"&gt;Count is: {{ count }}&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import { ref, onMounted } from 'vue'; </span><br><span class="line">const count = ref(0); </span><br><span class="line">function increment() {  count.value++;} </span><br><span class="line">onMounted(() =&gt; {  console.log(`The initial count is ${count.value}.`);})</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue2和vue3的区别</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3_reactive</title>
    <url>/posts/28171.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="Vue3——reactive"><a href="#Vue3——reactive" class="headerlink" title="Vue3——reactive"></a>Vue3——reactive</h1><p>上次我们说到了ref的用法， 今天来聊聊reactive， 其实它和ref的区别不大</p>
<h2 id="1-传值"><a href="#1-传值" class="headerlink" title="1. 传值"></a>1. 传值</h2><p> reactive只能传引用类型的值， 比如Array， Object， Map，Set。 那么如果你用到了原始值的话：就会出现以下的报错：</p>
<span id="more"></span>

<img src="/posts/28171/28171/image-20221015171147671.png" class="" title="image-20221015171147671">

<p>我们来看看原因：</p>
<img src="/posts/28171/28171/image-20221015171228024.png" class="" title="image-20221015171228024">

<p>reactive在被定义的时候就已经指明了它的类型是个对象；那么你传个对象就不会报错了；</p>
<h2 id="2-修改的时候不需要-value"><a href="#2-修改的时候不需要-value" class="headerlink" title="2. 修改的时候不需要.value"></a>2. 修改的时候不需要.value</h2><img src="/posts/28171/28171/image-20221015171712071.png" class="" title="image-20221015171712071">

<p>看看页面效果：</p>
<img src="/posts/28171/28171/image-20221015171734668.png" class="" title="image-20221015171734668"></body></html>]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>reactive</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3_ref</title>
    <url>/posts/19895.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue3-ref的用法解析"><a href="#vue3-ref的用法解析" class="headerlink" title="vue3_ref的用法解析"></a>vue3_ref的用法解析</h1><h2 id="ref是干什么的？"><a href="#ref是干什么的？" class="headerlink" title="ref是干什么的？"></a>ref是干什么的？</h2><p>我们知道， vue2是这样配置响应式的：</p>
<img src="/posts/19895/19895/image-20221015081038182.png" class="" title="image-20221015081038182">

<p>而在vue3中， 我们可以使用ref来配置响应式：</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> {{someone}}</span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span> = <span class="string">'ts'</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> { ref, reactive} <span class="keyword">from</span> <span class="string">'vue'</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> someone =<span class="title function_">ref</span>( {name : <span class="string">'小马'</span>, age : <span class="number">18</span>})</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> <span class="title function_">change</span> = (<span class="params"></span>) =&gt; {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  someone.<span class="property">value</span>.<span class="property">name</span> = <span class="string">'小杨'</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(someone)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">}</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这里有几个关键的步骤，</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { ref, reactive} <span class="keyword">from</span> <span class="string">'vue'</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们在修改值的时候： 需要加上.value， 这一步容易被忽略：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">someone.value.name = '小杨'</span><br></pre></td></tr></tbody></table></figure>

<p>官方文档是这样说的：</p>
<p><code>ref()</code> takes the argument and returns it wrapped within a ref object with a <code>.value</code> property:</p>
<p>翻译一下：</p>
<p>Ref ()获取参数并将其包装在具有. value 属性的 ref 对象中返回，如果不适用.value的话， 会报错：</p>
<img src="/posts/19895/19895/image-20221015083241387.png" class="" title="image-20221015083241387">

<h2 id="isRef"><a href="#isRef" class="headerlink" title="isRef"></a>isRef</h2><p>isRef用于判断一个对象是不是Ref对象， 它的返回值是一个布尔值</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  {{someone}}</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span> = <span class="string">'ts'</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> { ref,isRef, reactive} <span class="keyword">from</span> <span class="string">'vue'</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> someone = <span class="title function_">ref</span>({<span class="attr">name</span>: <span class="string">'小桃'</span>, age : <span class="number">20</span>})</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> otherone = {name : <span class="string">'大肠'</span>, <span class="attr">age</span>: <span class="number">21</span>}</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> <span class="title function_">change</span> = (<span class="params"></span>) =&gt; {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isRef</span>(someone))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isRef</span>(otherone));</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">}</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>



<img src="/posts/19895/19895/image-20221015093729642.png" class="" title="image-20221015093729642">

<p>当我点击按钮之后，控制台返回下面的结果：</p>
<img src="/posts/19895/19895/image-20221015093819007.png" class="" title="image-20221015093819007">

<h2 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a>shallowRef</h2><p> 这个是做浅层响应式的， ref是做深层次的：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  ref:{{someone}}</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  shallowRef: {{otherone}}</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span> = <span class="string">'ts'</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> { ref,shallowRef, reactive} <span class="keyword">from</span> <span class="string">'vue'</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> someone = <span class="title function_">ref</span>({<span class="attr">name</span>: <span class="string">'小桃'</span>, age : <span class="number">20</span>})</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> otherone = <span class="title function_">shallowRef</span>({name : <span class="string">'大肠'</span>, <span class="attr">age</span>: <span class="number">21</span>})</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> <span class="title function_">change</span> = (<span class="params"></span>) =&gt; {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    otherone.<span class="property">value</span>.<span class="property">name</span> = <span class="string">'大肠2'</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(otherone)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  }</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>执行上面的代码：</p>
<img src="/posts/19895/19895/image-20221015094349461.png" class="" title="image-20221015094349461">

<p>在页面中没有发生变化， 但是在控制台中发生了变化， 这个就是shallowRef的作用， 做浅层响应， 但是如果你在change函数中这个写：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">change</span> = (<span class="params"></span>) =&gt; {</span><br><span class="line">    otherone.<span class="property">value</span> = {</span><br><span class="line">      name : <span class="string">'大肠2'</span></span><br><span class="line">    }</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(otherone)</span><br><span class="line"></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<p>这个时候，视图就会更新了， 因为你可以使用value去让它响应</p>
<p><strong>注意：</strong>ref和shallowRef是不能一块去写的， 它们会相互影响</p>
<h2 id="triggerRef"><a href="#triggerRef" class="headerlink" title="triggerRef"></a>triggerRef</h2><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  ref:{{someone}}</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  shallowRef: {{otherone}}</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span> = <span class="string">'ts'</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> { ref,shallowRef, reactive,triggerRef} <span class="keyword">from</span> <span class="string">'vue'</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> someone = <span class="title function_">ref</span>({<span class="attr">name</span>: <span class="string">'小桃'</span>, age : <span class="number">20</span>})</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> otherone = <span class="title function_">shallowRef</span>({name : <span class="string">'大肠'</span>, <span class="attr">age</span>: <span class="number">21</span>})</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> <span class="title function_">change</span> = (<span class="params"></span>) =&gt; {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    otherone.<span class="property">value</span>.<span class="property">name</span> = <span class="string">'大肠2'</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">triggerRef</span>(otherone)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  }</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>以上方法，也可以通过triggerRef来实现 ，triggerRef会强制更新依赖</p>
<h2 id="ref获取dom元素："><a href="#ref获取dom元素：" class="headerlink" title="ref获取dom元素："></a>ref获取dom元素：</h2><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span> = <span class="string">'dom'</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    我是一个dom元素</span></span><br><span class="line"><span class="language-xml">   </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span> = <span class="string">'ts'</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> { ref,shallowRef, reactive,triggerRef} <span class="keyword">from</span> <span class="string">'vue'</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> dom = ref&lt;<span class="title class_">HTMLDivElement</span>&gt;()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> <span class="title function_">change</span> = (<span class="params"></span>) =&gt; {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dom.<span class="property">value</span>?.<span class="property">innerText</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  }</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<img src="/posts/19895/19895/image-20221015100200481.png" class="" title="image-20221015100200481">

</body></html>]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>ref</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3和vue2的区别</title>
    <url>/posts/42153.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue3和vue2-的区别"><a href="#vue3和vue2-的区别" class="headerlink" title="vue3和vue2 的区别"></a>vue3和vue2 的区别</h1><h2 id="面试官：vue3有了解过吗？能说说跟vue2的区别吗？"><a href="#面试官：vue3有了解过吗？能说说跟vue2的区别吗？" class="headerlink" title="面试官：vue3有了解过吗？能说说跟vue2的区别吗？"></a>面试官：vue3有了解过吗？能说说跟vue2的区别吗？</h2><img src="/posts/42153/42153/image-20221111064656149.png" class="" title="image-20221111064656149">

<h3 id="一、Vue3介绍"><a href="#一、Vue3介绍" class="headerlink" title="一、Vue3介绍"></a>一、Vue3介绍</h3><p>关于<code>vue3</code>的重构背景，尤大是这样说的：</p>
<p>「Vue 新版本的理念成型于 2018 年末，当时 Vue 2 的代码库已经有两岁半了。比起通用软件的生命周期来这好像也没那么久，但在这段时期，前端世界已经今昔非比了</p>
<span id="more"></span>

<p>在我们更新（和重写）Vue 的主要版本时，主要考虑两点因素：首先是新的 JavaScript 语言特性在主流浏览器中的受支持水平；其次是当前代码库中随时间推移而逐渐暴露出来的一些设计和架构问题」</p>
<p>简要就是：</p>
<ul>
<li>利用新的语言特性(es6)</li>
<li>解决架构问题</li>
</ul>
<h4 id="哪些变化"><a href="#哪些变化" class="headerlink" title="哪些变化"></a>哪些变化</h4><img src="/posts/42153/42153/image-20221111064912675.png" class="" title="image-20221111064912675">

<p>从上图中，我们可以概览<code>Vue3</code>的新特性，如下：</p>
<ul>
<li>速度更快</li>
<li>体积减少</li>
<li>更易维护</li>
<li>更接近原生</li>
<li>更易使用</li>
</ul>
<h5 id="速度更快"><a href="#速度更快" class="headerlink" title="速度更快"></a>速度更快</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">vue3`相比`vue2</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>重写了虚拟<code>Dom</code>实现</li>
<li>编译模板的优化</li>
<li>更高效的组件初始化</li>
<li><code>undate</code>性能提高1.3~2倍</li>
<li><code>SSR</code>速度提高了2~3倍</li>
</ul>
<img src="/posts/42153/42153/image-20221111064939926.png" class="" title="image-20221111064939926">

<h5 id="体积更小"><a href="#体积更小" class="headerlink" title="体积更小"></a>体积更小</h5><p>通过<code>webpack</code>的<code>tree-shaking</code>功能，可以将无用模块“剪辑”，仅打包需要的</p>
<p>能够<code>tree-shaking</code>，有两大好处：</p>
<ul>
<li>对开发人员，能够对<code>vue</code>实现更多其他的功能，而不必担忧整体体积过大</li>
<li>对使用者，打包出来的包体积变小了</li>
</ul>
<p><code>vue</code>可以开发出更多其他的功能，而不必担忧<code>vue</code>打包出来的整体体积过多</p>
<img src="/posts/42153/42153/image-20221111065001628.png" class="" title="image-20221111065001628">

<h4 id="更易维护"><a href="#更易维护" class="headerlink" title="更易维护"></a>更易维护</h4><h5 id="compositon-Api"><a href="#compositon-Api" class="headerlink" title="compositon Api"></a>compositon Api</h5><ul>
<li>可与现有的<code>Options API</code>一起使用</li>
<li>灵活的逻辑组合与复用</li>
<li><code>Vue3</code>模块可以和其他框架搭配使用</li>
</ul>
<img src="/posts/42153/42153/image-20221111065022816.png" class="" title="image-20221111065022816">

<h5 id="更好的Typescript支持"><a href="#更好的Typescript支持" class="headerlink" title="更好的Typescript支持"></a>更好的Typescript支持</h5><p><code>VUE3</code>是基于<code>typescipt</code>编写的，可以享受到自动的类型定义提示</p>
<img src="/posts/42153/42153/image-20221111065048307.png" class="" title="image-20221111065048307">

<h5 id="编译器重写"><a href="#编译器重写" class="headerlink" title="编译器重写"></a>编译器重写</h5><img src="/posts/42153/42153/image-20221111065107531.png" class="" title="image-20221111065107531">

<h5 id="更接近原生"><a href="#更接近原生" class="headerlink" title="更接近原生"></a>更接近原生</h5><p>可以自定义渲染 API</p>
<img src="/posts/42153/42153/image-20221111065129306.png" class="" title="image-20221111065129306">

<h5 id="更易使用"><a href="#更易使用" class="headerlink" title="更易使用"></a>更易使用</h5><p>响应式 <code>Api</code> 暴露出来</p>
<img src="/posts/42153/42153/image-20221111065151147.png" class="" title="image-20221111065151147">

<p>轻松识别组件重新渲染原因</p>
<img src="/posts/42153/42153/image-20221111065208559.png" class="" title="image-20221111065208559">

<h3 id="二、Vue3新增特性"><a href="#二、Vue3新增特性" class="headerlink" title="二、Vue3新增特性"></a>二、Vue3新增特性</h3><p>Vue 3 中需要关注的一些新功能包括：</p>
<ul>
<li>framents</li>
<li>Teleport</li>
<li>composition Api</li>
<li>createRenderer</li>
</ul>
<h4 id="framents"><a href="#framents" class="headerlink" title="framents"></a>framents</h4><p>在 <code>Vue3.x</code> 中，组件现在支持有多个根节点</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!-- <span class="title class_">Layout</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">v-bind</span>=<span class="string">"$attrs"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h4><p><code>Teleport</code> 是一种能够将我们的模板移动到 <code>DOM</code> 中 <code>Vue app</code> 之外的其他位置的技术，就有点像哆啦A梦的“任意门”</p>
<p>在<code>vue2</code>中，像 <code>modals</code>,<code>toast</code> 等这样的元素，如果我们嵌套在 <code>Vue</code> 的某个组件内部，那么处理嵌套组件的定位、<code>z-index</code> 和样式就会变得很困难</p>
<p>通过<code>Teleport</code>，我们可以在组件的逻辑位置写模板代码，然后在 <code>Vue</code> 应用范围之外渲染它</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"showToast"</span> <span class="attr">class</span>=<span class="string">"btn"</span>&gt;</span>打开 toast<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- to 属性就是目标位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"#teleport-target"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"visible"</span> <span class="attr">class</span>=<span class="string">"toast-wrap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toast-msg"</span>&gt;</span>我是一个 Toast 文案<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="createRenderer"><a href="#createRenderer" class="headerlink" title="createRenderer"></a>createRenderer</h4><p>通过<code>createRenderer</code>，我们能够构建自定义渲染器，我们能够将 <code>vue</code> 的开发模型扩展到其他平台</p>
<p>我们可以将其生成在<code>canvas</code>画布上</p>
<img src="/posts/42153/42153/image-20221111065329107.png" class="" title="image-20221111065329107">

<p>关于<code>createRenderer</code>，我们了解下基本使用，就不展开讲述了</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { createRenderer } <span class="keyword">from</span> <span class="string">'@vue/runtime-core'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> { render, createApp } = <span class="title function_">createRenderer</span>({</span><br><span class="line">  patchProp,</span><br><span class="line">  insert,</span><br><span class="line">  remove,</span><br><span class="line">  createElement,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> { render, createApp }</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'@vue/runtime-core'</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="composition-Api"><a href="#composition-Api" class="headerlink" title="composition Api"></a>composition Api</h4><p>composition Api，也就是组合式<code>api</code>，通过这种形式，我们能够更加容易维护我们的代码，将相同功能的变量进行一个集中式的管理</p>
<img src="/posts/42153/42153/image-20221111065425141.png" class="" title="image-20221111065425141">

<p>关于<code>compositon api</code>的使用，这里以下图展开</p>
<img src="/posts/42153/42153/image-20221111065447880.png" class="" title="image-20221111065447880">

<p>简单使用:</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">const</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> * <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) {</span><br><span class="line">            count.<span class="property">value</span>++</span><br><span class="line">        }</span><br><span class="line">        <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'component mounted!'</span>))</span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">            count,</span><br><span class="line">            double,</span><br><span class="line">            increment</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="三、非兼容变更"><a href="#三、非兼容变更" class="headerlink" title="三、非兼容变更"></a>三、非兼容变更</h3><h4 id="Global-API"><a href="#Global-API" class="headerlink" title="Global API"></a>Global API</h4><ul>
<li>全局 <code>Vue API</code> 已更改为使用应用程序实例</li>
<li>全局和内部 <code>API</code> 已经被重构为可 <code>tree-shakable</code></li>
</ul>
<h4 id="模板指令"><a href="#模板指令" class="headerlink" title="模板指令"></a>模板指令</h4><ul>
<li>组件上 <code>v-model</code> 用法已更改</li>
<li><code>&lt;template v-for&gt;</code>和 非 <code>v-for</code>节点上<code>key</code>用法已更改</li>
<li>在同一元素上使用的 <code>v-if</code> 和 <code>v-for</code> 优先级已更改</li>
<li><code>v-bind="object"</code> 现在排序敏感</li>
<li><code>v-for</code> 中的 <code>ref</code> 不再注册 <code>ref</code> 数组</li>
</ul>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><ul>
<li>只能使用普通函数创建功能组件</li>
<li><code>functional</code> 属性在单文件组件 <code>(SFC)</code></li>
<li>异步组件现在需要 <code>defineAsyncComponent</code> 方法来创建</li>
</ul>
<h4 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h4><ul>
<li><p>渲染函数<code>API</code>改变</p>
</li>
<li><p><code>$scopedSlots</code> property 已删除，所有插槽都通过 <code>$slots</code> 作为函数暴露</p>
</li>
<li><p>自定义指令 API 已更改为与组件生命周期一致</p>
</li>
<li><p>一些转换</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span></span><br></pre></td></tr></tbody></table></figure>

<p>被重命名了：</p>
<ul>
<li><code>v-enter</code> -&gt; <code>v-enter-from</code></li>
<li><code>v-leave</code> -&gt; <code>v-leave-from</code></li>
</ul>
</li>
<li><p>组件 <code>watch</code> 选项和实例方法 <code>$watch</code>不再支持点分隔字符串路径，请改用计算函数作为参数</p>
</li>
<li><p>在 <code>Vue 2.x</code> 中，应用根容器的 <code>outerHTML</code> 将替换为根组件模板 (如果根组件没有模板/渲染选项，则最终编译为模板)。<code>VUE3.x</code> 现在使用应用程序容器的 <code>innerHTML</code>。</p>
</li>
</ul>
<h4 id="其他小改变"><a href="#其他小改变" class="headerlink" title="其他小改变"></a>其他小改变</h4><ul>
<li><code>destroyed</code> 生命周期选项被重命名为 <code>unmounted</code></li>
<li><code>beforeDestroy</code> 生命周期选项被重命名为 <code>beforeUnmount</code></li>
<li><code>[prop default</code>工厂函数不再有权访问 <code>this</code> 是上下文</li>
<li>自定义指令 API 已更改为与组件生命周期一致</li>
<li><code>data</code> 应始终声明为函数</li>
<li>来自 <code>mixin</code> 的 <code>data</code> 选项现在可简单地合并</li>
<li><code>attribute</code> 强制策略已更改</li>
<li>一些过渡 <code>class</code> 被重命名</li>
<li>组建 watch 选项和实例方法 <code>$watch</code>不再支持以点分隔的字符串路径。请改用计算属性函数作为参数。</li>
<li><code>&lt;template&gt;</code> 没有特殊指令的标记 (<code>v-if/else-if/else</code>、<code>v-for</code> 或 <code>v-slot</code>) 现在被视为普通元素，并将生成原生的 <code>&lt;template&gt;</code> 元素，而不是渲染其内部内容。</li>
<li>在<code>Vue 2.x</code> 中，应用根容器的 <code>outerHTML</code> 将替换为根组件模板 (如果根组件没有模板/渲染选项，则最终编译为模板)。<code>Vue 3.x</code> 现在使用应用容器的 <code>innerHTML</code>，这意味着容器本身不再被视为模板的一部分。</li>
</ul>
<h4 id="移除-API"><a href="#移除-API" class="headerlink" title="移除 API"></a>移除 API</h4><ul>
<li><code>keyCode</code> 支持作为 <code>v-on</code> 的修饰符</li>
<li><code>$on</code>，<code>$off</code>和<code>$once</code> 实例方法</li>
<li>过滤<code>filter</code></li>
<li>内联模板 <code>attribute</code></li>
<li><code>$destroy</code> 实例方法。用户不应再手动管理单个<code>Vue</code> 组件的生命周期。</li>
</ul>
<h3 id="四、重大区别"><a href="#四、重大区别" class="headerlink" title="四、重大区别"></a>四、重大区别</h3><p>如果有人问起你vue2和vue3还有什么大的区别</p>
<p>首先先来说 **响应性 <code>reactivite</code>**：</p>
<p><code>vue2</code> 的响应性主要依赖 <code>Object.defineProperty</code> 进行实现，但是 <code>Object.defineProperty</code> 只能监听 <strong>指定对象的指定属性的 <code>getter</code> 行为和 <code>setter</code> 行为</strong>，那么这样在某些情况下就会出现问题。</p>
<p>什么问题呢？</p>
<p>比如说：我们在 <code>data</code> 中声明了一个对象 <code>person</code> ，但是在后期为 <code>person</code> 增加了新的属性，那么这个新的属性就会失去响应性。想要解决这个问题其实也非常的简单，可以通过 <code>Vue.$set</code> 方法来增加 <strong>指定对象指定属性的响应性</strong>。但是这样的一种方式，在 <code>Vue</code> 的自动响应性机制中是不合理。</p>
<p>所以在 <code>Vue3</code> 中，<code>Vue</code> 引入了反射和代理的概念，所谓反射指的是 <code>Reflect</code>，所谓代理指的是 <code>Proxy</code>。我们可以利用 <code>Proxy</code> 直接代理一个普通对象，得到一个 <code>proxy 实例</code> 的代理对象。在 <code>vue3</code> 中，这个过程通过 <code>reactive</code> 这个方法进行实现。</p>
<p>但是 <code>proxy</code> 只能实现代理复杂数据类型，所以 <code>vue</code> 额外提供了 <code>ref</code> 方法，用来处理简单数据类型的响应性。<code>ref</code> 本质上并没有进行数据的监听，而是构建了一个 <code>RefImpl</code> 的类，通过 <code>set</code> 和 <code>get</code> 标记了 <code>value</code> 函数，以此来进行的实现。所以 <code>ref</code> 必须要通过 <code>.value</code> 进行触发，之所以要这么做本质是调用 <code>value 方法</code>。</p>
<p>接下来是**运行时 <code>runtime</code>**：</p>
<p>所谓的运行时，大多数时候指的是 <code>renderer 渲染器</code>，渲染器本质上是一个对象，内部主要三个方法 <code>render、hydrate、createApp</code> ，其中 <code>render</code> 主要处理渲染逻辑，<code>hydrate</code> 主要处理服务端渲染逻辑，而 <code>createApp</code> 就是创建 <code>vue</code> 实例的方法。</p>
<p>这里咱们主要来说 <code>render 渲染函数</code>，<code>vue3</code> 中为了保证宿主环境与渲染逻辑的分离，把所有与宿主环境相关的逻辑进行了抽离，通过接口的形式进行传递。这样做的目的其实是为了解绑宿主环境与渲染逻辑，以保证 <code>vue</code> 在非浏览器端的宿主环境下可以正常渲染。</p>
<p>再往下是 **编辑器 <code>compiler</code>**：</p>
<p><code>vue</code> 中的 <code>compiler</code> 其实是一个 <code>DSL（特定领域下专用语言编辑器）</code> ，其目的是为了把 <code>template 模板</code> 编译成 <code>render</code> 函数。 逻辑主要是分成了三大步： <code>parse、transform 和 generate</code>。其中 <code>parse</code> 的作用是为了把 <code>template</code> 转化为 <code>AST（抽象语法树）</code>，<code>transform</code> 可以把 <code>AST（抽象语法树）</code> 转化为 <code>JavaScript AST</code>，最后由 <code>generate</code> 把 <code>JavaScript AST</code> 通过转化为 <code>render 函数</code>。转化的过程中会涉及到一些稍微复杂的概念，比如 <strong>有限自动状态机</strong></p>
<img src="/posts/42153/42153/%E6%97%A0%E6%A0%87%E9%A2%98-2022-10-17-0948.excalidraw.png" class="" title="无标题-2022-10-17-0948.excalidraw">

<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://vue3js.cn/docs/zh/guide/migration/introduction.html#%E6%A8%A1%E6%9D%BF%E6%8C%87%E4%BB%A4">https://vue3js.cn/docs/zh/guide/migration/introduction.html#%E6%A8%A1%E6%9D%BF%E6%8C%87%E4%BB%A4</a></li>
<li><a href="https://composition-api.vuejs.org/zh/#api-%E4%BB%8B%E7%BB%8D">https://composition-api.vuejs.org/zh/#api-%E4%BB%8B%E7%BB%8D</a></li>
<li><a href="https://juejin.cn/post/7203195123433734203">https://juejin.cn/post/7203195123433734203</a></li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue3和vue2的区别</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3环境搭建</title>
    <url>/posts/25653.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue3环境搭建"><a href="#vue3环境搭建" class="headerlink" title="vue3环境搭建"></a>vue3环境搭建</h1><p>首先是需要安装node.js的， 没有安装的同学可以去官网下载： <a href="https://nodejs.org/zh-cn/">Node.js (nodejs.org)</a></p>
<span id="more"></span>

<img src="/posts/25653/25653/image-20221015071028262.png" class="" title="image-20221015071028262">

<p>一般不要尝试最新版， 会有很多问题的，下载完之后就是无脑安装；</p>
<p>怎样检查node已经安装上了呢？</p>
<p>在cmd输入这个命令， </p>
<img src="/posts/25653/25653/image-20221015071217989.png" class="" title="image-20221015071217989">

<p>我们用node最重要用的就是npm的这个包管理工具：</p>
<p>输入npm-v就可以查看这个版本：</p>
<img src="/posts/25653/25653/image-20221015071329703.png" class="" title="image-20221015071329703">

<p>当然也有其他的很多包管理工具， 这里我就不意一一介绍了</p>
<p>之后开始构建前端项目：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">npm init vite@latest</span><br></pre></td></tr></tbody></table></figure>

<img src="/posts/25653/25653/image-20221015072634753.png" class="" title="image-20221015072634753">

<p>输入之后， 选择y， 然后vite-demo是项目名字， vue是选择的框架，typescript是选择的语言：</p>
<p>之后进入vite-demo目录， </p>
<p>运行</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">npm i</span><br></pre></td></tr></tbody></table></figure>

<p>之后就会出现一个node modules目录：里面是项目的第三方依赖</p>
<p>然后：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></tbody></table></figure>

<p>之后你就会看到这个页面：</p>
<img src="/posts/25653/25653/image-20221015073311912.png" class="" title="image-20221015073311912">

<p>这个使用vite搭建的环境：</p>
<img src="/posts/25653/25653/image-20221015073412656.png" class="" title="image-20221015073412656">

<p>这个就是目录</p>
<p>当然这里还有用的脚手架搭建的方法：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">npm init vue@latest</span><br></pre></td></tr></tbody></table></figure>

<p>然后你根据需要选一下自己的项目就行；</p>
<p>vite-env.d.ts是对项目做声明文件扩充的，原因就是typescript不认识.vue文件，最后实现兼容给</p>
<p>vite是用html去入口文件的， webpack是用js作为入口文件的</p>
<p>vite是基于esbuild做编译，基于rollup做打包</p>
<p>然后就是推荐装这两个插件：</p>
<img src="/posts/25653/25653/image-20221015074236980.png" class="" title="image-20221015074236980">

<p>如果装过vetur的话， 简单禁用就行；</p>
<p>然后打开设置 —&gt; 添加用户代码片段：</p>
<p>在vue.json中加入如下配置， 这样就可以很方便的编辑.vue文件了</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">	<span class="string">"Print to console"</span>:{</span><br><span class="line">		<span class="string">"prefix"</span>: <span class="string">"vue3"</span>,</span><br><span class="line">		<span class="string">"body"</span>: [</span><br><span class="line">			<span class="string">"&lt;template&gt;"</span>,</span><br><span class="line">			<span class="string">""</span>,</span><br><span class="line">			<span class="string">"&lt;div&gt;&lt;/div&gt;"</span>,</span><br><span class="line">			<span class="string">""</span>,</span><br><span class="line">			<span class="string">"&lt;/template&gt;"</span>,</span><br><span class="line">			<span class="string">""</span>,</span><br><span class="line">			<span class="string">"&lt;script setup lang = 'ts'&gt;"</span>,</span><br><span class="line">			<span class="string">"import { ref, reactive} from 'vue'"</span>,</span><br><span class="line">			<span class="string">""</span>,</span><br><span class="line">			<span class="string">"&lt;/script&gt;"</span>,</span><br><span class="line"></span><br><span class="line">			<span class="string">"&lt;style scoped&gt;"</span>,</span><br><span class="line">			<span class="string">""</span>,</span><br><span class="line">			<span class="string">"&lt;/style&gt;"</span>,</span><br><span class="line"></span><br><span class="line">		],</span><br><span class="line">		<span class="string">"description"</span>: <span class="string">"Log output to console"</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样做的目的是在.vue文件中输入vue3点击Tab，就可以直接生成代码片段， 这算是一个小技巧</p>
</body></html>]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3设计目标与优化</title>
    <url>/posts/3339.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue3设计目标与优化"><a href="#vue3设计目标与优化" class="headerlink" title="vue3设计目标与优化"></a>vue3设计目标与优化</h1><h2 id="面试官：Vue3-0的设计目标是什么？做了哪些优化"><a href="#面试官：Vue3-0的设计目标是什么？做了哪些优化" class="headerlink" title="面试官：Vue3.0的设计目标是什么？做了哪些优化"></a>面试官：Vue3.0的设计目标是什么？做了哪些优化</h2><img src="/posts/3339/3339/image-20221112053446984.png" class="" title="image-20221112053446984">

<h3 id="一、设计目标"><a href="#一、设计目标" class="headerlink" title="一、设计目标"></a>一、设计目标</h3><p>不以解决实际业务痛点的更新都是耍流氓，下面我们来列举一下<code>Vue3</code>之前我们或许会面临的问题</p>
<ul>
<li>随着功能的增长，复杂组件的代码变得越来越难以维护</li>
<li>缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制</li>
<li>类型推断不够友好</li>
<li><code>bundle</code>的时间太久了</li>
</ul>
<p>而 <code>Vue3</code> 经过长达两三年时间的筹备，做了哪些事情？</p>
<span id="more"></span>

<p>我们从结果反推</p>
<ul>
<li>更小</li>
<li>更快</li>
<li>TypeScript支持</li>
<li>API设计一致性</li>
<li>提高自身可维护性</li>
<li>开放更多底层功能</li>
</ul>
<p>一句话概述，就是更小更快更友好了</p>
<h4 id="更小"><a href="#更小" class="headerlink" title="更小"></a>更小</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Vue3`移除一些不常用的 `API</span><br></pre></td></tr></tbody></table></figure>

<p>引入<code>tree-shaking</code>，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了</p>
<h4 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h4><p>主要体现在编译方面：</p>
<ul>
<li>diff算法优化</li>
<li>静态提升</li>
<li>事件监听缓存</li>
<li>SSR优化</li>
</ul>
<p>下篇文章我们会进一步介绍</p>
<h4 id="更友好"><a href="#更友好" class="headerlink" title="更友好"></a>更友好</h4><p><code>vue3</code>在兼顾<code>vue2</code>的<code>options API</code>的同时还推出了<code>composition API</code>，大大增加了代码的逻辑组织和代码复用能力</p>
<p>这里代码简单演示下：</p>
<p>存在一个获取鼠标位置的函数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { toRefs, reactive } <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>){</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>({<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>});</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">update</span> = e=&gt;{</span><br><span class="line">        state.<span class="property">x</span> = e.<span class="property">pageX</span>;</span><br><span class="line">        state.<span class="property">y</span> = e.<span class="property">pageY</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>{</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">'mousemove'</span>,update);</span><br><span class="line">    })</span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>{</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">'mousemove'</span>,update);</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toRefs</span>(state);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们只需要调用这个函数，即可获取<code>x</code>、<code>y</code>的坐标，完全不用关注实现过程</p>
<p>试想一下，如果很多类似的第三方库，我们只需要调用即可，不必关注实现过程，开发效率大大提高</p>
<p>同时，<code>VUE3</code>是基于<code>typescipt</code>编写的，可以享受到自动的类型定义提示</p>
<h3 id="二、优化方案"><a href="#二、优化方案" class="headerlink" title="二、优化方案"></a>二、优化方案</h3><p><code>vue3</code>从很多层面都做了优化，可以分成三个方面：</p>
<ul>
<li>源码</li>
<li>性能</li>
<li>语法 API</li>
</ul>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>源码可以从两个层面展开：</p>
<ul>
<li>源码管理</li>
<li>TypeScript</li>
</ul>
<h5 id="源码管理"><a href="#源码管理" class="headerlink" title="源码管理"></a>源码管理</h5><p><code>vue3</code>整个源码是通过 <code>monorepo</code>的方式维护的，根据功能将不同的模块拆分到<code>packages</code>目录下面不同的子目录中</p>
<img src="/posts/3339/3339/image-20221112053630601.png" class="" title="image-20221112053630601">

<p>这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性</p>
<p>另外一些 <code>package</code>（比如 <code>reactivity</code> 响应式库）是可以独立于 <code>Vue</code> 使用的，这样用户如果只想使用 <code>Vue3</code>的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 <code>Vue</code></p>
<h5 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h5><p><code>Vue3</code>是基于<code>typeScript</code>编写的，提供了更好的类型检查，能支持复杂的类型推导</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p><code>vue3</code>是从什么哪些方面对性能进行进一步优化呢？</p>
<ul>
<li>体积优化</li>
<li>编译优化</li>
<li>数据劫持优化</li>
</ul>
<p>这里讲述数据劫持：</p>
<p>在<code>vue2</code>中，数据劫持是通过<code>Object.defineProperty</code>，这个 API 有一些缺陷，并不能检测对象属性的添加和删除</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">'a'</span>,{</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>){</span><br><span class="line">    <span class="comment">// track</span></span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>){</span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>尽管<code>Vue</code>为了解决这个问题提供了 <code>set</code>和<code>delete</code>实例方法，但是对于用户来说，还是增加了一定的心智负担</p>
<p>同时在面对嵌套层级比较深的情况下，就存在性能问题</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> {</span><br><span class="line">  <span class="attr">data</span>: {</span><br><span class="line">    <span class="attr">a</span>: {</span><br><span class="line">      <span class="attr">b</span>: {</span><br><span class="line">          <span class="attr">c</span>: {</span><br><span class="line">          <span class="attr">d</span>: <span class="number">1</span></span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>相比之下，<code>vue3</code>是通过<code>proxy</code>监听整个对象，那么对于删除还是监听当然也能监听到</p>
<p>同时<code>Proxy</code> 并不能监听到内部深层次的对象变化，而 <code>Vue3</code> 的处理方式是在<code>getter</code> 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归</p>
<h4 id="语法-API"><a href="#语法-API" class="headerlink" title="语法 API"></a>语法 API</h4><p>这里当然说的就是<code>composition API</code>，其两大显著的优化：</p>
<ul>
<li>优化逻辑组织</li>
<li>优化逻辑复用</li>
</ul>
<h5 id="逻辑组织"><a href="#逻辑组织" class="headerlink" title="逻辑组织"></a>逻辑组织</h5><p>一张图，我们可以很直观地感受到 <code>Composition API</code>在逻辑组织方面的优势</p>
<img src="/posts/3339/3339/image-20221112053725814.png" class="" title="image-20221112053725814">

<p>相同功能的代码编写在一块，而不像<code>options API</code>那样，各个功能的代码混成一块</p>
<h5 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h5><p>在<code>vue2</code>中，我们是通过<code>mixin</code>实现功能混合，如果多个<code>mixin</code>混合，会存在两个非常明显的问题：命名冲突和数据来源不清晰</p>
<p>而通过<code>composition</code>这种形式，可以将一些复用的代码抽离出来作为一个函数，只要的使用的地方直接进行调用即可</p>
<p>同样是上文的获取鼠标位置的例子</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { toRefs, reactive, onUnmounted, onMounted } <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>){</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>({<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>});</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">update</span> = e=&gt;{</span><br><span class="line">        state.<span class="property">x</span> = e.<span class="property">pageX</span>;</span><br><span class="line">        state.<span class="property">y</span> = e.<span class="property">pageY</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>{</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">'mousemove'</span>,update);</span><br><span class="line">    })</span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>{</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">'mousemove'</span>,update);</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toRefs</span>(state);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>组件使用</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useMousePosition <span class="keyword">from</span> <span class="string">'./mouse'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">const</span> { x, y } = <span class="title function_">useMousePosition</span>()</span><br><span class="line">        <span class="keyword">return</span> { x, y }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，整个数据来源清晰了，即使去编写更多的<code>hook</code>函数，也不会出现命名冲突的问题</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://juejin.cn/post/6850418112878575629#heading-5">https://juejin.cn/post/6850418112878575629#heading-5</a></li>
<li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue3设计目标与优化</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3的性能提升体现在哪些方面</title>
    <url>/posts/14509.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue3的性能提升体现在哪些方面"><a href="#vue3的性能提升体现在哪些方面" class="headerlink" title="vue3的性能提升体现在哪些方面"></a>vue3的性能提升体现在哪些方面</h1><h2 id="面试官：Vue3-0性能提升主要是通过哪几方面体现的？"><a href="#面试官：Vue3-0性能提升主要是通过哪几方面体现的？" class="headerlink" title="面试官：Vue3.0性能提升主要是通过哪几方面体现的？"></a>面试官：Vue3.0性能提升主要是通过哪几方面体现的？</h2><img src="/posts/14509/14509/image-20221114070332595.png" class="" title="image-20221114070332595">

<h3 id="一、编译阶段"><a href="#一、编译阶段" class="headerlink" title="一、编译阶段"></a>一、编译阶段</h3><p>回顾<code>Vue2</code>，我们知道每个组件实例都对应一个 <code>watcher</code> 实例，它会在组件渲染的过程中把用到的数据<code>property</code>记录为依赖，当依赖发生改变，触发<code>setter</code>，则会通知<code>watcher</code>，从而使关联的组件重新渲染</p>
<span id="more"></span>

<img src="/posts/14509/14509/image-20221114070349951.png" class="" title="image-20221114070349951">

<p>试想一下，一个组件结构如下图</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>{{ message }}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 <code>diff</code> 和遍历其实都是不需要的，造成性能浪费</p>
<p>因此，<code>Vue3</code>在编译阶段，做了进一步优化。主要有如下：</p>
<ul>
<li>diff算法优化</li>
<li>静态提升</li>
<li>事件监听缓存</li>
<li>SSR优化</li>
</ul>
<h4 id="diff算法优化"><a href="#diff算法优化" class="headerlink" title="diff算法优化"></a>diff算法优化</h4><p><code>vue3</code>在<code>diff</code>算法中相比<code>vue2</code>增加了静态标记</p>
<p>关于这个静态标记，其作用是为了会发生变化的地方添加一个<code>flag</code>标记，下次发生变化的时候直接找该地方进行比较</p>
<p>下图这里，已经标记静态节点的<code>p</code>标签在<code>diff</code>过程中则不会比较，把性能进一步提高</p>
<img src="/posts/14509/14509/image-20221114070426948.png" class="" title="image-20221114070426948">

<p>关于静态类型枚举如下</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> enum <span class="title class_">PatchFlags</span> {</span><br><span class="line">  <span class="variable constant_">TEXT</span> = <span class="number">1</span>,<span class="comment">// 动态的文本节点</span></span><br><span class="line">  <span class="variable constant_">CLASS</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,  <span class="comment">// 2 动态的 class</span></span><br><span class="line">  <span class="variable constant_">STYLE</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,  <span class="comment">// 4 动态的 style</span></span><br><span class="line">  <span class="variable constant_">PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,  <span class="comment">// 8 动态属性，不包括类名和样式</span></span><br><span class="line">  <span class="variable constant_">FULL_PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,  <span class="comment">// 16 动态 key，当 key 变化时需要完整的 diff 算法做比较</span></span><br><span class="line">  <span class="variable constant_">HYDRATE_EVENTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,  <span class="comment">// 32 表示带有事件监听器的节点</span></span><br><span class="line">  <span class="variable constant_">STABLE_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,   <span class="comment">// 64 一个不会改变子节点顺序的 Fragment</span></span><br><span class="line">  <span class="variable constant_">KEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">// 128 带有 key 属性的 Fragment</span></span><br><span class="line">  <span class="variable constant_">UNKEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="comment">// 256 子节点没有 key 的 Fragment</span></span><br><span class="line">  <span class="variable constant_">NEED_PATCH</span> = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,   <span class="comment">// 512</span></span><br><span class="line">  <span class="variable constant_">DYNAMIC_SLOTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,  <span class="comment">// 动态 solt</span></span><br><span class="line">  <span class="variable constant_">HOISTED</span> = -<span class="number">1</span>,  <span class="comment">// 特殊标志是负整数表示永远不会用作 diff</span></span><br><span class="line">  <span class="variable constant_">BAIL</span> = -<span class="number">2</span> <span class="comment">// 一个特殊的标志，指代差异算法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="静态提升"><a href="#静态提升" class="headerlink" title="静态提升"></a>静态提升</h4><p><code>Vue3</code>中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用</p>
<p>这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;span&gt;你好&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>{{ message }}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>没有做静态提升之前</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) {</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">"span"</span>, <span class="literal">null</span>, <span class="string">"你好"</span>),</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">message</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>做了静态提升之后</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span><span class="title function_">_createVNode</span>(<span class="string">"span"</span>, <span class="literal">null</span>, <span class="string">"你好"</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) {</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    _hoisted_1,</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">message</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br></pre></td></tr></tbody></table></figure>

<p>静态内容<code>_hoisted_1</code>被放置在<code>render</code> 函数外，每次渲染的时候只要取 <code>_hoisted_1</code> 即可</p>
<p>同时 <code>_hoisted_1</code> 被打上了 <code>PatchFlag</code> ，静态标记值为 -1 ，特殊标志是负整数表示永远不会用于 Diff</p>
<h4 id="事件监听缓存"><a href="#事件监听缓存" class="headerlink" title="事件监听缓存"></a>事件监听缓存</h4><p>默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;button @click = 'onClick'&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>没开启事件监听器缓存</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> render = <span class="comment">/*#__PURE__*/</span><span class="title function_">_withId</span>(<span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) {</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(<span class="string">"div"</span>, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">"button"</span>, { <span class="attr">onClick</span>: _ctx.<span class="property">onClick</span> }, <span class="string">"点我"</span>, <span class="number">8</span> <span class="comment">/* PROPS */</span>, [<span class="string">"onClick"</span>])</span><br><span class="line">                                             <span class="comment">// PROPS=1&lt;&lt;3,// 8 //动态属性，但不包含类名和样式</span></span><br><span class="line">  ]))</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>开启事件侦听器缓存后</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) {</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(<span class="string">"div"</span>, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">"button"</span>, {</span><br><span class="line">      <span class="attr">onClick</span>: _cache[<span class="number">1</span>] || (_cache[<span class="number">1</span>] = <span class="function">(<span class="params">...args</span>) =&gt;</span> (_ctx.<span class="title function_">onClick</span>(...args)))</span><br><span class="line">    }, <span class="string">"点我"</span>)</span><br><span class="line">  ]))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述发现开启了缓存后，没有了静态标记。也就是说下次<code>diff</code>算法的时候直接使用</p>
<h4 id="SSR优化"><a href="#SSR优化" class="headerlink" title="SSR优化"></a>SSR优化</h4><p>当静态内容大到一定量级时候，会用<code>createStaticVNode</code>方法在客户端去生成一个static node，这些静态<code>node</code>，会被直接<code>innerHtml</code>，就不需要创建对象，然后根据对象渲染</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">div&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">span</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	...  <span class="comment">// 很多个静态属性</span></span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>{{ message }}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>编译后</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { mergeProps <span class="keyword">as</span> _mergeProps } <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">import</span> { ssrRenderAttrs <span class="keyword">as</span> _ssrRenderAttrs, ssrInterpolate <span class="keyword">as</span> _ssrInterpolate } <span class="keyword">from</span> <span class="string">"@vue/server-renderer"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ssrRender</span>(<span class="params">_ctx, _push, _parent, _attrs, $props, $setup, $data, $options</span>) {</span><br><span class="line">  <span class="keyword">const</span> _cssVars = { <span class="attr">style</span>: { <span class="attr">color</span>: _ctx.<span class="property">color</span> }}</span><br><span class="line">  <span class="title function_">_push</span>(<span class="string">`&lt;div<span class="subst">${</span></span></span><br><span class="line"><span class="subst"><span class="string">    _ssrRenderAttrs(_mergeProps(_attrs, _cssVars))</span></span></span><br><span class="line"><span class="subst"><span class="string">  }</span>&gt;&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;...&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;&lt;div&gt;&lt;span&gt;<span class="subst">${</span></span></span><br><span class="line"><span class="subst"><span class="string">    _ssrInterpolate(_ctx.message)</span></span></span><br><span class="line"><span class="subst"><span class="string">  }</span>&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;`</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="二、源码体积"><a href="#二、源码体积" class="headerlink" title="二、源码体积"></a>二、源码体积</h3><p>相比<code>Vue2</code>，<code>Vue3</code>整体体积变小了，除了移出一些不常用的API，再重要的是<code>Tree shanking</code></p>
<p>任何一个函数，如<code>ref</code>、<code>reavtived</code>、<code>computed</code>等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { computed, defineComponent, ref } <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>({</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params">props, context</span>) {</span><br><span class="line">        <span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> state = <span class="title function_">reactive</span>({</span><br><span class="line">            <span class="attr">name</span>: <span class="string">'test'</span></span><br><span class="line">        })</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> readOnlyAge = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> age.<span class="property">value</span>++) <span class="comment">// 19</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">            age,</span><br><span class="line">            state,</span><br><span class="line">            readOnlyAge</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h3 id="三、响应式系统"><a href="#三、响应式系统" class="headerlink" title="三、响应式系统"></a>三、响应式系统</h3><p><code>vue2</code>中采用 <code>defineProperty</code>来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加<code>getter</code>和<code>setter</code>，实现响应式</p>
<p><code>vue3</code>采用<code>proxy</code>重写了响应式系统，因为<code>proxy</code>可以对整个对象进行监听，所以不需要深度遍历</p>
<ul>
<li>可以监听动态属性的添加</li>
<li>可以监听到数组的索引和数组<code>length</code>属性</li>
<li>可以监听删除属性</li>
</ul>
<p>关于这两个 API 具体的不同，我们下篇文章会进行一个更加详细的介绍</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://juejin.cn/post/6903171037211557895%E3%80%81">https://juejin.cn/post/6903171037211557895、</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue3的性能提升</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中proxy代替Object.defineProperty的好处</title>
    <url>/posts/13466.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="proxy-vs-Object-defineProperty"><a href="#proxy-vs-Object-defineProperty" class="headerlink" title="proxy vs Object.defineProperty"></a>proxy vs Object.defineProperty</h1><h2 id="面试官：Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？"><a href="#面试官：Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？" class="headerlink" title="面试官：Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？"></a>面试官：Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</h2><img src="/posts/13466/13466/image-20221209160323058.png" class="" title="image-20221209160323058">

<h3 id="一、Object-defineProperty"><a href="#一、Object-defineProperty" class="headerlink" title="一、Object.defineProperty"></a>一、Object.defineProperty</h3><p>定义：<code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象</p>
<h5 id="为什么能实现响应式"><a href="#为什么能实现响应式" class="headerlink" title="为什么能实现响应式"></a>为什么能实现响应式</h5><span id="more"></span>

<p>通过<code>defineProperty</code> 两个属性，<code>get</code>及<code>set</code></p>
<ul>
<li>get</li>
</ul>
<p>属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值</p>
<ul>
<li>set</li>
</ul>
<p>属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined</p>
<p>下面通过代码展示：</p>
<p>定义一个响应式函数<code>defineReactive</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) {</span><br><span class="line">    app.<span class="property">innerText</span> = obj.<span class="property">foo</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) {</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, {</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">${key}</span>:<span class="subst">${val}</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        },</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) {</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) {</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>调用<code>defineReactive</code>，数据发生变化触发<code>update</code>方法，实现数据响应式</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = {}</span><br><span class="line"><span class="title function_">defineReactive</span>(obj, <span class="string">'foo'</span>, <span class="string">''</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>{</span><br><span class="line">    obj.<span class="property">foo</span> = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleTimeString</span>()</span><br><span class="line">},<span class="number">1000</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>在对象存在多个<code>key</code>情况下，需要进行遍历</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> {</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果存在嵌套对象的情况，还需要在<code>defineReactive</code>中进行递归</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) {</span><br><span class="line">    <span class="title function_">observe</span>(val)</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, {</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">${key}</span>:<span class="subst">${val}</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        },</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) {</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) {</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当给<code>key</code>赋值为对象的时候，还需要在<code>set</code>属性中进行递归</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">set</span>(<span class="params">newVal</span>) {</span><br><span class="line">    <span class="keyword">if</span> (newVal !== val) {</span><br><span class="line">        <span class="title function_">observe</span>(newVal) <span class="comment">// 新值是对象的情况</span></span><br><span class="line">        <span class="title function_">notifyUpdate</span>()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题</p>
<p>现在对一个对象进行删除与添加属性操作，无法劫持到</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = {</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">"foo"</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">"bar"</span></span><br><span class="line">}</span><br><span class="line"><span class="title function_">observe</span>(obj)</span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">foo</span> <span class="comment">// no ok</span></span><br><span class="line">obj.<span class="property">jar</span> = <span class="string">'xxx'</span> <span class="comment">// no ok</span></span><br></pre></td></tr></tbody></table></figure>

<p>当我们对一个数组进行监听的时候，并不那么好使了</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrData = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arrData.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val,index</span>)=&gt;</span>{</span><br><span class="line">    <span class="title function_">defineProperty</span>(arrData,index,val)</span><br><span class="line">})</span><br><span class="line">arrData.<span class="title function_">push</span>() <span class="comment">// no ok</span></span><br><span class="line">arrData.<span class="title function_">pop</span>()  <span class="comment">// no ok</span></span><br><span class="line">arrDate[<span class="number">0</span>] = <span class="number">99</span> <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到数据的<code>api</code>无法劫持到，从而无法实现数据响应式，</p>
<p>所以在<code>Vue2</code>中，增加了<code>set</code>、<code>delete</code> API，并且对数组<code>api</code>方法进行一个重写</p>
<p>还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>检测不到对象属性的添加和删除</li>
<li>数组<code>API</code>方法无法监听到</li>
<li>需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题</li>
</ul>
<h3 id="二、proxy"><a href="#二、proxy" class="headerlink" title="二、proxy"></a>二、proxy</h3><p><code>Proxy</code>的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了</p>
<p>在<code>ES6</code>系列中，我们详细讲解过<code>Proxy</code>的使用，就不再述说了</p>
<p>下面通过代码进行展示：</p>
<p>定义一个响应式方法<code>reactive</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> &amp;&amp; obj != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, {</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) {</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">${key}</span>:<span class="subst">${res}</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        },</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) {</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">${key}</span>:<span class="subst">${value}</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        },</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) {</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">${key}</span>:<span class="subst">${res}</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>测试一下简单数据的操作，发现都能劫持</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>({</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">'foo'</span></span><br><span class="line">})</span><br><span class="line"><span class="comment">// 1.获取</span></span><br><span class="line">state.<span class="property">foo</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 2.设置已存在属性</span></span><br><span class="line">state.<span class="property">foo</span> = <span class="string">'fooooooo'</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 3.设置不存在属性</span></span><br><span class="line">state.<span class="property">dong</span> = <span class="string">'dong'</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 4.删除属性</span></span><br><span class="line"><span class="keyword">delete</span> state.<span class="property">dong</span> <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure>

<p>再测试嵌套对象情况，这时候发现就不那么 OK 了</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>({</span><br><span class="line">    <span class="attr">bar</span>: { <span class="attr">a</span>: <span class="number">1</span> }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置嵌套对象属性</span></span><br><span class="line">state.<span class="property">bar</span>.<span class="property">a</span> = <span class="number">10</span> <span class="comment">// no ok</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果要解决，需要在<code>get</code>之上再进行一层代理</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> &amp;&amp; obj != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, {</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) {</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">${key}</span>:<span class="subst">${res}</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">isObject</span>(res) ? <span class="title function_">reactive</span>(res) : res</span><br><span class="line">        },</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p><code>Object.defineProperty</code>只能遍历对象属性进行劫持</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> {</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>Proxy</code>直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> &amp;&amp; obj != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, {</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) {</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">${key}</span>:<span class="subst">${res}</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        },</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) {</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">${key}</span>:<span class="subst">${value}</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        },</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) {</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">${key}</span>:<span class="subst">${res}</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>Proxy</code>可以直接监听数组的变化（<code>push</code>、<code>shift</code>、<code>splice</code>）</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> proxtObj = <span class="title function_">reactive</span>(obj)</span><br><span class="line">obj.<span class="title function_">psuh</span>(<span class="number">4</span>) <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>Proxy</code>有多达13种拦截方法,不限于<code>apply</code>、<code>ownKeys</code>、<code>deleteProperty</code>、<code>has</code>等等，这是<code>Object.defineProperty</code>不具备的</p>
<p>正因为<code>defineProperty</code>自身的缺陷，导致<code>Vue2</code>在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外<code>set</code>、<code>delete</code>方法）</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 数组重写</span></span><br><span class="line"><span class="keyword">const</span> originalProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Object</span>.<span class="title function_">create</span>(originalProto)</span><br><span class="line">[<span class="string">'push'</span>, <span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'splice'</span>, <span class="string">'reverse'</span>, <span class="string">'sort'</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> {</span><br><span class="line">  arrayProto[method] = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    originalProto[method].<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">arguments</span>)</span><br><span class="line">    dep.<span class="title function_">notice</span>()</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// set、delete</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(obj,<span class="string">'bar'</span>,<span class="string">'newbar'</span>)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">delete</span>(obj),<span class="string">'bar'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><code>Proxy</code> 不兼容IE，也没有 <code>polyfill</code>, <code>defineProperty</code> 能支持到IE9</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>proxy vs Object.defineProperty</tag>
      </tags>
  </entry>
  <entry>
    <title>v-if和v-show不能一起使用</title>
    <url>/posts/34987.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="v-if和v-show不能一起使用"><a href="#v-if和v-show不能一起使用" class="headerlink" title="v-if和v-show不能一起使用"></a>v-if和v-show不能一起使用</h1><h2 id="面试官：v-if和v-for的优先级是什么？"><a href="#面试官：v-if和v-for的优先级是什么？" class="headerlink" title="面试官：v-if和v-for的优先级是什么？"></a>面试官：v-if和v-for的优先级是什么？</h2><img src="/posts/34987/34987/image-20221015062131031.png" class="" title="image-20221015062131031">

<h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 <code>true</code>值的时候被渲染</p>
<p><code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组或者对象，而 <code>item</code> 则是被迭代的数组元素的别名</p>
<p>在 <code>v-for</code> 的时候，建议设置<code>key</code>值，并且保证每个<code>key</code>值是独一无二的，这便于<code>diff</code>算法进行优化</p>
<p>两者在用法上：</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Modal</span> v-<span class="keyword">if</span>=<span class="string">"isShow"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    {{ item.label }}</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="二、优先级"><a href="#二、优先级" class="headerlink" title="二、优先级"></a>二、优先级</h2><p><code>v-if</code>与<code>v-for</code>都是<code>vue</code>模板系统中的指令</p>
<p>在<code>vue</code>模板编译的时候，会将指令系统转化成可执行的<code>render</code>函数</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>编写一个<code>p</code>标签，同时使用<code>v-if</code>与 <code>v-for</code></p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">        {{ item.title }}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>创建<code>vue</code>实例，存放<code>isShow</code>与<code>items</code>数据</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>({</span><br><span class="line">  <span class="attr">el</span>: <span class="string">"#app"</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      <span class="attr">items</span>: [</span><br><span class="line">        { <span class="attr">title</span>: <span class="string">"foo"</span> },</span><br><span class="line">        { <span class="attr">title</span>: <span class="string">"baz"</span> }]</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">computed</span>: {</span><br><span class="line">    <span class="title function_">isShow</span>(<span class="params"></span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> &gt; <span class="number">0</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>模板指令的代码都会生成在<code>render</code>函数中，通过<code>app.$options.render</code>就能得到渲染函数</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">ƒ <span class="title function_">anonymous</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">with</span> (<span class="variable language_">this</span>) { <span class="keyword">return</span> </span><br><span class="line">    <span class="title function_">_c</span>(<span class="string">'div'</span>, { <span class="attr">attrs</span>: { <span class="string">"id"</span>: <span class="string">"app"</span> } }, </span><br><span class="line">    <span class="title function_">_l</span>((items), <span class="keyword">function</span> (<span class="params">item</span>) </span><br><span class="line">    { <span class="keyword">return</span> (isShow) ? <span class="title function_">_c</span>(<span class="string">'p'</span>, [<span class="title function_">_v</span>(<span class="string">"\n"</span> + <span class="title function_">_s</span>(item.<span class="property">title</span>) + <span class="string">"\n"</span>)]) : <span class="title function_">_e</span>() }), <span class="number">0</span>) }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>_l</code>是<code>vue</code>的列表渲染函数，函数内部都会进行一次<code>if</code>判断</p>
<p>初步得到结论：<code>v-for</code>优先级是比<code>v-if</code>高</p>
<p>再将<code>v-for</code>与<code>v-if</code>置于不同标签</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span>{{item.title}}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>再输出下<code>render</code>函数</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">ƒ <span class="title function_">anonymous</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="title function_">with</span>(<span class="params"><span class="variable language_">this</span></span>){<span class="keyword">return</span> </span><br><span class="line">    <span class="title function_">_c</span>(<span class="string">'div'</span>,{<span class="attr">attrs</span>:{<span class="string">"id"</span>:<span class="string">"app"</span>}},</span><br><span class="line">    [(isShow)?[<span class="title function_">_v</span>(<span class="string">"\n"</span>),</span><br><span class="line">    <span class="title function_">_l</span>((items),<span class="keyword">function</span>(<span class="params">item</span>){<span class="keyword">return</span> <span class="title function_">_c</span>(<span class="string">'p'</span>,[<span class="title function_">_v</span>(<span class="title function_">_s</span>(item.<span class="property">title</span>))])})]:<span class="title function_">_e</span>()],<span class="number">2</span>)}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这时候我们可以看到，<code>v-for</code>与<code>v-if</code>作用在不同标签时候，是先进行判断，再进行列表的渲染</p>
<p>我们再在查看下<code>vue</code>源码</p>
<p>源码位置：<code>\vue-dev\src\compiler\codegen\index.js</code></p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">genElement</span> (<span class="attr">el</span>: <span class="title class_">ASTElement</span>, <span class="attr">state</span>: <span class="title class_">CodegenState</span>): string {</span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">parent</span>) {</span><br><span class="line">    el.<span class="property">pre</span> = el.<span class="property">pre</span> || el.<span class="property">parent</span>.<span class="property">pre</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">staticRoot</span> &amp;&amp; !el.<span class="property">staticProcessed</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genStatic</span>(el, state)</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">once</span> &amp;&amp; !el.<span class="property">onceProcessed</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genOnce</span>(el, state)</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">for</span> &amp;&amp; !el.<span class="property">forProcessed</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genFor</span>(el, state)</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">if</span> &amp;&amp; !el.<span class="property">ifProcessed</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genIf</span>(el, state)</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">tag</span> === <span class="string">'template'</span> &amp;&amp; !el.<span class="property">slotTarget</span> &amp;&amp; !state.<span class="property">pre</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genChildren</span>(el, state) || <span class="string">'void 0'</span></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">tag</span> === <span class="string">'slot'</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genSlot</span>(el, state)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// component or element</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在进行<code>if</code>判断的时候，<code>v-for</code>是比<code>v-if</code>先进行判断</p>
<p>最终结论：<code>v-for</code>优先级比<code>v-if</code>高</p>
<h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h2><ol>
<li>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</li>
<li>如果避免出现这种情况，则在外层嵌套<code>template</code>（页面渲染不生成<code>dom</code>节点），在这一层进行v-if判断，然后在内部进行v-for循环</li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template v-<span class="keyword">if</span>=<span class="string">"isShow"</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>如果条件出现在循环内部，可通过计算属性<code>computed</code>提前过滤掉那些不需要显示的项</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: {</span><br><span class="line">    <span class="attr">items</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">item</span>) {</span><br><span class="line">        <span class="keyword">return</span> item.<span class="property">isShow</span></span><br><span class="line">      })</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>@js语音答题社区</p>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>v-if和v-show</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中的nextTick的理解</title>
    <url>/posts/3ebe0fba.html</url>
    <content><![CDATA[<html><head></head><body><p>技术交流群的朋友们提起了一个关于nextTick的问题： 引发了大家的热烈讨论</p>
<span id="more"></span>

<p>q: 问个问题，浏览器渲染时机是，当前宏任务完成，然后再进行微任务队列，然后完成后才渲染DOM，但是Vue的nextTick是优先微任务，那不就在渲染前执行？这个时候还没渲染吧， 这个时候能为什么能拿到更新之后的DOM？</p>
<p>a: dom是js描述UI的对象</p>
<p>a: 渲染UI是渲染UI不一样哦</p>
<p>a: js中的dom对象更新了</p>
<p>a: UI没更新</p>
<p>b: 确实在当前宏任务完成后，浏览器会先执行微任务队列，然后再渲染DOM。而Vue的nextTick确实是优先微任务，但它只是在下一个微任务队列中执行回调函数，而不是在渲染前执行。因此，Vue的nextTick不会影响浏览器的渲染时机。</p>
<p>a ： 每一帧都会判断dom有没有改变然后去更新页面这样</p>
<p>a : vue改dom对象的操作在nextTick之前</p>
<p>a: 所以就可以拿到修改的属性，然后页面上要等渲染UI后才能看到</p>
<p>c: 这个地方用框架来理解会有点奇怪</p>
<p>c: 用原生dom来理解好一点</p>
<p>c: 比如你创建一个元素 然后append到body 再获取高度 这个时候肯定是能查到元素高度的</p>
<p>c: 这个过程中 所有代码不都属于同一个任务吗</p>
<p>d: 针对nextTick这个问题，不知道我理解的对不对。nextTick本质是promise.then,除了里面的回调函数，其他所有的宏任务和微任务都会按顺序执行，等这些宏任务微任务都执行完毕之后，vue会相应地更新虚拟dom，这个时候才会执行nextTick即promise.then中的回调函数，所以里面能拿到最新的虚拟dom</p>
<p>e: 我把其他所有的宏任务微任务按顺序执行的整个过程理解为promise里面的构造函数，等构造函数里面的所有东西都执行完，再执行then，即对应nextTick中的回调函数</p>
<p>f: Vue更新数据时，dom并不会立即更新，因为你可能同时更新很多数据，如果dom更新是同步的，会导致你一个数据更新了100次，dom也更新100次，所以vue把dom更新放在了微任务队列中，当你同步更新了一百次数据，vue会在下一个微任务中更新dom</p>
<p>g: 是主线程去拿微任务或者宏任务（不纠结现在其他的任务队列，统称为宏任务），当主线程空闲时，会去拿微任务，如果微任务执行完了，再去拿宏任务，如果执行完一个宏任务，会再去微任务队列查看有没有微任务，如果没有，则再去拿宏任务，这种循环执行任务队列的方式，叫事件循环 ，也叫消息循环</p>
<p>各路大神各显神通， 八仙过海， 都说出了自己不同的理解</p>
<p><strong>在理解这个问题之前</strong>， <strong>我们有必要需要先了解一下什么是宏任务</strong></p>
<ol>
<li><code>setTimeout</code>: 用于在指定的时间后执行一个回调函数。它创建的宏任务将在指定的延时时间到达后加入宏任务队列。</li>
<li><code>setInterval</code>: 用于以固定的时间间隔重复执行一个回调函数。它创建的宏任务将在每个时间间隔到达时加入宏任务队列。</li>
<li><code>setImmediate</code>: 仅在 Node.js 环境中可用，用于在当前事件循环迭代完成后立即执行一个回调函数。它创建的宏任务将在当前迭代周期的末尾加入宏任务队列。</li>
<li>I/O 操作：网络请求、文件读写等异步 I/O 操作在完成时会创建宏任务并加入宏任务队列。</li>
<li>用户交互事件：如鼠标点击、键盘输入等。当用户产生交互事件时，浏览器会将相关的事件处理函数作为宏任务加入队列。</li>
<li>UI 渲染：浏览器可能会将 UI 渲染任务放入宏任务队列，以确保在其他宏任务执行完毕后进行页面渲染。</li>
<li><code>MessageChannel</code> 和 <code>MessagePort.postMessage</code>: 用于在 Web Workers 之间或跨窗口通信时创建宏任务。</li>
<li>其他 API 产生的宏任务：例如，<code>requestAnimationFrame</code>（在下一次重绘之前执行回调函数）和 <code>requestIdleCallback</code>（在浏览器空闲时段执行回调函数）等。</li>
</ol>
<p>这就说明， 键盘事件、鼠标事件、网络事件以及HTML解析在某种程度上可以看作宏任务。具体来说，这些事件或操作会触发相应的回调函数或事件处理函数。当浏览器准备执行这些回调或事件处理函数时，它们会被作为宏任务添加到事件循环的宏任务队列中。</p>
<ol>
<li>键盘事件和鼠标事件：当用户与页面进行交互，例如点击鼠标或按下键盘时，浏览器会将与这些事件相关的回调函数或事件处理函数作为宏任务加入宏任务队列。</li>
<li>网络事件：当网络请求（如Ajax、Fetch等）完成时，成功或失败的回调函数会作为宏任务添加到宏任务队列中。</li>
<li>HTML解析：HTML解析过程中，浏览器会遇到例如<code>&lt;script&gt;</code>标签等需要执行的代码。这些同步代码会直接在主线程上运行，而不是作为宏任务。然而，在解析过程中可能会遇到异步操作，如动态加载脚本等，这些操作会触发回调函数，这些回调函数会作为宏任务加入到宏任务队列中。</li>
</ol>
<p><strong>其实针对这个问题， 如果要想完美的解决。 得了解到一些概念， 同步代码， 宏任务， 微任务， 还有vue中的nextTick方法，</strong></p>
<ol>
<li>同步代码：同步代码是指在执行时按照顺序依次执行的代码。在同步代码中，一个任务的执行必须等待前一个任务完成。</li>
<li>宏任务（macro-task）：宏任务是指一些异步操作的任务，如<code>setTimeout</code>、<code>setInterval</code>和<code>requestAnimationFrame</code>等。宏任务会被添加到宏任务队列中，浏览器会在适当的时机执行这些任务。</li>
<li>微任务（micro-task）：微任务是一种比宏任务更轻量级的异步任务，如<code>Promise.then</code>、<code>MutationObserver</code>等。浏览器在执行宏任务之间以及执行完所有同步代码之后，会先执行微任务队列中的所有任务。</li>
<li>Vue中的<code>nextTick</code>方法：<code>nextTick</code>是Vue中的一个方法，它的作用是在DOM更新后执行指定的回调函数。<code>nextTick</code>的实现是基于微任务（micro-task），因此它的执行时机在当前宏任务完成、微任务队列执行之后，但在下一个宏任务开始之前。</li>
</ol>
<p>话不多说， 我们来举个例子来帮助理解这些个概念：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'1. 同步代码开始'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'4. 宏任务 setTimeout'</span>);</span><br><span class="line">}, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'2. 微任务 Promise.then'</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>({</span><br><span class="line">  <span class="attr">data</span>: {</span><br><span class="line">    <span class="attr">message</span>: <span class="string">'Hello, Vue!'</span></span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">vm.<span class="property">message</span> = <span class="string">'Hello, World!'</span>;</span><br><span class="line">vm.$nextTick(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'3. Vue.nextTick 回调'</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'1. 同步代码结束'</span>);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，代码的执行顺序如下：</p>
<ol>
<li>首先，浏览器执行同步代码，输出<code>1. 同步代码开始</code>和<code>1. 同步代码结束</code>。</li>
<li>接下来，浏览器检查微任务队列，发现有一个<code>Promise.then</code>的任务，执行它，输出<code>2. 微任务 Promise.then</code>。</li>
<li>此时，Vue的数据已经发生了变化，因此Vue会在微任务队列中添加一个<code>nextTick</code>的任务。浏览器发现微任务队列还有任务，执行<code>nextTick</code>回调，输出<code>3. Vue.nextTick 回调</code>。</li>
<li>最后，浏览器执行宏任务队列中的<code>setTimeout</code>任务，输出<code>4. 宏任务 setTimeout</code>。</li>
</ol>
<p>通过这个例子，你可以看到<code>nextTick</code>是在同步代码执行完毕、微任务队列执行之后、下一个宏任务开始之前执行的。因此，<code>nextTick</code>可以确保我们的回调函数在DOM更新之后执行，同时不影响浏览器的渲染性能。</p>
<p><strong>我们还需要注意一点</strong>， <strong>在事件循环（event loop）中，宏任务（macro-task）和微任务（micro-task）本身与渲染并没有直接关系。事件循环是浏览器中用于处理异步任务的一种机制，而渲染是浏览器将DOM更新反映在屏幕上的过程。</strong></p>
<p><strong>什么时候事件循环会进入下一个迭代周期？</strong></p>
<p>我们来用代码举一个例子： </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">console.log("同步代码 1");</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; {</span><br><span class="line">  console.log("宏任务 1");</span><br><span class="line">}, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(() =&gt; {</span><br><span class="line">  console.log("微任务 1");</span><br><span class="line">}).then(() =&gt; {</span><br><span class="line">  console.log("微任务 2");</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">console.log("同步代码 2");</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; {</span><br><span class="line">  console.log("宏任务 2");</span><br><span class="line">}, 0);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这段代码的执行顺序：</p>
<p>同步代码1 ——-&gt;  同步代码2———&gt; 微任务1———&gt; 微任务2———–&gt;宏任务1（这个时候执行完了一个宏任务， 就代表着进入了下一个迭代周期）</p>
<p>在第二个迭代周期里， 只有一个宏任务， 所以直接打印宏任务2</p>
<p>我们来看看进入迭代周期的标志： </p>
<ol>
<li>当前的同步代码执行完毕。</li>
<li>当前的微任务队列中的所有任务都已执行完毕。</li>
</ol>
<p>在每个迭代周期中，事件循环会按照以下顺序执行：</p>
<ol>
<li>执行同步代码。</li>
<li>检查并执行微任务队列中的所有任务。</li>
<li>检查并执行宏任务队列中的一个任务。</li>
</ol>
<p>所以综上所述： </p>
<p>Vue 的 <code>nextTick</code> 方法在内部使用了微任务队列。当数据发生变化时，Vue 会将 <code>nextTick</code> 的回调函数添加到微任务队列中。在浏览器的事件循环中，微任务队列中的任务会在宏任务之前执行。因此，可以理解为 <code>nextTick</code> 的回调函数会在当前宏任务完成后、DOM 渲染之前执行。</p>
<p>然而，需要注意的是，Vue 的数据变化和 DOM 更新是异步的。即使 <code>nextTick</code> 的回调函数在 DOM 渲染之前执行，但它仍然可以访问到已经更新的 DOM。这是因为 Vue 会在内部使用一个队列来批量处理数据更新，然后在一个适当的时机（通常是在当前宏任务完成后的微任务队列中）将这些更新应用到 DOM 上。这样，当 <code>nextTick</code> 的回调函数执行时，DOM 已经更新，但浏览器尚未进行最终渲染。</p>
<p><strong>值得注意的是：</strong></p>
<p>当代码刚开始执行时，浏览器首先会执行同步代码。这些同步代码并不属于宏任务。然而，在同步代码执行过程中，可能会创建并添加宏任务到宏任务队列中。例如，当代码中包含<code>setTimeout</code>或<code>setInterval</code>这类异步函数时，它们会创建并添加宏任务到队列。</p>
<p>简而言之，在代码刚开始执行时，是没有正在执行的宏任务的。同步代码执行完毕后，事件循环将检查宏任务队列，并按顺序执行队列中的任务。如果同步代码中创建了宏任务，那么这些任务将在同步代码执行完毕后被执行。</p>
</body></html>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue中的nextTick的理解</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中组件和插件的区别</title>
    <url>/posts/51138.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue中组件和插件的区别："><a href="#vue中组件和插件的区别：" class="headerlink" title="vue中组件和插件的区别："></a>vue中组件和插件的区别：</h1><h2 id="面试官：Vue中组件和插件有什么区别？"><a href="#面试官：Vue中组件和插件有什么区别？" class="headerlink" title="面试官：Vue中组件和插件有什么区别？"></a>面试官：Vue中组件和插件有什么区别？</h2><img src="/posts/51138/51138/image-20221019060916057.png" class="" title="image-20221019060916057">

<h3 id="一、组件是什么"><a href="#一、组件是什么" class="headerlink" title="一、组件是什么"></a>一、组件是什么</h3><p>回顾以前对组件的定义：</p>
<p>组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件</p>
<span id="more"></span>

<p>组件的优势</p>
<ul>
<li>降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</li>
<li>调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</li>
<li>提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</li>
</ul>
<h3 id="二、插件是什么"><a href="#二、插件是什么" class="headerlink" title="二、插件是什么"></a>二、插件是什么</h3><p>插件通常用来为 <code>Vue</code> 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：</p>
<ul>
<li>添加全局方法或者属性。如: <code>vue-custom-element</code></li>
<li>添加全局资源：指令/过滤器/过渡等。如 <code>vue-touch</code></li>
<li>通过全局混入来添加一些组件选项。如<code>vue-router</code></li>
<li>添加 <code>Vue</code> 实例方法，通过把它们添加到 <code>Vue.prototype</code> 上实现。</li>
<li>一个库，提供自己的 <code>API</code>，同时提供上面提到的一个或多个功能。如<code>vue-router</code></li>
</ul>
<h3 id="三、两者的区别"><a href="#三、两者的区别" class="headerlink" title="三、两者的区别"></a>三、两者的区别</h3><p>两者的区别主要表现在以下几个方面：</p>
<ul>
<li>编写形式</li>
<li>注册形式</li>
<li>使用场景</li>
</ul>
<h4 id="编写形式"><a href="#编写形式" class="headerlink" title="编写形式"></a>编写形式</h4><h5 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h5><p>编写一个组件，可以有很多方式，我们最常见的就是<code>vue</code>单文件的这种格式，每一个<code>.vue</code>文件我们都可以看成是一个组件</p>
<p><code>vue</code>文件标准格式</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span>{ </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ...</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">}</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>我们还可以通过<code>template</code>属性来编写一个组件，如果组件内容多，我们可以在外部定义<code>template</code>组件内容，如果组件内容并不多，我们可直接写在<code>template</code>属性上</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template id=<span class="string">"testComponent"</span>&gt;     <span class="comment">// 组件显示的内容</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>component!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>   </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">'componentA'</span>,{ </span><br><span class="line">    <span class="attr">template</span>: <span class="string">'#testComponent'</span>  </span><br><span class="line">    <span class="attr">template</span>: <span class="string">`&lt;div&gt;component&lt;/div&gt;`</span>  <span class="comment">// 组件内容少可以通过这种形式</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<h5 id="编写插件"><a href="#编写插件" class="headerlink" title="编写插件"></a>编写插件</h5><p><code>vue</code>插件的实现应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">MyPlugin</span>.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) {</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">myGlobalMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">'my-directive'</span>, {</span><br><span class="line">    bind (el, binding, vnode, oldVnode) {</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">  })</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">mixin</span>({</span><br><span class="line">    <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">  })</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params">methodOptions</span>) {</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="注册形式"><a href="#注册形式" class="headerlink" title="注册形式"></a>注册形式</h4><h5 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h5><p><code>vue</code>组件注册主要分为全局注册与局部注册</p>
<p>全局注册通过<code>Vue.component</code>方法，第一个参数为组件的名称，第二个参数为传入的配置项</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">'my-component-name'</span>, { <span class="comment">/* ... */</span> })</span><br></pre></td></tr></tbody></table></figure>

<p>局部注册只需在用到的地方通过<code>components</code>属性注册一个组件</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> component1 = {...} <span class="comment">// 定义一个组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">	<span class="attr">components</span>:{</span><br><span class="line">		component1   <span class="comment">// 局部注册</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="插件注册"><a href="#插件注册" class="headerlink" title="插件注册"></a>插件注册</h5><p>插件的注册通过<code>Vue.use()</code>的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(插件名字,{ <span class="comment">/* ... */</span>} )</span><br></pre></td></tr></tbody></table></figure>

<p>注意的是：</p>
<p>注册插件的时候，需要在调用 <code>new Vue()</code> 启动应用之前完成</p>
<p><code>Vue.use</code>会自动阻止多次注册相同插件，只会注册一次</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>具体的其实在插件是什么章节已经表述了，这里在总结一下</p>
<p>组件 <code>(Component)</code> 是用来构成你的 <code>App</code> 的业务模块，它的目标是 <code>App.vue</code></p>
<p>插件 <code>(Plugin)</code> 是用来增强你的技术栈的功能模块，它的目标是 <code>Vue</code> 本身</p>
<p>简单来说，插件就是指对<code>Vue</code>的功能的增强或补充</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>组件和插件</tag>
      </tags>
  </entry>
  <entry>
    <title>vue响应式</title>
    <url>/posts/31936.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue响应式解析"><a href="#vue响应式解析" class="headerlink" title="vue响应式解析"></a>vue响应式解析</h1><h2 id="了解状态和数据驱动视图"><a href="#了解状态和数据驱动视图" class="headerlink" title="了解状态和数据驱动视图"></a>了解状态和数据驱动视图</h2><p>众所周知，<code>Vue</code>最大的特点之一就是数据驱动视图，那么什么是数据驱动视图呢？在这里，我们可以把数据理解为状态，而视图就是用户可直观看到页面。页面不可能是一成不变的，它应该是动态变化的，而它的变化也不应该是无迹可寻的，它或者是由用户操作引起的，亦或者是由后端数据变化引起的，不管它是因为什么引起的，我们统称为它的状态变了，它由前一个状态变到了后一个状态，页面也就应该随之而变化，所以我们就可以得到如下一个公式：</p>
<span id="more"></span>

<p><strong>UI = render(state)</strong></p>
<p>上述公式中：状态<code>state</code>是输入，页面<code>UI</code>输出，状态输入一旦变化了，页面输出也随之而变化。我们把这种特性称之为数据驱动视图。</p>
<p>OK，有了基本概念以后，我们再把上述公式拆成三部分：<code>state</code>、<code>render()</code>以及<code>UI</code>。我们知道<code>state</code>和<code>UI</code>都是用户定的，而不变的是这个<code>render()</code>。所以<code>Vue</code>就扮演了<code>render()</code>这个角色，当<code>Vue</code>发现<code>state</code>变化之后，经过一系列加工，最终将变化反应在<code>UI</code>上。</p>
<p>那么第一个问题来了，<code>Vue</code>怎么知道<code>state</code>变化了呢？</p>
<h3 id="变化侦测"><a href="#变化侦测" class="headerlink" title="变化侦测"></a>变化侦测</h3><p>那<code>Vue</code>是怎么知道<code>state</code>变化了呢？换句话说，数据变化了是怎么通知给<code>Vue</code>呢？那么，这就引出了<code>Vue</code>中的变化侦测。</p>
<p>变化侦测就是追踪状态，亦或者说是数据的变化，一旦发生了变化，就要去更新视图。</p>
<p>变化侦测可不是个新名词，它在目前的前端三大框架中均有涉及。在<code>Angular</code>中是通过脏值检查流程来实现变化侦测；在<code>React</code>是通过对比虚拟<code>DOM</code>来实现变化侦测，而在<code>Vue</code>中也有自己的一套变化侦测实现机制。</p>
<p>那么，接下来我们就通过阅读源码来学习一下<code>Vue</code>是怎么实现自己的对数据变化进行侦测的机制</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>数据驱动视图简单来说就是数据变化引起视图变化，那么第一步就是先要知道数据什么时候发生变化，也就是说对数据的变化要进行侦测。</p>
<p>其次，数据的变化侦测在三大框架中均有涉及，不同的框架有着自己的一套侦测机制。</p>
</body></html>]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue响应式</tag>
      </tags>
  </entry>
  <entry>
    <title>vue实例挂载的工程中发生了什么？</title>
    <url>/posts/60238.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue实例挂载的过程中发生了什么？"><a href="#vue实例挂载的过程中发生了什么？" class="headerlink" title="vue实例挂载的过程中发生了什么？"></a>vue实例挂载的过程中发生了什么？</h1><h2 id="面试官：Vue实例挂载的过程"><a href="#面试官：Vue实例挂载的过程" class="headerlink" title="面试官：Vue实例挂载的过程"></a>面试官：Vue实例挂载的过程</h2><img src="/posts/60238/60238/image-20221013055145173.png" class="" title="image-20221013055145173">

<h3 id="一、思考"><a href="#一、思考" class="headerlink" title="一、思考"></a>一、思考</h3><p>我们都听过知其然知其所以然这句话</p>
<p>那么不知道大家是否思考过<code>new Vue()</code>这个过程中究竟做了些什么？</p>
<p>过程中是如何完成数据的绑定，又是如何将数据渲染到视图的等等</p>
<span id="more"></span>

<h3 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h3><p>首先找到<code>vue</code>的构造函数</p>
<p>源码位置：src\core\instance\index.js</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (options) {</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vue</span>)</span><br><span class="line">  ) {</span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>options</code>是用户传递过来的配置项，如<code>data、methods</code>等常用的方法</p>
<p><code>vue</code>构建函数调用<code>_init</code>方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">initMixin</span>(<span class="title class_">Vue</span>);     <span class="comment">// 定义 _init</span></span><br><span class="line"><span class="title function_">stateMixin</span>(<span class="title class_">Vue</span>);    <span class="comment">// 定义 $set $get $delete $watch 等</span></span><br><span class="line"><span class="title function_">eventsMixin</span>(<span class="title class_">Vue</span>);   <span class="comment">// 定义事件  $on  $once $off $emit</span></span><br><span class="line"><span class="title function_">lifecycleMixin</span>(<span class="title class_">Vue</span>);<span class="comment">// 定义 _update  $forceUpdate  $destroy</span></span><br><span class="line"><span class="title function_">renderMixin</span>(<span class="title class_">Vue</span>);   <span class="comment">// 定义 _render 返回虚拟dom</span></span><br></pre></td></tr></tbody></table></figure>

<p>首先可以看<code>initMixin</code>方法，发现该方法在<code>Vue</code>原型上定义了<code>_init</code>方法</p>
<p>源码位置：src\core\instance\init.js</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) {</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">// a uid</span></span><br><span class="line">    vm.<span class="property">_uid</span> = uid++</span><br><span class="line">    <span class="keyword">let</span> startTag, endTag</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) {</span><br><span class="line">      startTag = <span class="string">`vue-perf-start:<span class="subst">${vm._uid}</span>`</span></span><br><span class="line">      endTag = <span class="string">`vue-perf-end:<span class="subst">${vm._uid}</span>`</span></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">    vm.<span class="property">_isVue</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="comment">// 合并属性，判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options.<span class="property">_isComponent</span>) {</span><br><span class="line">      <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">      <span class="title function_">initInternalComponent</span>(vm, options)</span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">// 合并vue属性</span></span><br><span class="line">      vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">        <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span>),</span><br><span class="line">        options || {},</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span>) {</span><br><span class="line">      <span class="comment">// 初始化proxy拦截器</span></span><br><span class="line">      <span class="title function_">initProxy</span>(vm)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      vm.<span class="property">_renderProxy</span> = vm</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm.<span class="property">_self</span> = vm</span><br><span class="line">    <span class="comment">// 初始化组件生命周期标志位</span></span><br><span class="line">    <span class="title function_">initLifecycle</span>(vm)</span><br><span class="line">    <span class="comment">// 初始化组件事件侦听</span></span><br><span class="line">    <span class="title function_">initEvents</span>(vm)</span><br><span class="line">    <span class="comment">// 初始化渲染方法</span></span><br><span class="line">    <span class="title function_">initRender</span>(vm)</span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">    <span class="comment">// 初始化依赖注入内容，在初始化data、props之前</span></span><br><span class="line">    <span class="title function_">initInjections</span>(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    <span class="comment">// 初始化props/data/method/watch/methods</span></span><br><span class="line">    <span class="title function_">initState</span>(vm)</span><br><span class="line">    <span class="title function_">initProvide</span>(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">'created'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) {</span><br><span class="line">      vm.<span class="property">_name</span> = <span class="title function_">formatComponentName</span>(vm, <span class="literal">false</span>)</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">${vm._name}</span> init`</span>, startTag, endTag)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 挂载元素</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) {</span><br><span class="line">      vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>仔细阅读上面的代码，我们得到以下结论：</p>
<ul>
<li>在调用<code>beforeCreate</code>之前，数据初始化并未完成，像<code>data</code>、<code>props</code>这些属性无法访问到</li>
<li>到了<code>created</code>的时候，数据已经初始化完成，能够访问<code>data</code>、<code>props</code>这些属性，但这时候并未完成<code>dom</code>的挂载，因此无法访问到<code>dom</code>元素</li>
<li>挂载方法是调用<code>vm.$mount</code>方法</li>
</ul>
<p><code>initState</code>方法是完成<code>props/data/method/watch/methods</code>的初始化</p>
<p>源码位置：src\core\instance\state.js</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initState</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) {</span><br><span class="line">  <span class="comment">// 初始化组件的watcher列表</span></span><br><span class="line">  vm.<span class="property">_watchers</span> = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.<span class="property">$options</span></span><br><span class="line">  <span class="comment">// 初始化props</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">props</span>) <span class="title function_">initProps</span>(vm, opts.<span class="property">props</span>)</span><br><span class="line">  <span class="comment">// 初始化methods方法</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">methods</span>) <span class="title function_">initMethods</span>(vm, opts.<span class="property">methods</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">data</span>) {</span><br><span class="line">    <span class="comment">// 初始化data  </span></span><br><span class="line">    <span class="title function_">initData</span>(vm)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="title function_">observe</span>(vm.<span class="property">_data</span> = {}, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">computed</span>) <span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">watch</span> &amp;&amp; opts.<span class="property">watch</span> !== nativeWatch) {</span><br><span class="line">    <span class="title function_">initWatch</span>(vm, opts.<span class="property">watch</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们和这里主要看初始化<code>data</code>的方法为<code>initData</code>，它与<code>initState</code>在同一文件上</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) {</span><br><span class="line">  <span class="keyword">let</span> data = vm.<span class="property">$options</span>.<span class="property">data</span></span><br><span class="line">  <span class="comment">// 获取到组件上的data</span></span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="keyword">typeof</span> data === <span class="string">'function'</span></span><br><span class="line">    ? <span class="title function_">getData</span>(data, vm)</span><br><span class="line">    : data || {}</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isPlainObject</span>(data)) {</span><br><span class="line">    data = {}</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">'data functions should return an object:\n'</span> +</span><br><span class="line">      <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span></span><br><span class="line">  <span class="keyword">const</span> methods = vm.<span class="property">$options</span>.<span class="property">methods</span></span><br><span class="line">  <span class="keyword">let</span> i = keys.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) {</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span>) {</span><br><span class="line">      <span class="comment">// 属性名不能与方法名重复</span></span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; <span class="title function_">hasOwn</span>(methods, key)) {</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Method "<span class="subst">${key}</span>" has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 属性名不能与state名称重复</span></span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) {</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`The data property "<span class="subst">${key}</span>" is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isReserved</span>(key)) { <span class="comment">// 验证key值的合法性</span></span><br><span class="line">      <span class="comment">// 将_data中的数据挂载到组件vm上,这样就可以通过this.xxx访问到组件上的数据</span></span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="comment">// 响应式监听data是数据的变化</span></span><br><span class="line">  <span class="title function_">observe</span>(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>仔细阅读上面的代码，我们可以得到以下结论：</p>
<ul>
<li>初始化顺序：<code>props</code>、<code>methods</code>、<code>data</code></li>
<li><code>data</code>定义的时候可选择函数形式或者对象形式（组件只能为函数形式）</li>
</ul>
<p>关于数据响应式在这就不展开详细说明</p>
<p>上文提到挂载方法是调用<code>vm.$mount</code>方法</p>
<p>源码位置：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: string | Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> {</span><br><span class="line">  <span class="comment">// 获取或查询元素</span></span><br><span class="line">  el = el &amp;&amp; <span class="title function_">query</span>(el)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="comment">// vue 不允许直接挂载到body或页面文档上</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) {</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span></span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">render</span>) {</span><br><span class="line">    <span class="keyword">let</span> template = options.<span class="property">template</span></span><br><span class="line">    <span class="comment">// 存在template模板，解析vue模板文件</span></span><br><span class="line">    <span class="keyword">if</span> (template) {</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) {</span><br><span class="line">        <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">'#'</span>) {</span><br><span class="line">          template = <span class="title function_">idToTemplate</span>(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp; !template) {</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">${options.template}</span>`</span>,</span><br><span class="line">              <span class="variable language_">this</span></span><br><span class="line">            )</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) {</span><br><span class="line">        template = template.<span class="property">innerHTML</span></span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span>) {</span><br><span class="line">          <span class="title function_">warn</span>(<span class="string">'invalid template option:'</span> + template, <span class="variable language_">this</span>)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (el) {</span><br><span class="line">      <span class="comment">// 通过选择器获取元素内容</span></span><br><span class="line">      template = <span class="title function_">getOuterHTML</span>(el)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (template) {</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) {</span><br><span class="line">        <span class="title function_">mark</span>(<span class="string">'compile'</span>)</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  1.将temmplate解析ast tree</span></span><br><span class="line"><span class="comment">       *  2.将ast tree转换成render语法字符串</span></span><br><span class="line"><span class="comment">       *  3.生成render方法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">const</span> { render, staticRenderFns } = <span class="title function_">compileToFunctions</span>(template, {</span><br><span class="line">        <span class="attr">outputSourceRange</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span>,</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">        <span class="attr">comments</span>: options.<span class="property">comments</span></span><br><span class="line">      }, <span class="variable language_">this</span>)</span><br><span class="line">      options.<span class="property">render</span> = render</span><br><span class="line">      options.<span class="property">staticRenderFns</span> = staticRenderFns</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) {</span><br><span class="line">        <span class="title function_">mark</span>(<span class="string">'compile end'</span>)</span><br><span class="line">        <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">${<span class="variable language_">this</span>._name}</span> compile`</span>, <span class="string">'compile'</span>, <span class="string">'compile end'</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>阅读上面代码，我们能得到以下结论：</p>
<ul>
<li>不要将根元素放到<code>body</code>或者<code>html</code>上</li>
<li>可以在对象中定义<code>template/render</code>或者直接使用<code>template</code>、<code>el</code>表示元素选择器</li>
<li>最终都会解析成<code>render</code>函数，调用<code>compileToFunctions</code>，会将<code>template</code>解析成<code>render</code>函数</li>
</ul>
<p>对<code>template</code>的解析步骤大致分为以下几步：</p>
<ul>
<li>将<code>html</code>文档片段解析成<code>ast</code>描述符</li>
<li>将<code>ast</code>描述符解析成字符串</li>
<li>生成<code>render</code>函数</li>
</ul>
<p>生成<code>render</code>函数，挂载到<code>vm</code>上后，会再次调用<code>mount</code>方法</p>
<p>源码位置：src\platforms\web\runtime\index.js</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// public mount method</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: string | Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> {</span><br><span class="line">  el = el &amp;&amp; inBrowser ? <span class="title function_">query</span>(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 渲染组件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mountComponent</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>调用<code>mountComponent</code>渲染组件</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span> (</span><br><span class="line">  <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">el</span>: ?<span class="title class_">Element</span>,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): <span class="title class_">Component</span> {</span><br><span class="line">  vm.<span class="property">$el</span> = el</span><br><span class="line">  <span class="comment">// 如果没有获取解析的render函数，则会抛出警告</span></span><br><span class="line">  <span class="comment">// render是解析模板文件生成的</span></span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="property">$options</span>.<span class="property">render</span>) {</span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span> = createEmptyVNode</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span>) {</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.<span class="property">$options</span>.<span class="property">template</span> &amp;&amp; vm.<span class="property">$options</span>.<span class="property">template</span>.<span class="title function_">charAt</span>(<span class="number">0</span>) !== <span class="string">'#'</span>) ||</span><br><span class="line">        vm.<span class="property">$options</span>.<span class="property">el</span> || el) {</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class="line">          <span class="string">'compiler is not available. Either pre-compile the templates into '</span> +</span><br><span class="line">          <span class="string">'render functions, or use the compiler-included build.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 没有获取到vue的模板文件</span></span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 执行beforeMount钩子</span></span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) {</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">const</span> name = vm.<span class="property">_name</span></span><br><span class="line">      <span class="keyword">const</span> id = vm.<span class="property">_uid</span></span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">${id}</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">${id}</span>`</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>()</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">${name}</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating)</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">${name}</span> patch`</span>, startTag, endTag)</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 定义更新函数</span></span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="comment">// 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render</span></span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher's constructor</span></span><br><span class="line">  <span class="comment">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component's mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="comment">// 监听当前组件状态，当有数据变化时，更新组件</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, {</span><br><span class="line">    before () {</span><br><span class="line">      <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) {</span><br><span class="line">        <span class="comment">// 数据更新引发的组件更新</span></span><br><span class="line">        <span class="title function_">callHook</span>(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) {</span><br><span class="line">    vm.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">'mounted'</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>阅读上面代码，我们得到以下结论：</p>
<ul>
<li>会触发<code>beforeCreate</code>钩子</li>
<li>定义<code>updateComponent</code>渲染页面视图的方法</li>
<li>监听组件数据，一旦发生变化，触发<code>beforeUpdate</code>生命钩子</li>
</ul>
<p><code>updateComponent</code>方法主要执行在<code>vue</code>初始化时声明的<code>render</code>，<code>update</code>方法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">render`的作用主要是生成`vnode</span><br></pre></td></tr></tbody></table></figure>

<p>源码位置：src\core\instance\render.js</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 定义vue 原型上的render方法</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> {</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">// render函数来自于组件的option</span></span><br><span class="line">    <span class="keyword">const</span> { render, _parentVnode } = vm.<span class="property">$options</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_parentVnode) {</span><br><span class="line">        vm.<span class="property">$scopedSlots</span> = <span class="title function_">normalizeScopedSlots</span>(</span><br><span class="line">            _parentVnode.<span class="property">data</span>.<span class="property">scopedSlots</span>,</span><br><span class="line">            vm.<span class="property">$slots</span>,</span><br><span class="line">            vm.<span class="property">$scopedSlots</span></span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">    <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">    vm.<span class="property">$vnode</span> = _parentVnode</span><br><span class="line">    <span class="comment">// render self</span></span><br><span class="line">    <span class="keyword">let</span> vnode</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// There's no need to maintain a stack because all render fns are called</span></span><br><span class="line">        <span class="comment">// separately from one another. Nested component's render fns are called</span></span><br><span class="line">        <span class="comment">// when parent component is patched.</span></span><br><span class="line">        currentRenderingInstance = vm</span><br><span class="line">        <span class="comment">// 调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode</span></span><br><span class="line">        vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br><span class="line">    } <span class="keyword">catch</span> (e) {</span><br><span class="line">        <span class="title function_">handleError</span>(e, vm, <span class="string">`render`</span>)</span><br><span class="line">        <span class="comment">// return error render result,</span></span><br><span class="line">        <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">        <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp; vm.<span class="property">$options</span>.<span class="property">renderError</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                vnode = vm.<span class="property">$options</span>.<span class="property">renderError</span>.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>, e)</span><br><span class="line">            } <span class="keyword">catch</span> (e) {</span><br><span class="line">                <span class="title function_">handleError</span>(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">                vnode = vm.<span class="property">_vnode</span></span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            vnode = vm.<span class="property">_vnode</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        currentRenderingInstance = <span class="literal">null</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// if the returned array contains only a single node, allow it</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode) &amp;&amp; vnode.<span class="property">length</span> === <span class="number">1</span>) {</span><br><span class="line">        vnode = vnode[<span class="number">0</span>]</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> <span class="title class_">VNode</span>)) {</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode)) {</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">                <span class="string">'Multiple root nodes returned from render function. Render function '</span> +</span><br><span class="line">                <span class="string">'should return a single root node.'</span>,</span><br><span class="line">                vm</span><br><span class="line">            )</span><br><span class="line">        }</span><br><span class="line">        vnode = <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// set parent</span></span><br><span class="line">    vnode.<span class="property">parent</span> = _parentVnode</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>_update</code>主要功能是调用<code>patch</code>，将<code>vnode</code>转换为真实<code>DOM</code>，并且更新到页面中</p>
<p>源码位置：src\core\instance\lifecycle.js</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) {</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.<span class="property">$el</span></span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm.<span class="property">_vnode</span></span><br><span class="line">    <span class="comment">// 设置当前激活的作用域</span></span><br><span class="line">    <span class="keyword">const</span> restoreActiveInstance = <span class="title function_">setActiveInstance</span>(vm)</span><br><span class="line">    vm.<span class="property">_vnode</span> = vnode</span><br><span class="line">    <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">    <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) {</span><br><span class="line">      <span class="comment">// initial render</span></span><br><span class="line">      <span class="comment">// 执行具体的挂载逻辑</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// updates</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(prevVnode, vnode)</span><br><span class="line">    }</span><br><span class="line">    <span class="title function_">restoreActiveInstance</span>()</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) {</span><br><span class="line">      prevEl.<span class="property">__vue__</span> = <span class="literal">null</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$el</span>) {</span><br><span class="line">      vm.<span class="property">$el</span>.<span class="property">__vue__</span> = vm</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$vnode</span> &amp;&amp; vm.<span class="property">$parent</span> &amp;&amp; vm.<span class="property">$vnode</span> === vm.<span class="property">$parent</span>.<span class="property">_vnode</span>) {</span><br><span class="line">      vm.<span class="property">$parent</span>.<span class="property">$el</span> = vm.<span class="property">$el</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">    <span class="comment">// updated in a parent's updated hook.</span></span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h3><ul>
<li><code>new Vue</code>的时候调用会调用<code>_init</code>方法<ul>
<li>定义 <code>$set</code>、<code>$get</code> 、<code>$delete</code>、<code>$watch</code> 等方法</li>
<li>定义 <code>$on</code>、<code>$off</code>、<code>$emit</code>、<code>$off</code>等事件</li>
<li>定义 <code>_update</code>、<code>$forceUpdate</code>、<code>$destroy</code>生命周期</li>
</ul>
</li>
<li>调用<code>$mount</code>进行页面的挂载</li>
<li>挂载的时候主要是通过<code>mountComponent</code>方法</li>
<li>定义<code>updateComponent</code>更新函数</li>
<li>执行<code>render</code>生成虚拟<code>DOM</code></li>
<li><code>_update</code>将虚拟<code>DOM</code>生成真实<code>DOM</code>结构，并且渲染到页面中</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://www.cnblogs.com/gerry2019/p/12001661.html">https://www.cnblogs.com/gerry2019/p/12001661.html</a></li>
<li><a href="https://github.com/vuejs/vue/tree/dev/src/core/instance">https://github.com/vuejs/vue/tree/dev/src/core/instance</a></li>
<li><a href="https://vue3js.cn/">https://vue3js.cn</a></li>
</ul>
<p>@js语言答题社区</p>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue实例挂载</tag>
      </tags>
  </entry>
  <entry>
    <title>vue权限管理</title>
    <url>/posts/29902.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue权限管理"><a href="#vue权限管理" class="headerlink" title="vue权限管理"></a>vue权限管理</h1><h2 id="面试官：vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？"><a href="#面试官：vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？" class="headerlink" title="面试官：vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？"></a>面试官：vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？</h2><img src="/posts/29902/29902/image-20221107070338527.png" class="" title="image-20221107070338527">

<h3 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h3><p>权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源</p>
<p>而前端权限归根结底是请求的发起权，请求的发起可能有下面两种形式触发</p>
<span id="more"></span>

<ul>
<li>页面加载触发</li>
<li>页面上的按钮点击触发</li>
</ul>
<p>总的来说，所有的请求发起都触发自前端路由或视图</p>
<p>所以我们可以从这两方面入手，对触发权限的源头进行控制，最终要实现的目标是：</p>
<ul>
<li>路由方面，用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 <code>4xx</code> 提示页</li>
<li>视图方面，用户只能看到自己有权浏览的内容和有权操作的控件</li>
<li>最后再加上请求控制作为最后一道防线，路由可能配置失误，按钮可能忘了加权限，这种时候请求控制可以用来兜底，越权请求将在前端被拦截</li>
</ul>
<h3 id="二、如何做"><a href="#二、如何做" class="headerlink" title="二、如何做"></a>二、如何做</h3><p>前端权限控制可以分为四个方面：</p>
<ul>
<li>接口权限</li>
<li>按钮权限</li>
<li>菜单权限</li>
<li>路由权限</li>
</ul>
<h4 id="接口权限"><a href="#接口权限" class="headerlink" title="接口权限"></a>接口权限</h4><p>接口权限目前一般采用<code>jwt</code>的形式来验证，没有通过的话一般返回<code>401</code>，跳转到登录页面重新进行登录</p>
<p>登录完拿到<code>token</code>，将<code>token</code>存起来，通过<code>axios</code>请求拦截器进行拦截，每次请求的时候头部携带<code>token</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> {</span><br><span class="line">    config.<span class="property">headers</span>[<span class="string">'token'</span>] = cookie.<span class="title function_">get</span>(<span class="string">'token'</span>)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">})</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">res</span>=&gt;</span>{},{response}=&gt;{</span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">40099</span> || response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">40098</span>) { <span class="comment">//token过期或者错误</span></span><br><span class="line">        router.<span class="title function_">push</span>(<span class="string">'/login'</span>)</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<h4 id="路由权限控制"><a href="#路由权限控制" class="headerlink" title="路由权限控制"></a>路由权限控制</h4><p><strong>方案一</strong></p>
<p>初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routerMap = [</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">path</span>: <span class="string">'/permission'</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">'/permission/index'</span>,</span><br><span class="line">    <span class="attr">alwaysShow</span>: <span class="literal">true</span>, <span class="comment">// will always show the root menu</span></span><br><span class="line">    <span class="attr">meta</span>: {</span><br><span class="line">      <span class="attr">title</span>: <span class="string">'permission'</span>,</span><br><span class="line">      <span class="attr">icon</span>: <span class="string">'lock'</span>,</span><br><span class="line">      <span class="attr">roles</span>: [<span class="string">'admin'</span>, <span class="string">'editor'</span>] <span class="comment">// you can set roles in root nav</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">children</span>: [{</span><br><span class="line">      <span class="attr">path</span>: <span class="string">'page'</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/permission/page'</span>),</span><br><span class="line">      <span class="attr">name</span>: <span class="string">'pagePermission'</span>,</span><br><span class="line">      <span class="attr">meta</span>: {</span><br><span class="line">        <span class="attr">title</span>: <span class="string">'pagePermission'</span>,</span><br><span class="line">        <span class="attr">roles</span>: [<span class="string">'admin'</span>] <span class="comment">// or you can only set roles in sub nav</span></span><br><span class="line">      }</span><br><span class="line">    }, {</span><br><span class="line">      <span class="attr">path</span>: <span class="string">'directive'</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/permission/directive'</span>),</span><br><span class="line">      <span class="attr">name</span>: <span class="string">'directivePermission'</span>,</span><br><span class="line">      <span class="attr">meta</span>: {</span><br><span class="line">        <span class="attr">title</span>: <span class="string">'directivePermission'</span></span><br><span class="line">        <span class="comment">// if do not set roles, means: this page does not require permission</span></span><br><span class="line">      }</span><br><span class="line">    }]</span><br><span class="line">  }]</span><br></pre></td></tr></tbody></table></figure>

<p>这种方式存在以下四种缺点：</p>
<ul>
<li>加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。</li>
<li>全局路由守卫里，每次路由跳转都要做权限判断。</li>
<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>
<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li>
</ul>
<p><strong>方案二</strong></p>
<p>初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制</p>
<p>登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用<code>addRoutes</code>添加路由</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">Message</span> } <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">NProgress</span> <span class="keyword">from</span> <span class="string">'nprogress'</span> <span class="comment">// progress bar</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'nprogress/nprogress.css'</span><span class="comment">// progress bar style</span></span><br><span class="line"><span class="keyword">import</span> { getToken } <span class="keyword">from</span> <span class="string">'@/utils/auth'</span> <span class="comment">// getToken from cookie</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">NProgress</span>.<span class="title function_">configure</span>({ <span class="attr">showSpinner</span>: <span class="literal">false</span> })<span class="comment">// NProgress Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// permission judge function</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasPermission</span>(<span class="params">roles, permissionRoles</span>) {</span><br><span class="line">  <span class="keyword">if</span> (roles.<span class="title function_">indexOf</span>(<span class="string">'admin'</span>) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// admin permission passed directly</span></span><br><span class="line">  <span class="keyword">if</span> (!permissionRoles) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> roles.<span class="title function_">some</span>(<span class="function"><span class="params">role</span> =&gt;</span> permissionRoles.<span class="title function_">indexOf</span>(role) &gt;= <span class="number">0</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> whiteList = [<span class="string">'/login'</span>, <span class="string">'/authredirect'</span>]<span class="comment">// no redirect whitelist</span></span><br><span class="line"></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> {</span><br><span class="line">  <span class="title class_">NProgress</span>.<span class="title function_">start</span>() <span class="comment">// start progress bar</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">getToken</span>()) { <span class="comment">// determine if there has token</span></span><br><span class="line">    <span class="comment">/* has token*/</span></span><br><span class="line">    <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">'/login'</span>) {</span><br><span class="line">      <span class="title function_">next</span>({ <span class="attr">path</span>: <span class="string">'/'</span> })</span><br><span class="line">      <span class="title class_">NProgress</span>.<span class="title function_">done</span>() <span class="comment">// if current page is dashboard will not trigger	afterEach hook, so manually handle it</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">if</span> (store.<span class="property">getters</span>.<span class="property">roles</span>.<span class="property">length</span> === <span class="number">0</span>) { <span class="comment">// 判断当前用户是否已拉取完user_info信息</span></span><br><span class="line">        store.<span class="title function_">dispatch</span>(<span class="string">'GetUserInfo'</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> { <span class="comment">// 拉取user_info</span></span><br><span class="line">          <span class="keyword">const</span> roles = res.<span class="property">data</span>.<span class="property">roles</span> <span class="comment">// note: roles must be a array! such as: ['editor','develop']</span></span><br><span class="line">          store.<span class="title function_">dispatch</span>(<span class="string">'GenerateRoutes'</span>, { roles }).<span class="title function_">then</span>(<span class="function">() =&gt;</span> { <span class="comment">// 根据roles权限生成可访问的路由表</span></span><br><span class="line">            router.<span class="title function_">addRoutes</span>(store.<span class="property">getters</span>.<span class="property">addRouters</span>) <span class="comment">// 动态添加可访问路由表</span></span><br><span class="line">            <span class="title function_">next</span>({ ...to, <span class="attr">replace</span>: <span class="literal">true</span> }) <span class="comment">// hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record</span></span><br><span class="line">          })</span><br><span class="line">        }).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> {</span><br><span class="line">          store.<span class="title function_">dispatch</span>(<span class="string">'FedLogOut'</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">            <span class="title class_">Message</span>.<span class="title function_">error</span>(err || <span class="string">'Verification failed, please login again'</span>)</span><br><span class="line">            <span class="title function_">next</span>({ <span class="attr">path</span>: <span class="string">'/'</span> })</span><br><span class="line">          })</span><br><span class="line">        })</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">hasPermission</span>(store.<span class="property">getters</span>.<span class="property">roles</span>, to.<span class="property">meta</span>.<span class="property">roles</span>)) {</span><br><span class="line">          <span class="title function_">next</span>()<span class="comment">//</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="title function_">next</span>({ <span class="attr">path</span>: <span class="string">'/401'</span>, <span class="attr">replace</span>: <span class="literal">true</span>, <span class="attr">query</span>: { <span class="attr">noGoBack</span>: <span class="literal">true</span> }})</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 可删 ↑</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">/* has no token*/</span></span><br><span class="line">    <span class="keyword">if</span> (whiteList.<span class="title function_">indexOf</span>(to.<span class="property">path</span>) !== -<span class="number">1</span>) { <span class="comment">// 在免登录白名单，直接进入</span></span><br><span class="line">      <span class="title function_">next</span>()</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">'/login'</span>) <span class="comment">// 否则全部重定向到登录页</span></span><br><span class="line">      <span class="title class_">NProgress</span>.<span class="title function_">done</span>() <span class="comment">// if current page is login will not trigger afterEach hook, so manually handle it</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="title class_">NProgress</span>.<span class="title function_">done</span>() <span class="comment">// finish progress bar</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限</p>
<p>这种方式也存在了以下的缺点：</p>
<ul>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>
<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li>
</ul>
<h4 id="菜单权限"><a href="#菜单权限" class="headerlink" title="菜单权限"></a>菜单权限</h4><p>菜单权限可以理解成将页面与理由进行解耦</p>
<h5 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h5><p>菜单与路由分离，菜单由后端返回</p>
<p>前端定义路由信息</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">name</span>: <span class="string">"login"</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">"/login"</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">"@/pages/Login.vue"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>name</code>字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有<code>name</code>对应的字段，并且做唯一性校验</p>
<p>全局路由守卫里做判断</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasPermission</span>(<span class="params">router, accessMenu</span>) {</span><br><span class="line">  <span class="keyword">if</span> (whiteList.<span class="title function_">indexOf</span>(router.<span class="property">path</span>) !== -<span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">let</span> menu = <span class="title class_">Util</span>.<span class="title function_">getMenuByName</span>(router.<span class="property">name</span>, accessMenu);</span><br><span class="line">  <span class="keyword">if</span> (menu.<span class="property">name</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title class_">Router</span>.<span class="title function_">beforeEach</span>(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; {</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">getToken</span>()) {</span><br><span class="line">    <span class="keyword">let</span> userInfo = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">userInfo</span>;</span><br><span class="line">    <span class="keyword">if</span> (!userInfo.<span class="property">name</span>) {</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">"GetUserInfo"</span>)</span><br><span class="line">        <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">'updateAccessMenu'</span>)</span><br><span class="line">        <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">'/login'</span>) {</span><br><span class="line">          <span class="title function_">next</span>({ <span class="attr">name</span>: <span class="string">'home_index'</span> })</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="comment">//Util.toDefaultPage([...routers], to.name, router, next);</span></span><br><span class="line">          <span class="title function_">next</span>({ ...to, <span class="attr">replace</span>: <span class="literal">true</span> })<span class="comment">//菜单权限更新完成,重新进一次当前路由</span></span><br><span class="line">        }</span><br><span class="line">      }  </span><br><span class="line">      <span class="keyword">catch</span> (e) {</span><br><span class="line">        <span class="keyword">if</span> (whiteList.<span class="title function_">indexOf</span>(to.<span class="property">path</span>) !== -<span class="number">1</span>) { <span class="comment">// 在免登录白名单，直接进入</span></span><br><span class="line">          <span class="title function_">next</span>()</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="title function_">next</span>(<span class="string">'/login'</span>)</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">'/login'</span>) {</span><br><span class="line">        <span class="title function_">next</span>({ <span class="attr">name</span>: <span class="string">'home_index'</span> })</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">hasPermission</span>(to, store.<span class="property">getters</span>.<span class="property">accessMenu</span>)) {</span><br><span class="line">          <span class="title class_">Util</span>.<span class="title function_">toDefaultPage</span>(store.<span class="property">getters</span>.<span class="property">accessMenu</span>,to, routes, next);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="title function_">next</span>({ <span class="attr">path</span>: <span class="string">'/403'</span>,<span class="attr">replace</span>:<span class="literal">true</span> })</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">if</span> (whiteList.<span class="title function_">indexOf</span>(to.<span class="property">path</span>) !== -<span class="number">1</span>) { <span class="comment">// 在免登录白名单，直接进入</span></span><br><span class="line">      <span class="title function_">next</span>()</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">'/login'</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">let</span> menu = <span class="title class_">Util</span>.<span class="title function_">getMenuByName</span>(to.<span class="property">name</span>, store.<span class="property">getters</span>.<span class="property">accessMenu</span>);</span><br><span class="line">  <span class="title class_">Util</span>.<span class="title function_">title</span>(menu.<span class="property">title</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="title class_">Router</span>.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的<code>name</code>与路由的<code>name</code>是一一对应的，而后端返回的菜单就已经是经过权限过滤的</p>
<p>如果根据路由<code>name</code>找不到对应的菜单，就表示用户有没权限访问</p>
<p>如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过<code>addRoutes</code>动态挂载</p>
<p>这种方式的缺点：</p>
<ul>
<li>菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用</li>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
</ul>
<h5 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h5><p>菜单和路由都由后端返回</p>
<p>前端统一定义路由组件</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">"../pages/Home.vue"</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserInfo</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">"../pages/UserInfo.vue"</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">    <span class="attr">home</span>: <span class="title class_">Home</span>,</span><br><span class="line">    <span class="attr">userInfo</span>: <span class="title class_">UserInfo</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>后端路由组件返回以下格式</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        <span class="attr">name</span>: <span class="string">"home"</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">"/"</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="string">"home"</span></span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        <span class="attr">name</span>: <span class="string">"home"</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">"/userinfo"</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="string">"userInfo"</span></span><br><span class="line">    }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>在将后端返回路由通过<code>addRoutes</code>动态挂载之间，需要将数据处理一下，将<code>component</code>字段换为真正的组件</p>
<p>如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理</p>
<p>这种方法也会存在缺点：</p>
<ul>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
<li>前后端的配合要求更高</li>
</ul>
<h4 id="按钮权限"><a href="#按钮权限" class="headerlink" title="按钮权限"></a>按钮权限</h4><h5 id="方案一-1"><a href="#方案一-1" class="headerlink" title="方案一"></a>方案一</h5><p>按钮权限也可以用<code>v-if</code>判断</p>
<p>但是如果页面过多，每个页面页面都要获取用户权限<code>role</code>和路由表里的<code>meta.btnPermissions</code>，然后再做判断</p>
<p>这种方式就不展开举例了</p>
<h5 id="方案二-1"><a href="#方案二-1" class="headerlink" title="方案二"></a>方案二</h5><p>通过自定义指令进行按钮权限的判断</p>
<p>首先配置路由</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">path</span>: <span class="string">'/permission'</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">'权限测试'</span>,</span><br><span class="line">    <span class="attr">meta</span>: {</span><br><span class="line">        <span class="attr">btnPermissions</span>: [<span class="string">'admin'</span>, <span class="string">'supper'</span>, <span class="string">'normal'</span>]</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">//页面需要的权限</span></span><br><span class="line">    <span class="attr">children</span>: [{</span><br><span class="line">        <span class="attr">path</span>: <span class="string">'supper'</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title function_">_import</span>(<span class="string">'system/supper'</span>),</span><br><span class="line">        <span class="attr">name</span>: <span class="string">'权限测试页'</span>,</span><br><span class="line">        <span class="attr">meta</span>: {</span><br><span class="line">            <span class="attr">btnPermissions</span>: [<span class="string">'admin'</span>, <span class="string">'supper'</span>]</span><br><span class="line">        } <span class="comment">//页面需要的权限</span></span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        <span class="attr">path</span>: <span class="string">'normal'</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title function_">_import</span>(<span class="string">'system/normal'</span>),</span><br><span class="line">        <span class="attr">name</span>: <span class="string">'权限测试页'</span>,</span><br><span class="line">        <span class="attr">meta</span>: {</span><br><span class="line">            <span class="attr">btnPermissions</span>: [<span class="string">'admin'</span>]</span><br><span class="line">        } <span class="comment">//页面需要的权限</span></span><br><span class="line">    }]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>自定义权限鉴定指令</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">/**权限指令**/</span></span><br><span class="line"><span class="keyword">const</span> has = <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">'has'</span>, {</span><br><span class="line">    <span class="attr">bind</span>: <span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) {</span><br><span class="line">        <span class="comment">// 获取页面按钮权限</span></span><br><span class="line">        <span class="keyword">let</span> btnPermissionsArr = [];</span><br><span class="line">        <span class="keyword">if</span>(binding.<span class="property">value</span>){</span><br><span class="line">            <span class="comment">// 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。</span></span><br><span class="line">            btnPermissionsArr = <span class="title class_">Array</span>.<span class="title function_">of</span>(binding.<span class="property">value</span>);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">// 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。</span></span><br><span class="line">            btnPermissionsArr = vnode.<span class="property">context</span>.<span class="property">$route</span>.<span class="property">meta</span>.<span class="property">btnPermissions</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.$_has(btnPermissionsArr)) {</span><br><span class="line">            el.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(el);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"><span class="comment">// 权限检查方法</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$_has</span> = <span class="keyword">function</span> (<span class="params">value</span>) {</span><br><span class="line">    <span class="keyword">let</span> isExist = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 获取用户按钮权限</span></span><br><span class="line">    <span class="keyword">let</span> btnPermissionsStr = sessionStorage.<span class="title function_">getItem</span>(<span class="string">"btnPermissions"</span>);</span><br><span class="line">    <span class="keyword">if</span> (btnPermissionsStr == <span class="literal">undefined</span> || btnPermissionsStr == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="title function_">indexOf</span>(btnPermissionsStr) &gt; -<span class="number">1</span>) {</span><br><span class="line">        isExist = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> isExist;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">export</span> {has}</span><br></pre></td></tr></tbody></table></figure>

<p>在使用的按钮中只需要引用<code>v-has</code>指令</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;el-button @click=<span class="string">'editClick'</span> type=<span class="string">"primary"</span> v-has&gt;编辑&lt;/el-button&gt;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>关于权限如何选择哪种合适的方案，可以根据自己项目的方案项目，如考虑路由与菜单是否分离</p>
<p>权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/b-D2eH1mLwL_FkaZwjueSw">https://mp.weixin.qq.com/s/b-D2eH1mLwL_FkaZwjueSw</a></li>
<li><a href="https://segmentfault.com/a/1190000020887109">https://segmentfault.com/a/1190000020887109</a></li>
<li><a href="https://juejin.cn/post/6844903648057622536#heading-6">https://juejin.cn/post/6844903648057622536#heading-6</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title>vue生命周期</title>
    <url>/posts/21750.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue面试题"><a href="#vue面试题" class="headerlink" title="vue面试题"></a>vue面试题</h1><h2 id="面试官：请描述下你对vue生命周期的理解？在created和mounted这两个生命周期中请求数据有什么区别呢？"><a href="#面试官：请描述下你对vue生命周期的理解？在created和mounted这两个生命周期中请求数据有什么区别呢？" class="headerlink" title="面试官：请描述下你对vue生命周期的理解？在created和mounted这两个生命周期中请求数据有什么区别呢？"></a>面试官：请描述下你对vue生命周期的理解？在created和mounted这两个生命周期中请求数据有什么区别呢？</h2><img src="/posts/21750/21750/image-20221014073650919.png" class="" title="image-20221014073650919">

<h3 id="一、生命周期是什么"><a href="#一、生命周期是什么" class="headerlink" title="一、生命周期是什么"></a>一、生命周期是什么</h3><p>生命周期<code>（Life Cycle）</code>的概念应用很广泛，特别是在政治、经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为“从摇篮到坟墓”<code>（Cradle-to-Grave）</code>的整个过程在<code>Vue</code>中实例从创建到销毁的过程就是生命周期，即指从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程我们可以把组件比喻成工厂里面的一条流水线，每个工人（生命周期）站在各自的岗位，当任务流转到工人身边的时候，工人就开始工作PS：在<code>Vue</code>生命周期钩子会自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对 <code>property</code> 和方法进行运算这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)</p>
<span id="more"></span>

<h3 id="二、生命周期有哪些"><a href="#二、生命周期有哪些" class="headerlink" title="二、生命周期有哪些"></a>二、生命周期有哪些</h3><p>Vue生命周期总共可以分为8个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期</p>
<table>
<thead>
<tr>
<th align="left">生命周期</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">beforeCreate</td>
<td align="left">组件实例被创建之初</td>
</tr>
<tr>
<td align="left">created</td>
<td align="left">组件实例已经完全创建</td>
</tr>
<tr>
<td align="left">beforeMount</td>
<td align="left">组件挂载之前</td>
</tr>
<tr>
<td align="left">mounted</td>
<td align="left">组件挂载到实例上去之后</td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td align="left">组件数据发生变化，更新之前</td>
</tr>
<tr>
<td align="left">updated</td>
<td align="left">组件数据更新之后</td>
</tr>
<tr>
<td align="left">beforeDestroy</td>
<td align="left">组件实例销毁之前</td>
</tr>
<tr>
<td align="left">destroyed</td>
<td align="left">组件实例销毁之后</td>
</tr>
<tr>
<td align="left">activated</td>
<td align="left">keep-alive 缓存的组件激活时</td>
</tr>
<tr>
<td align="left">deactivated</td>
<td align="left">keep-alive 缓存的组件停用时调用</td>
</tr>
<tr>
<td align="left">errorCaptured</td>
<td align="left">捕获一个来自子孙组件的错误时被调用</td>
</tr>
</tbody></table>
<h3 id="三、生命周期整体流程"><a href="#三、生命周期整体流程" class="headerlink" title="三、生命周期整体流程"></a>三、生命周期整体流程</h3><h4 id="Vue生命周期流程图"><a href="#Vue生命周期流程图" class="headerlink" title="Vue生命周期流程图"></a><code>Vue</code>生命周期流程图</h4><img src="/posts/21750/21750/image-20221014073826997.png" class="" title="image-20221014073826997">

<h4 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h4><p><strong>beforeCreate -&gt; created</strong></p>
<ul>
<li>初始化<code>vue</code>实例，进行数据观测</li>
</ul>
<p><strong>created</strong></p>
<ul>
<li>完成数据观测，属性与方法的运算，<code>watch</code>、<code>event</code>事件回调的配置</li>
<li>可调用<code>methods</code>中的方法，访问和修改data数据触发响应式渲染<code>dom</code>，可通过<code>computed</code>和<code>watch</code>完成数据计算</li>
<li>此时<code>vm.$el</code> 并没有被创建</li>
</ul>
<p><strong>created -&gt; beforeMount</strong></p>
<ul>
<li>判断是否存在<code>el</code>选项，若不存在则停止编译，直到调用<code>vm.$mount(el)</code>才会继续编译</li>
<li>优先级：<code>render</code> &gt; <code>template</code> &gt; <code>outerHTML</code></li>
<li><code>vm.el</code>获取到的是挂载<code>DOM</code>的</li>
</ul>
<p><strong>beforeMount</strong></p>
<ul>
<li>在此阶段可获取到<code>vm.el</code></li>
<li>此阶段<code>vm.el</code>虽已完成DOM初始化，但并未挂载在<code>el</code>选项上</li>
</ul>
<p><strong>beforeMount -&gt; mounted</strong></p>
<ul>
<li>此阶段<code>vm.el</code>完成挂载，<code>vm.$el</code>生成的<code>DOM</code>替换了<code>el</code>选项所对应的<code>DOM</code></li>
</ul>
<p><strong>mounted</strong></p>
<ul>
<li><code>vm.el</code>已完成<code>DOM</code>的挂载与渲染，此刻打印<code>vm.$el</code>，发现之前的挂载点及内容已被替换成新的DOM</li>
</ul>
<p><strong>beforeUpdate</strong></p>
<ul>
<li>更新的数据必须是被渲染在模板上的（<code>el</code>、<code>template</code>、<code>render</code>之一）</li>
<li>此时<code>view</code>层还未更新</li>
<li>若在<code>beforeUpdate</code>中再次修改数据，不会再次触发更新方法</li>
</ul>
<p><strong>updated</strong></p>
<ul>
<li>完成<code>view</code>层的更新</li>
<li>若在<code>updated</code>中再次修改数据，会再次触发更新方法（<code>beforeUpdate</code>、<code>updated</code>）</li>
</ul>
<p><strong>beforeDestroy</strong></p>
<ul>
<li>实例被销毁前调用，此时实例属性与方法仍可访问</li>
</ul>
<p><strong>destroyed</strong></p>
<ul>
<li>完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器</li>
<li>并不能清除DOM，仅仅销毁实例</li>
</ul>
<h4 id="使用场景分析"><a href="#使用场景分析" class="headerlink" title="使用场景分析"></a><strong>使用场景分析</strong></h4><table>
<thead>
<tr>
<th align="left">生命周期</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">beforeCreate</td>
<td align="left">执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</td>
</tr>
<tr>
<td align="left">created</td>
<td align="left">组件初始化完毕，各种数据可以使用，常用于异步数据获取</td>
</tr>
<tr>
<td align="left">beforeMount</td>
<td align="left">未执行渲染、更新，dom未创建</td>
</tr>
<tr>
<td align="left">mounted</td>
<td align="left">初始化结束，dom已创建，可用于获取访问数据和dom元素</td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td align="left">更新前，可用于获取更新前各种状态</td>
</tr>
<tr>
<td align="left">updated</td>
<td align="left">更新后，所有状态已是最新</td>
</tr>
<tr>
<td align="left">beforeDestroy</td>
<td align="left">销毁前，可用于一些定时器或订阅的取消</td>
</tr>
<tr>
<td align="left">destroyed</td>
<td align="left">组件已销毁，作用同上</td>
</tr>
</tbody></table>
<h3 id="四、题外话：数据请求在created和mouted的区别"><a href="#四、题外话：数据请求在created和mouted的区别" class="headerlink" title="四、题外话：数据请求在created和mouted的区别"></a>四、题外话：数据请求在created和mouted的区别</h3><p><code>created</code>是在组件实例一旦创建完成的时候立刻调用，这时候页面<code>dom</code>节点并未生成；<code>mounted</code>是在页面<code>dom</code>节点渲染完毕之后就立刻执行的。触发时机上<code>created</code>是比<code>mounted</code>要更早的，两者的相同点：都能拿到实例对象的属性和方法。 讨论这个问题本质就是触发的时机，放在<code>mounted</code>中的请求有可能导致页面闪动（因为此时页面<code>dom</code>结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在<code>created</code>生命周期当中。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://juejin.cn/post/6844903811094413320">https://juejin.cn/post/6844903811094413320</a></li>
<li><a href="https://baike.baidu.com/">https://baike.baidu.com/</a></li>
<li><a href="http://cn.vuejs.org/">http://cn.vuejs.org/</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue生命周期的理解</tag>
      </tags>
  </entry>
  <entry>
    <title>vue的data添加一个新的属性时会发生什么？</title>
    <url>/posts/61087.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue的data添加一个新的属性时会发生什么？"><a href="#vue的data添加一个新的属性时会发生什么？" class="headerlink" title="vue的data添加一个新的属性时会发生什么？"></a>vue的data添加一个新的属性时会发生什么？</h1><h2 id="面试官：动态给vue的data添加一个新的属性时会发生什么？怎样解决？"><a href="#面试官：动态给vue的data添加一个新的属性时会发生什么？怎样解决？" class="headerlink" title="面试官：动态给vue的data添加一个新的属性时会发生什么？怎样解决？"></a>面试官：动态给vue的data添加一个新的属性时会发生什么？怎样解决？</h2><img src="/posts/61087/61087/image-20221018063416070.png" class="" title="image-20221018063416070">

<h3 id="一、直接添加属性的问题"><a href="#一、直接添加属性的问题" class="headerlink" title="一、直接添加属性的问题"></a>一、直接添加属性的问题</h3><p>我们从一个例子开始</p>
<p>定义一个<code>p</code>标签，通过<code>v-for</code>指令进行遍历</p>
<p>然后给<code>botton</code>标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也新增一行</p>
<span id="more"></span>

<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"(value,key) in item"</span> <span class="attr">:key</span>=<span class="string">"key"</span>&gt;</span></span><br><span class="line">    {{ value }}</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"addProperty"</span>&gt;</span>动态添加新属性<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>实例化一个<code>vue</code>实例，定义<code>data</code>属性和<code>methods</code>方法</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>({</span><br><span class="line">    <span class="attr">el</span>:<span class="string">"#app"</span>,</span><br><span class="line">   	<span class="attr">data</span>:<span class="function">()=&gt;</span>{</span><br><span class="line">       	<span class="attr">item</span>:{</span><br><span class="line">            <span class="attr">oldProperty</span>:<span class="string">"旧属性"</span></span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">methods</span>:{</span><br><span class="line">        <span class="title function_">addProperty</span>(<span class="params"></span>){</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">newProperty</span> = <span class="string">"新属性"</span>  <span class="comment">// 为items添加新属性</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">items</span>)  <span class="comment">// 输出带有newProperty的items</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>点击按钮，发现结果不及预期，数据虽然更新了（<code>console</code>打印出了新属性），但页面并没有更新</p>
<h3 id="二、原理分析"><a href="#二、原理分析" class="headerlink" title="二、原理分析"></a>二、原理分析</h3><p>为什么产生上面的情况呢？</p>
<p>下面来分析一下</p>
<p><code>vue2</code>是用过<code>Object.defineProperty</code>实现数据响应式</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = {}</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">'foo'</span>, {</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get foo:<span class="subst">${val}</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        },</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) {</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) {</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`set foo:<span class="subst">${newVal}</span>`</span>);</span><br><span class="line">                val = newVal</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当我们访问<code>foo</code>属性或者设置<code>foo</code>值的时候都能够触发<code>setter</code>与<code>getter</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">obj.<span class="property">foo</span>   </span><br><span class="line">obj.<span class="property">foo</span> = <span class="string">'new'</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是我们为<code>obj</code>添加新属性的时候，却无法触发事件属性的拦截</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">obj.<span class="property">bar</span>  = <span class="string">'新属性'</span></span><br></pre></td></tr></tbody></table></figure>

<p>原因是一开始<code>obj</code>的<code>foo</code>属性被设成了响应式数据，而<code>bar</code>是后面新增的属性，并没有通过<code>Object.defineProperty</code>设置成响应式数据</p>
<h3 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h3><p><code>Vue</code> 不允许在已经创建的实例上动态添加新的响应式属性</p>
<p>若想实现数据与视图同步更新，可采取下面三种解决方案：</p>
<ul>
<li>Vue.set()</li>
<li>Object.assign()</li>
<li>$forcecUpdated()</li>
</ul>
<h4 id="Vue-set"><a href="#Vue-set" class="headerlink" title="Vue.set()"></a>Vue.set()</h4><p>Vue.set( target, propertyName/index, value )</p>
<p>参数</p>
<ul>
<li><code>{Object | Array} target</code></li>
<li><code>{string | number} propertyName/index</code></li>
<li><code>{any} value</code></li>
</ul>
<p>返回值：设置的值</p>
<p>通过<code>Vue.set</code>向响应式对象中添加一个<code>property</code>，并确保这个新 <code>property</code>同样是响应式的，且触发视图更新</p>
<p>关于<code>Vue.set</code>源码（省略了很多与本节不相关的代码）</p>
<p>源码位置：<code>src\core\observer\index.js</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">set</span> (<span class="attr">target</span>: <span class="title class_">Array</span>&lt;any&gt; | <span class="title class_">Object</span>, <span class="attr">key</span>: any, <span class="attr">val</span>: any): any {</span><br><span class="line">  ...</span><br><span class="line">  <span class="title function_">defineReactive</span>(ob.<span class="property">value</span>, key, val)</span><br><span class="line">  ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里无非再次调用<code>defineReactive</code>方法，实现新增属性的响应式</p>
<p>关于<code>defineReactive</code>方法，内部还是通过<code>Object.defineProperty</code>实现属性拦截</p>
<p>大致代码如下：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) {</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, {</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) {</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">${key}</span>:<span class="subst">${val}</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        },</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) {</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) {</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`set <span class="subst">${key}</span>:<span class="subst">${newVal}</span>`</span>);</span><br><span class="line">                val = newVal</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p>直接使用<code>Object.assign()</code>添加到对象的新属性不会触发更新</p>
<p>应创建一个新的对象，合并原对象和混入对象的属性</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">someObject</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>({},<span class="variable language_">this</span>.<span class="property">someObject</span>,{<span class="attr">newProperty1</span>:<span class="number">1</span>,<span class="attr">newProperty2</span>:<span class="number">2</span> ...})</span><br></pre></td></tr></tbody></table></figure>

<h4 id="forceUpdate"><a href="#forceUpdate" class="headerlink" title="$forceUpdate"></a>$forceUpdate</h4><p>如果你发现你自己需要在 <code>Vue</code>中做一次强制更新，99.9% 的情况，是你在某个地方做错了事</p>
<p><code>$forceUpdate</code>迫使<code>Vue</code> 实例重新渲染</p>
<p>PS：仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>如果为对象添加少量的新属性，可以直接采用<code>Vue.set()</code></li>
<li>如果需要为新对象添加大量的新属性，则通过<code>Object.assign()</code>创建新对象</li>
<li>如果你实在不知道怎么操作时，可采取<code>$forceUpdate()</code>进行强制刷新 (不建议)</li>
</ul>
<p>PS：<code>vue3</code>是用过<code>proxy</code>实现数据响应式的，直接动态添加新属性仍可以实现数据响应式</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://cn.vuejs.org/v2/api/#Vue-set">https://cn.vuejs.org/v2/api/#Vue-set</a></li>
<li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue_data</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件之间的通信方式有哪些？</title>
    <url>/posts/50684.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue组件之间的通信方式有哪些？"><a href="#vue组件之间的通信方式有哪些？" class="headerlink" title="vue组件之间的通信方式有哪些？"></a>vue组件之间的通信方式有哪些？</h1><h2 id="面试官：Vue组件之间的通信方式都有哪些？"><a href="#面试官：Vue组件之间的通信方式都有哪些？" class="headerlink" title="面试官：Vue组件之间的通信方式都有哪些？"></a>面试官：Vue组件之间的通信方式都有哪些？</h2><img src="/posts/50684/50684/image-20221020135724159.png" class="" title="image-20221020135724159">

<h3 id="一、组件间通信的概念"><a href="#一、组件间通信的概念" class="headerlink" title="一、组件间通信的概念"></a>一、组件间通信的概念</h3><p>开始之前，我们把<strong>组件间通信</strong>这个词进行拆分</p>
<ul>
<li>组件</li>
<li>通信</li>
</ul>
<span id="more"></span>

<p>都知道组件是<code>vue</code>最强大的功能之一，<code>vue</code>中每一个<code>.vue</code>我们都可以视之为一个组件通信指的是发送者通过某种媒体以某种格式来传递信息到收信者以达到某个目的。广义上，任何信息的交通都是通信<strong>组件间通信</strong>即指组件(<code>.vue</code>)通过某种方式来传递信息以达到某个目的举个栗子我们在使用<code>UI</code>框架中的<code>table</code>组件，可能会往<code>table</code>组件中传入某些数据，这个本质就形成了组件之间的通信</p>
<h3 id="二、组件间通信解决了什么"><a href="#二、组件间通信解决了什么" class="headerlink" title="二、组件间通信解决了什么"></a>二、组件间通信解决了什么</h3><p>在古代，人们通过驿站、飞鸽传书、烽火报警、符号、语言、眼神、触碰等方式进行信息传递，到了今天，随着科技水平的飞速发展，通信基本完全利用有线或无线电完成，相继出现了有线电话、固定电话、无线电话、手机、互联网甚至视频电话等各种通信方式从上面这段话，我们可以看到通信的本质是信息同步，共享回到<code>vue</code>中，每个组件之间的都有独自的作用域，组件间的数据是无法共享的但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统</p>
<h3 id="三、组件间通信的分类"><a href="#三、组件间通信的分类" class="headerlink" title="三、组件间通信的分类"></a>三、组件间通信的分类</h3><p>组件间通信的分类可以分成以下</p>
<ul>
<li>父子组件之间的通信</li>
<li>兄弟组件之间的通信</li>
<li>祖孙与后代组件之间的通信</li>
<li>非关系组件间之间的通信</li>
</ul>
<p>关系图:</p>
<img src="/posts/50684/50684/image-20221020135747171.png" class="" title="image-20221020135747171">

<h3 id="四、组件间通信的方案"><a href="#四、组件间通信的方案" class="headerlink" title="四、组件间通信的方案"></a>四、组件间通信的方案</h3><p>整理<code>vue</code>中8种常规的通信方案</p>
<ol>
<li>通过 props 传递</li>
<li>通过 $emit 触发自定义事件</li>
<li>使用 ref</li>
<li>EventBus</li>
<li>$parent 或$root</li>
<li>attrs 与 listeners</li>
<li>Provide 与 Inject</li>
<li>Vuex</li>
</ol>
<h4 id="props传递数据"><a href="#props传递数据" class="headerlink" title="props传递数据"></a>props传递数据</h4><img src="/posts/50684/50684/image-20221020135804121.png" class="" title="image-20221020135804121">

<ul>
<li>适用场景：父组件传递数据给子组件</li>
<li>子组件设置<code>props</code>属性，定义接收父组件传递过来的参数</li>
<li>父组件在使用子组件标签中通过字面量来传递值</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Children</span>.<span class="property">vue</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">props</span>:{  </span><br><span class="line">    <span class="comment">// 字符串形式  </span></span><br><span class="line"> <span class="attr">name</span>:<span class="title class_">String</span> <span class="comment">// 接收的类型参数  </span></span><br><span class="line">    <span class="comment">// 对象形式  </span></span><br><span class="line">    <span class="attr">age</span>:{    </span><br><span class="line">        <span class="attr">type</span>:<span class="title class_">Number</span>, <span class="comment">// 接收的类型为数值  </span></span><br><span class="line">        <span class="attr">defaule</span>:<span class="number">18</span>,  <span class="comment">// 默认值为18  </span></span><br><span class="line">       <span class="attr">require</span>:<span class="literal">true</span> <span class="comment">// age属性必须传递  </span></span><br><span class="line">    }  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<p><code>Father.vue</code>组件</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Children</span> name=<span class="string">"jack"</span> age=<span class="number">18</span> /&gt; </span><br></pre></td></tr></tbody></table></figure>

<h4 id="emit-触发自定义事件"><a href="#emit-触发自定义事件" class="headerlink" title="$emit 触发自定义事件"></a>$emit 触发自定义事件</h4><ul>
<li>适用场景：子组件传递数据给父组件</li>
<li>子组件通过<code>$emit触发</code>自定义事件，<code>$emit</code>第二个参数为传递的数值</li>
<li>父组件绑定监听器获取到子组件传递过来的参数</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Chilfen.vue</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">'add'</span>, good) </span><br></pre></td></tr></tbody></table></figure>

<p>Father.vue</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Children</span> @add=<span class="string">"cartAdd($event)"</span> /&gt;  </span><br></pre></td></tr></tbody></table></figure>

<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><ul>
<li>父组件在使用子组件的时候设置<code>ref</code></li>
<li>父组件通过设置子组件<code>ref</code>来获取数据</li>
</ul>
<p>父组件：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Children</span> ref=<span class="string">"foo"</span> /&gt;  </span><br><span class="line">  </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">foo</span>  <span class="comment">// 获取子组件实例，通过子组件实例我们就能拿到对应的数据 </span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h4><ul>
<li>使用场景：兄弟组件传值</li>
<li>创建一个中央事件总线<code>EventBus</code></li>
<li>兄弟组件通过<code>$emit</code>触发自定义事件，<code>$emit</code>第二个参数为传递的数值</li>
<li>另一个兄弟组件通过<code>$on</code>监听自定义事件</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Bus.js</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个中央时间总线类  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> {  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) {  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span> = {};   <span class="comment">// 存放事件的名字  </span></span><br><span class="line">  }  </span><br><span class="line">  $on(name, fn) {  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span>[name] = <span class="variable language_">this</span>.<span class="property">callbacks</span>[name] || [];  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span>[name].<span class="title function_">push</span>(fn);  </span><br><span class="line">  }  </span><br><span class="line">  $emit(name, args) {  </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">callbacks</span>[name]) {  </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>[name].<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> <span class="title function_">cb</span>(args));  </span><br><span class="line">    }  </span><br><span class="line">  }  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// main.js  </span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="keyword">new</span> <span class="title class_">Bus</span>() <span class="comment">// 将$bus挂载到vue实例的原型上  </span></span><br><span class="line"><span class="comment">// 另一种方式  </span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>() <span class="comment">// Vue已经实现了Bus的功能  </span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Children1.vue</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$emit(<span class="string">'foo'</span>)  </span><br></pre></td></tr></tbody></table></figure>

<p>Children2.vue</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">'foo'</span>, <span class="variable language_">this</span>.<span class="property">handle</span>) </span><br></pre></td></tr></tbody></table></figure>

<h4 id="parent-或-root"><a href="#parent-或-root" class="headerlink" title="$parent 或$ root"></a>$parent 或$ root</h4><ul>
<li>通过共同祖辈<code>$parent</code>或者<code>$root</code>搭建通信桥连</li>
</ul>
<p>兄弟组件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">this.$parent.on('add',this.add)</span><br></pre></td></tr></tbody></table></figure>

<p>另一个兄弟组件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">this.$parent.emit('add')</span><br></pre></td></tr></tbody></table></figure>

<h4 id="attrs-与-listeners"><a href="#attrs-与-listeners" class="headerlink" title="$attrs 与$ listeners"></a>$attrs 与$ listeners</h4><ul>
<li>适用场景：祖先传递数据给子孙</li>
<li>设置批量向下传属性<code>$attrs</code>和 <code>$listeners</code></li>
<li>包含了父级作用域中不作为 <code>prop</code> 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。</li>
<li>可以通过 <code>v-bind="$attrs"</code> 传⼊内部组件</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// child：并未在props中声明foo  </span></span><br><span class="line">&lt;p&gt;{{$attrs.<span class="property">foo</span>}}&lt;/p&gt;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// parent  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">foo</span>=<span class="string">"foo"</span>/&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 给Grandson隔代传值，communication/index.vue  </span></span><br><span class="line">&lt;<span class="title class_">Child2</span> msg=<span class="string">"lalala"</span> @some-event=<span class="string">"onSomeEvent"</span>&gt;&lt;/<span class="title class_">Child2</span>&gt;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Child2做展开  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Grandson</span> <span class="attr">v-bind</span>=<span class="string">"$attrs"</span> <span class="attr">v-on</span>=<span class="string">"$listeners"</span>&gt;</span><span class="tag">&lt;/<span class="name">Grandson</span>&gt;</span></span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Grandson使⽤  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"$emit('some-event', 'msg from grandson')"</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">{{msg}}  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br></pre></td></tr></tbody></table></figure>

<h4 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h4><ul>
<li>在祖先组件定义<code>provide</code>属性，返回传递的值</li>
<li>在后代组件通过<code>inject</code>接收组件传递过来的值</li>
</ul>
<p>祖先组件</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="params"></span>){  </span><br><span class="line">    <span class="keyword">return</span> {  </span><br><span class="line">        <span class="attr">foo</span>:<span class="string">'foo'</span>  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<p>后代组件</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">inject</span>:[<span class="string">'foo'</span>] <span class="comment">// 获取到祖先组件传递过来的值</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a><code>vuex</code></h4><ul>
<li>适用场景: 复杂关系的组件数据传递</li>
<li><code>Vuex</code>作用相当于一个用来存储共享变量的容器</li>
</ul>
<img src="/posts/50684/50684/image-20221020140206505.png" class="" title="image-20221020140206505">

<ul>
<li><code>state</code>用来存放共享变量的地方</li>
<li><code>getter</code>，可以增加一个<code>getter</code>派生状态，(相当于<code>store</code>中的计算属性），用来获得共享变量的值</li>
<li><code>mutations</code>用来存放修改<code>state</code>的方法。</li>
<li><code>actions</code>也是用来存放修改state的方法，不过<code>action</code>是在<code>mutations</code>的基础上进行。常用来做一些异步操作</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>父子关系的组件数据传递选择 <code>props</code> 与 <code>$emit</code>进行传递，也可选择<code>ref</code></li>
<li>兄弟关系的组件数据传递可选择<code>$bus</code>，其次可以选择<code>$parent</code>进行传递</li>
<li>祖先与后代组件数据传递可选择<code>attrs</code>与<code>listeners</code>或者 <code>Provide</code>与 <code>Inject</code></li>
<li>复杂关系的组件数据传递可以通过<code>vuex</code>存放共享的变量</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://juejin.cn/post/6844903990052782094#heading-0">https://juejin.cn/post/6844903990052782094#heading-0</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1">https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1</a></li>
<li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue组件之间的通信方式</tag>
      </tags>
  </entry>
  <entry>
    <title>vue解决跨域问题</title>
    <url>/posts/46596.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue解决跨域问题"><a href="#vue解决跨域问题" class="headerlink" title="vue解决跨域问题"></a>vue解决跨域问题</h1><h2 id="面试官：Vue项目中你是如何解决跨域的呢？"><a href="#面试官：Vue项目中你是如何解决跨域的呢？" class="headerlink" title="面试官：Vue项目中你是如何解决跨域的呢？"></a>面试官：Vue项目中你是如何解决跨域的呢？</h2><img src="/posts/46596/46596/image-20221108073907500.png" class="" title="image-20221108073907500">

<h3 id="一、跨域是什么"><a href="#一、跨域是什么" class="headerlink" title="一、跨域是什么"></a>一、跨域是什么</h3><p>跨域本质是浏览器基于<strong>同源策略</strong>的一种安全手段</p>
<p>同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能</p>
<p>所谓同源（即指在同一个域）具有以下三个相同点</p>
<ul>
<li>协议相同（protocol）</li>
<li>主机相同（host）</li>
<li>端口相同（port）</li>
</ul>
<p>反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域</p>
<span id="more"></span>

<blockquote>
<p>一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。</p>
</blockquote>
<h3 id="二、如何解决"><a href="#二、如何解决" class="headerlink" title="二、如何解决"></a>二、如何解决</h3><p>解决跨域的方法有很多，下面列举了三种：</p>
<ul>
<li>JSONP</li>
<li>CORS</li>
<li>Proxy</li>
</ul>
<p>而在<code>vue</code>项目中，我们主要针对<code>CORS</code>或<code>Proxy</code>这两种方案进行展开</p>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应</p>
<p><code>CORS</code> 实现起来非常方便，只需要增加一些 <code>HTTP</code> 头，让服务器能声明允许的访问来源</p>
<p>只要后端实现了 <code>CORS</code>，就实现了跨域</p>
<img src="/posts/46596/46596/image-20221108073930764.png" class="" title="image-20221108073930764">

<p>以<code>koa</code>框架举例</p>
<p>添加中间件，直接设置<code>Access-Control-Allow-Origin</code>响应头</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next)=&gt; {</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'</span>);</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT, POST, GET, DELETE, OPTIONS'</span>);</span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="property">method</span> == <span class="string">'OPTIONS'</span>) {</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="number">200</span>; </span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>ps: <code>Access-Control-Allow-Origin</code> 设置为*其实意义不大，可以说是形同虚设，实际应用中，上线前我们会将<code>Access-Control-Allow-Origin</code> 值设为我们目标<code>host</code></p>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>代理（Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击</p>
<p><strong>方案一</strong></p>
<p>如果是通过<code>vue-cli</code>脚手架工具搭建项目，我们可以通过<code>webpack</code>为我们起一个本地服务器作为请求的代理对象</p>
<p>通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果web应用和接口服务器不在一起仍会跨域</p>
<p>在<code>vue.config.js</code>文件，新增以下代码</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">amodule.<span class="property">exports</span> = {</span><br><span class="line">    <span class="attr">devServer</span>: {</span><br><span class="line">        <span class="attr">host</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8084</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>,<span class="comment">// vue项目启动时自动打开浏览器</span></span><br><span class="line">        <span class="attr">proxy</span>: {</span><br><span class="line">            <span class="string">'/api'</span>: { <span class="comment">// '/api'是代理标识，用于告诉node，url前面是/api的就是使用代理的</span></span><br><span class="line">                <span class="attr">target</span>: <span class="string">"http://xxx.xxx.xx.xx:8080"</span>, <span class="comment">//目标地址，一般是指后台服务器地址</span></span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//是否跨域</span></span><br><span class="line">                <span class="attr">pathRewrite</span>: { <span class="comment">// pathRewrite 的作用是把实际Request Url中的'/api'用""代替</span></span><br><span class="line">                    <span class="string">'^/api'</span>: <span class="string">""</span> </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过<code>axios</code>发送请求中，配置请求的根路径</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">'/api'</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>方案二</strong></p>
<p>此外，还可通过服务端实现代理请求转发</p>
<p>以<code>express</code>框架为例</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(__dirname + <span class="string">'/'</span>))</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">'/api'</span>, <span class="title function_">proxy</span>({ <span class="attr">target</span>: <span class="string">'http://localhost:4000'</span>, <span class="attr">changeOrigin</span>: <span class="literal">false</span></span><br><span class="line">                      }));</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = app</span><br></pre></td></tr></tbody></table></figure>

<p><strong>方案三</strong></p>
<p>通过配置<code>nginx</code>实现代理</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">server {</span><br><span class="line">    listen    <span class="number">80</span>;</span><br><span class="line">    # server_name www.<span class="property">josephxia</span>.<span class="property">com</span>;</span><br><span class="line">    location / {</span><br><span class="line">        root  /<span class="keyword">var</span>/www/html;</span><br><span class="line">        index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">        try_files $uri $uri/ /index.<span class="property">html</span>;</span><br><span class="line">    }</span><br><span class="line">    location /api {</span><br><span class="line">        proxy_pass  <span class="attr">http</span>:<span class="comment">//127.0.0.1:3000;</span></span><br><span class="line">        proxy_redirect   off;</span><br><span class="line">        proxy_set_header  <span class="title class_">Host</span>       $host;</span><br><span class="line">        proxy_set_header  X-<span class="title class_">Real</span>-<span class="variable constant_">IP</span>     $remote_addr;</span><br><span class="line">        proxy_set_header  X-<span class="title class_">Forwarded</span>-<span class="title class_">For</span>  $proxy_add_x_forwarded_for;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue解决跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>vue项目部署到服务器</title>
    <url>/posts/3757.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue项目部署到服务器"><a href="#vue项目部署到服务器" class="headerlink" title="vue项目部署到服务器"></a>vue项目部署到服务器</h1><h1 id="面试官：vue项目本地开发完成后部署到服务器后报404是什么原因呢？"><a href="#面试官：vue项目本地开发完成后部署到服务器后报404是什么原因呢？" class="headerlink" title="面试官：vue项目本地开发完成后部署到服务器后报404是什么原因呢？"></a>面试官：vue项目本地开发完成后部署到服务器后报404是什么原因呢？</h1><img src="/posts/3757/3757/image-20221109073917506.png" class="" title="image-20221109073917506">

<h2 id="一、如何部署"><a href="#一、如何部署" class="headerlink" title="一、如何部署"></a>一、如何部署</h2><p>前后端分离开发模式下，前后端是独立布署的，前端只需要将最后的构建物上传至目标服务器的<code>web</code>容器指定的静态目录下即可</p>
<span id="more"></span>

<p>我们知道<code>vue</code>项目在构建后，是生成一系列的静态文件</p>
<p>常规布署我们只需要将这个目录上传至目标服务器即可</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">// scp 上传 user为主机登录用户，host为主机外网ip, xx为web容器静态资源路径</span><br><span class="line">scp dist.zip user@host:/xx/xx/xx</span><br></pre></td></tr></tbody></table></figure>

<p>让<code>web</code>容器跑起来，以<code>nginx</code>为例</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">server {</span><br><span class="line">  listen  80;</span><br><span class="line">  server_name  www.xxx.com;</span><br><span class="line"></span><br><span class="line">  location / {</span><br><span class="line">    index  /data/dist/index.html;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>配置完成记得重启<code>nginx</code></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">// 检查配置是否正确</span><br><span class="line">nginx -t </span><br><span class="line"></span><br><span class="line">// 平滑重启</span><br><span class="line">nginx -s reload</span><br></pre></td></tr></tbody></table></figure>

<p>操作完后就可以在浏览器输入域名进行访问了</p>
<p>当然上面只是提到最简单也是最直接的一种布署方式</p>
<p>什么自动化，镜像，容器，流水线布署，本质也是将这套逻辑抽象，隔离，用程序来代替重复性的劳动，本文不展开</p>
<h2 id="二、404问题"><a href="#二、404问题" class="headerlink" title="二、404问题"></a>二、404问题</h2><p>这是一个经典的问题，相信很多同学都有遇到过，那么你知道其真正的原因吗？</p>
<p>我们先还原一下场景：</p>
<ul>
<li><code>vue</code>项目在本地时运行正常，但部署到服务器中，刷新页面，出现了404错误</li>
</ul>
<p>先定位一下，HTTP 404 错误意味着链接指向的资源不存在</p>
<p>问题在于为什么不存在？且为什么只有<code>history</code>模式下会出现这个问题？</p>
<h3 id="为什么history模式下有问题"><a href="#为什么history模式下有问题" class="headerlink" title="为什么history模式下有问题"></a>为什么history模式下有问题</h3><p><code>Vue</code>是属于单页应用（single-page application）</p>
<p>而<code>SPA</code>是一种网络应用程序或网站的模型，所有用户交互是通过动态重写当前页面，前面我们也看到了，不管我们应用有多少页面，构建物都只会产出一个<code>index.html</code></p>
<p>现在，我们回头来看一下我们的<code>nginx</code>配置</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">server {</span><br><span class="line">  listen  <span class="number">80</span>;</span><br><span class="line">  server_name  www.<span class="property">xxx</span>.<span class="property">com</span>;</span><br><span class="line"></span><br><span class="line">  location / {</span><br><span class="line">    index  /data/dist/index.<span class="property">html</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以根据 <code>nginx</code> 配置得出，当我们在地址栏输入 <code>www.xxx.com</code> 时，这时会打开我们 <code>dist</code> 目录下的 <code>index.html</code> 文件，然后我们在跳转路由进入到 <code>www.xxx.com/login</code></p>
<p>关键在这里，当我们在 <code>website.com/login</code> 页执行刷新操作，<code>nginx location</code> 是没有相关配置的，所以就会出现 404 的情况</p>
<h3 id="为什么hash模式下没有问题"><a href="#为什么hash模式下没有问题" class="headerlink" title="为什么hash模式下没有问题"></a>为什么hash模式下没有问题</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">router hash` 模式我们都知道是用符号#表示的，如 `website.com/#/login`, `hash` 的值为 `#/login</span><br></pre></td></tr></tbody></table></figure>

<p>它的特点在于：<code>hash</code> 虽然出现在 <code>URL</code> 中，但不会被包括在 <code>HTTP</code> 请求中，对服务端完全没有影响，因此改变 <code>hash</code> 不会重新加载页面</p>
<p><code>hash</code> 模式下，仅 <code>hash</code> 符号之前的内容会被包含在请求中，如 <code>website.com/#/login</code> 只有 <code>website.com</code> 会被包含在请求中 ，因此对于服务端来说，即使没有配置<code>location</code>，也不会返回404错误</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>看到这里我相信大部分同学都能想到怎么解决问题了，</p>
<p>产生问题的本质是因为我们的路由是通过JS来执行视图切换的，</p>
<p>当我们进入到子路由时刷新页面，<code>web</code>容器没有相对应的页面此时会出现404</p>
<p>所以我们只需要配置将任意页面都重定向到 <code>index.html</code>，把路由交由前端处理</p>
<p>对<code>nginx</code>配置文件<code>.conf</code>修改，添加<code>try_files $uri $uri/ /index.html;</code></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">server {</span><br><span class="line">  listen  80;</span><br><span class="line">  server_name  www.xxx.com;</span><br><span class="line"></span><br><span class="line">  location / {</span><br><span class="line">    index  /data/dist/index.html;</span><br><span class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>修改完配置文件后记得配置的更新</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></tbody></table></figure>

<p>这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 <code>index.html</code> 文件</p>
<p>为了避免这种情况，你应该在 <code>Vue</code> 应用里面覆盖所有的路由情况，然后在给出一个 404 页面</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>({</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">'history'</span>,</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    { <span class="attr">path</span>: <span class="string">'*'</span>, <span class="attr">component</span>: <span class="title class_">NotFoundComponent</span> }</span><br><span class="line">  ]</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>关于后端配置方案还有：<code>Apache</code>、<code>nodejs</code>等，思想是一致的，这里就不展开述说了</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://juejin.cn/post/6844903872637632525">https://juejin.cn/post/6844903872637632525</a></li>
<li><a href="https://vue-js.com/topic/5f8cf91d96b2cb0032c385c0%E3%80%81">https://vue-js.com/topic/5f8cf91d96b2cb0032c385c0、</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title>vue项目错误处理</title>
    <url>/posts/49172.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue项目错误处理"><a href="#vue项目错误处理" class="headerlink" title="vue项目错误处理"></a>vue项目错误处理</h1><h2 id="面试官：你是怎么处理vue项目中的错误的？"><a href="#面试官：你是怎么处理vue项目中的错误的？" class="headerlink" title="面试官：你是怎么处理vue项目中的错误的？"></a>面试官：你是怎么处理vue项目中的错误的？</h2><img src="/posts/49172/49172/image-20221110063943106.png" class="" title="image-20221110063943106">

<h3 id="一、错误类型"><a href="#一、错误类型" class="headerlink" title="一、错误类型"></a>一、错误类型</h3><p>任何一个框架，对于错误的处理都是一种必备的能力</p>
<p>在<code>Vue</code> 中，则是定义了一套对应的错误处理规则给到使用者，且在源代码级别，对部分必要的过程做了一定的错误处理。</p>
<span id="more"></span>

<p>主要的错误来源包括：</p>
<ul>
<li>后端接口错误</li>
<li>代码中本身逻辑错误</li>
</ul>
<h3 id="二、如何处理"><a href="#二、如何处理" class="headerlink" title="二、如何处理"></a>二、如何处理</h3><h4 id="后端接口错误"><a href="#后端接口错误" class="headerlink" title="后端接口错误"></a>后端接口错误</h4><p>通过<code>axios</code>的<code>interceptor</code>实现网络请求的<code>response</code>先进行一层拦截</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">apiClient.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">response</span> =&gt;</span> {</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  },</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> {</span><br><span class="line">    <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">status</span> == <span class="number">401</span>) {</span><br><span class="line">      router.<span class="title function_">push</span>({ <span class="attr">name</span>: <span class="string">"Login"</span> });</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      message.<span class="title function_">error</span>(<span class="string">"出错了"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="代码逻辑问题"><a href="#代码逻辑问题" class="headerlink" title="代码逻辑问题"></a>代码逻辑问题</h4><h5 id="全局设置错误处理"><a href="#全局设置错误处理" class="headerlink" title="全局设置错误处理"></a>全局设置错误处理</h5><p>设置全局错误处理函数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">errorHandler</span> = <span class="keyword">function</span> (<span class="params">err, vm, info</span>) {</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">  <span class="comment">// `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子</span></span><br><span class="line">  <span class="comment">// 只在 2.2.0+ 可用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>errorHandler</code>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 <code>Vue</code> 实例</p>
<p>不过值得注意的是，在不同<code>Vue</code> 版本中，该全局 <code>API</code> 作用的范围会有所不同：</p>
<blockquote>
<p>从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 <code>undefined</code> 时，被捕获的错误会通过 <code>console.error</code> 输出而避免应用崩</p>
</blockquote>
<blockquote>
<p>从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了</p>
</blockquote>
<blockquote>
<p>从 2.6.0 起，这个钩子也会捕获 <code>v-on</code> DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理</p>
</blockquote>
<h5 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h5><p><code>errorCaptured</code>是 2.5.0 新增的一个生命钩子函数，当捕获到一个来自子孙组件的错误时被调用</p>
<p>基本类型</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="attr">err</span>: <span class="title class_">Error</span>, <span class="attr">vm</span>: <span class="title class_">Component</span>, <span class="attr">info</span>: string) =&gt; ?boolean</span><br></pre></td></tr></tbody></table></figure>

<p>此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播</p>
<p>参考官网，错误传播规则如下：</p>
<ul>
<li>默认情况下，如果全局的 <code>config.errorHandler</code> 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报</li>
<li>如果一个组件的继承或父级从属链路中存在多个 <code>errorCaptured</code> 钩子，则它们将会被相同的错误逐个唤起。</li>
<li>如果此 <code>errorCaptured</code> 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 <code>config.errorHandler</code></li>
<li>一个 <code>errorCaptured</code> 钩子能够返回 <code>false</code> 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 <code>errorCaptured</code> 钩子和全局的 <code>config.errorHandler</code></li>
</ul>
<p>下面来看个例子</p>
<p>定义一个父组件<code>cat</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">'cat'</span>, {</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">			&lt;h1&gt;Cat: &lt;/h1&gt;</span></span><br><span class="line"><span class="string">        	&lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span>,</span><br><span class="line">    <span class="attr">props</span>:{</span><br><span class="line">        <span class="attr">name</span>:{</span><br><span class="line">            <span class="attr">required</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="attr">type</span>:<span class="title class_">String</span></span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">    <span class="title function_">errorCaptured</span>(<span class="params">err,vm,info</span>) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`cat EC: <span class="subst">${err.toString()}</span>\ninfo: <span class="subst">${info}</span>`</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>定义一个子组件<code>kitten</code>，其中<code>dontexist()</code>并没有定义，存在错误</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">'kitten'</span>, {</span><br><span class="line">    <span class="attr">template</span>:<span class="string">'&lt;div&gt;&lt;h1&gt;Kitten: {{ dontexist() }}&lt;/h1&gt;&lt;/div&gt;'</span>,</span><br><span class="line">    <span class="attr">props</span>:{</span><br><span class="line">        <span class="attr">name</span>:{</span><br><span class="line">            <span class="attr">required</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="attr">type</span>:<span class="title class_">String</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>页面中使用组件</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cat</span> <span class="attr">name</span>=<span class="string">"my cat"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">kitten</span>&gt;</span><span class="tag">&lt;/<span class="name">kitten</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>在父组件的<code>errorCaptured</code>则能够捕获到信息</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">cat <span class="attr">EC</span>: <span class="title class_">TypeError</span>: dontexist is not a <span class="keyword">function</span></span><br><span class="line"><span class="attr">info</span>: render</span><br></pre></td></tr></tbody></table></figure>

<h3 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h3><p>异常处理源码</p>
<p>源码位置：/src/core/util/error.js</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 全局配置,也就是上面的Vue.config</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></span><br><span class="line"><span class="keyword">import</span> { warn } <span class="keyword">from</span> <span class="string">'./debug'</span></span><br><span class="line"><span class="comment">// 判断环境</span></span><br><span class="line"><span class="keyword">import</span> { inBrowser, inWeex } <span class="keyword">from</span> <span class="string">'./env'</span></span><br><span class="line"><span class="comment">// 判断是否是Promise，通过val.then === 'function' &amp;&amp; val.catch === 'function', val ！=== null &amp;&amp; val !== undefined</span></span><br><span class="line"><span class="keyword">import</span> { isPromise } <span class="keyword">from</span> <span class="string">'shared/util'</span></span><br><span class="line"><span class="comment">// 当错误函数处理错误时，停用deps跟踪以避免可能出现的infinite rendering</span></span><br><span class="line"><span class="comment">// 解决以下出现的问题https://github.com/vuejs/vuex/issues/1505的问题</span></span><br><span class="line"><span class="keyword">import</span> { pushTarget, popTarget } <span class="keyword">from</span> <span class="string">'../observer/dep'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">handleError</span> (<span class="attr">err</span>: <span class="title class_">Error</span>, <span class="attr">vm</span>: any, <span class="attr">info</span>: string) {</span><br><span class="line">    <span class="comment">// Deactivate deps tracking while processing error handler to avoid possible infinite rendering.</span></span><br><span class="line">    <span class="title function_">pushTarget</span>()</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// vm指当前报错的组件实例</span></span><br><span class="line">        <span class="keyword">if</span> (vm) {</span><br><span class="line">            <span class="keyword">let</span> cur = vm</span><br><span class="line">            <span class="comment">// 首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用errorCaptured 方法。</span></span><br><span class="line">            <span class="comment">// 在遍历调用完所有 errorCaptured 方法、或 errorCaptured 方法有报错时，调用 globalHandleError 方法</span></span><br><span class="line">            <span class="keyword">while</span> ((cur = cur.<span class="property">$parent</span>)) {</span><br><span class="line">                <span class="keyword">const</span> hooks = cur.<span class="property">$options</span>.<span class="property">errorCaptured</span></span><br><span class="line">                <span class="comment">// 判断是否存在errorCaptured钩子函数</span></span><br><span class="line">                <span class="keyword">if</span> (hooks) {</span><br><span class="line">                    <span class="comment">// 选项合并的策略，钩子函数会被保存在一个数组中</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hooks.<span class="property">length</span>; i++) {</span><br><span class="line">                        <span class="comment">// 如果errorCaptured 钩子执行自身抛出了错误，</span></span><br><span class="line">                        <span class="comment">// 则用try{}catch{}捕获错误，将这个新错误和原本被捕获的错误都会发送给全局的config.errorHandler</span></span><br><span class="line">                        <span class="comment">// 调用globalHandleError方法</span></span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            <span class="comment">// 当前errorCaptured执行，根据返回是否是false值</span></span><br><span class="line">                            <span class="comment">// 是false，capture = true，阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler</span></span><br><span class="line">                            <span class="comment">// 是true capture = fale，组件的继承或父级从属链路中存在的多个 errorCaptured 钩子，会被相同的错误逐个唤起</span></span><br><span class="line">                            <span class="comment">// 调用对应的钩子函数，处理错误</span></span><br><span class="line">                            <span class="keyword">const</span> capture = hooks[i].<span class="title function_">call</span>(cur, err, vm, info) === <span class="literal">false</span></span><br><span class="line">                            <span class="keyword">if</span> (capture) <span class="keyword">return</span></span><br><span class="line">                        } <span class="keyword">catch</span> (e) {</span><br><span class="line">                            <span class="title function_">globalHandleError</span>(e, cur, <span class="string">'errorCaptured hook'</span>)</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 除非禁止错误向上传播，否则都会调用全局的错误处理函数</span></span><br><span class="line">        <span class="title function_">globalHandleError</span>(err, vm, info)</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="title function_">popTarget</span>()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 异步错误处理函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">invokeWithErrorHandling</span> (</span><br><span class="line"><span class="attr">handler</span>: <span class="title class_">Function</span>,</span><br><span class="line"> <span class="attr">context</span>: any,</span><br><span class="line"> <span class="attr">args</span>: <span class="literal">null</span> | any[],</span><br><span class="line">    <span class="attr">vm</span>: any,</span><br><span class="line">        <span class="attr">info</span>: string</span><br><span class="line">        ) {</span><br><span class="line">            <span class="keyword">let</span> res</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 根据参数选择不同的handle执行方式</span></span><br><span class="line">                res = args ? handler.<span class="title function_">apply</span>(context, args) : handler.<span class="title function_">call</span>(context)</span><br><span class="line">                <span class="comment">// handle返回结果存在</span></span><br><span class="line">                <span class="comment">// res._isVue an flag to avoid this being observed，如果传入值的_isVue为ture时(即传入的值是Vue实例本身)不会新建observer实例</span></span><br><span class="line">                <span class="comment">// isPromise(res) 判断val.then === 'function' &amp;&amp; val.catch === 'function', val ！=== null &amp;&amp; val !== undefined</span></span><br><span class="line">                <span class="comment">// !res._handled  _handle是Promise 实例的内部变量之一，默认是false，代表onFulfilled,onRejected是否被处理</span></span><br><span class="line">                <span class="keyword">if</span> (res &amp;&amp; !res.<span class="property">_isVue</span> &amp;&amp; <span class="title function_">isPromise</span>(res) &amp;&amp; !res.<span class="property">_handled</span>) {</span><br><span class="line">                    res.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">handleError</span>(e, vm, info + <span class="string">` (Promise/async)`</span>))</span><br><span class="line">                    <span class="comment">// avoid catch triggering multiple times when nested calls</span></span><br><span class="line">                    <span class="comment">// 避免嵌套调用时catch多次的触发</span></span><br><span class="line">                    res.<span class="property">_handled</span> = <span class="literal">true</span></span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (e) {</span><br><span class="line">                <span class="comment">// 处理执行错误</span></span><br><span class="line">                <span class="title function_">handleError</span>(e, vm, info)</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局错误处理</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">globalHandleError</span> (err, vm, info) {</span><br><span class="line">    <span class="comment">// 获取全局配置，判断是否设置处理函数，默认undefined</span></span><br><span class="line">    <span class="comment">// 已配置</span></span><br><span class="line">    <span class="keyword">if</span> (config.<span class="property">errorHandler</span>) {</span><br><span class="line">        <span class="comment">// try{}catch{} 住全局错误处理函数</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 执行设置的全局错误处理函数，handle error 想干啥就干啥💗</span></span><br><span class="line">            <span class="keyword">return</span> config.<span class="property">errorHandler</span>.<span class="title function_">call</span>(<span class="literal">null</span>, err, vm, info)</span><br><span class="line">        } <span class="keyword">catch</span> (e) {</span><br><span class="line">            <span class="comment">// 如果开发者在errorHandler函数中手动抛出同样错误信息throw err</span></span><br><span class="line">            <span class="comment">// 判断err信息是否相等，避免log两次</span></span><br><span class="line">            <span class="comment">// 如果抛出新的错误信息throw err Error('你好毒')，将会一起log输出</span></span><br><span class="line">            <span class="keyword">if</span> (e !== err) {</span><br><span class="line">                <span class="title function_">logError</span>(e, <span class="literal">null</span>, <span class="string">'config.errorHandler'</span>)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 未配置常规log输出</span></span><br><span class="line">    <span class="title function_">logError</span>(err, vm, info)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误输出函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logError</span> (err, vm, info) {</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span>) {</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`Error in <span class="subst">${info}</span>: "<span class="subst">${err.toString()}</span>"`</span>, vm)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> ((inBrowser || inWeex) &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">console</span> !== <span class="string">'undefined'</span>) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><code>handleError</code>在需要捕获异常的地方调用，首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用<code>errorCaptured</code> 方法，在遍历调用完所有 <code>errorCaptured</code> 方法或 <code>errorCaptured</code> 方法有报错时，调用 <code>globalHandleError</code> 方法</li>
<li><code>globalHandleError</code>调用全局的 <code>errorHandler</code> 方法，再通过<code>logError</code>判断环境输出错误信息</li>
<li><code>invokeWithErrorHandling</code>更好的处理异步错误信息</li>
<li><code>logError</code>判断环境，选择不同的抛错方式。非生产环境下，调用<code>warn</code>方法处理错误</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://juejin.cn/post/6844904096936230925">https://juejin.cn/post/6844904096936230925</a></li>
<li><a href="https://segmentfault.com/a/1190000018606181">https://segmentfault.com/a/1190000018606181</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue项目错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title>《三体》读后感</title>
    <url>/posts/7f6f288a.html</url>
    <content><![CDATA[<html><head></head><body><p>三体是一部非常棒的科幻作品</p>
<img src="/posts/7f6f288a/7f6f288a/image-20221227115151308.png" class="" title="image-20221227115151308">

<p>关于三体，不同的人也有自己最喜欢的角色。我本人最喜欢的角色就是章北海。</p>
<span id="more"></span>

<p>那些出自章北海的脍炙人口的句子当然也是被粉丝们津津乐道， 比如：</p>
<p>那以前， 要多想</p>
<p>自然选择， 前进四！！！</p>
<p>没关系的， 都一样</p>
<p>北海最终的归宿就是星辰大海。 一个很悲壮的故事。</p>
<p>之前大刘的粉丝就问了他自己一个问题：”你的三体为什么会这么火？“</p>
<p>大刘回答道：“我也不知道， 就连出版社也不知道”</p>
<p>个人对三体火起来的一个看法：</p>
<p>它集合了中国的上下五千年历史、世界史、物理学、星际学、生物学、天文学、纳米科学、人工智能、航天、宇宙探索、人类社会学等各类学科的科幻大作！</p>
<p>接着就是再三体中提到的一些哲学问题： </p>
<p>1、讽刺寡头资本家和政府的剥削（掩体世界固化的阶层，紧张的房地产和百姓苟且的生活），讽刺政治为大的社会环境！</p>
<p>2、大道至简：一副清明上河图和一片蓝天背后所蕴藏的细节哪个多？</p>
<p>3、人性本恶！</p>
<p>4、降维打击：高维打击低维是很容易的事情，但是永远也根除不了消灭不完低维的东西。</p>
<p>三体中一些奇妙的科幻点子：</p>
<p>1、 智子</p>
<p>2、 面壁计划和破壁计划（面壁人和破壁人）</p>
<p>3、 黑暗森林法则（我敢打赌，只要看过三体， 就永远不会忘记黑暗森林法则， 除非失忆）</p>
<p>4、 执剑人</p>
<p>5、 云天明的三个故事</p>
<p>6、 降维打击（这个科幻点子就像是外星人指点的）</p>
<p>7、 高等文明（三体， 歌者， 归零者（重启宇宙））</p>
<p>三体确实是一部旷世神作，以至于我身边的朋友， 读过它都表示相见恨晚， 想起了高中上晚自习，我和一个朋友毫无学习的兴趣， 就在那里讨论三体。</p>
<p>三体之后， 再无科幻小说；就像是金庸老先生去世后， 我再也没有看过其他的武侠小说。</p>
<p>三体给我的一种感觉是： 自己再思考的时候就会换一个维度， 从宇宙的角度来看待问题， 黑暗森林法则适用于人与人之间， 国家与国家之间， 文明与文明之间。</p>
<p>里面罗辑的好莱坞风格的救世，章北海中式风格的长征精神， 维德的功利主义形象， 为达目的不择手段；大史干练的警察形象；前三位面壁者失败后的表情，人类命运一波三折的思想观念的一些转变。 让我们觉得生活中的这些事都不算是事， 跟浩瀚的宇宙比起来， 我们就是蚂蚁</p>
<p>十年可知旦夕祸福， 百年可知生老病死， 千年可叹王朝更替，万年可见斗转星移。这短短的几十年，我们应该怎么去活下去？</p>
<p>找到自己喜爱的人， 喜爱的事。努力的活完自己短暂的一生， 然后把成果留给下一代去共享。书中说三体人的思维是透明的， 这是它们科技繁荣的一个重要的原因，由于人类还没有进化出这种功能， 但是互联网中的开源精神，也是被大肆赞扬的。</p>
<p>人类和三体人比， 最弱的一点就是人性，人性是一个沼泽，越挣扎陷得越深。道德和法律限制我们自己的行为， 在黑暗战役中， 北海说过一句话， 新的道德和文明正在形成。我们古代的荀子也是认为， 人性向恶，需要以严刑峻法束之。中国上下五千年， 哪一代人不向往一个和谐，安定的社会？</p>
<p>我们智人能统治世界的一个重要原因就是发生了认知革命， 人类是团结的， 如果几个人相互矛盾， 他们在面对共同的敌人的时候， 这几个人会摒弃前嫌， 然后团结起来。 就像是在抗日战争时期， 共产党和国民党会团结起来， 共同地去对抗他们的敌人。</p>
<p>三体给我的一个影响就是要多去观察和思考。 比如对于一个普通人，就是被苹果砸死， 他也不会去思考为什么苹果会掉下来；也绝对不会去思考周围空气是我们生存的必要。</p>
<p>天行有常， 不为尧存， 不为桀亡。人类在自然面前还是太渺小了， 一个病毒折腾了世界三年了， 人类还是没有办法，地球少了谁都是会自己围绕着太阳转下去。</p>
<p>一些三体的书迷听过三体要拍影视剧， 又开始玩梗， 不要拍摄， 不要拍摄， 不要拍摄。这么好的作品真的是想象力界的珠穆朗玛峰。这些书迷不想看到自己的信仰被影视剧毁于一旦， 所以就想着阻止人家去拍摄， 大刘也说了， 现在的科技估计拍不出感觉</p>
<p>一个日本人在看完三体后， 把三本书按照顺序放在前面， 直接下跪， 表示对此书的至高无上的敬意。 真的就差磕头了， 日本人的这种文化， 比如你去商场买鞋， 会有服务员小姐姐跪着给你换鞋并服务的很到位， 这种文化我们值不值得学习？这真的是客户至上的感觉， 这种感觉在中国是体验不到的， 比如你下榻一个酒店， 那些服务员就以貌取人， 如果你打扮的不怎么样？话里话外一种冷嘲热讽， 对你爱答不理的样子。没有办法 ， 中国的环境就造成了现在的这种情况， 前几天还和朋友讨论现在彩礼的情况， 彩礼从古代到现在的性质全部变了， 本来给女方的东西， 现在这传统却是给了女方的父母，确实是令人难受啊，扯远了。</p>
<p>最后：生存是社会的第一法则，也是人生的第一法则</p>
</body></html>]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>《三体》读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>《云边有个小卖部》读后感</title>
    <url>/posts/17659.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="《云边有个小卖部》读后感"><a href="#《云边有个小卖部》读后感" class="headerlink" title="《云边有个小卖部》读后感"></a>《云边有个小卖部》读后感</h1><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">有些人刻骨铭心，没几年会遗忘。</span><br><span class="line">有些人不论生死，都陪在身旁。</span><br><span class="line">——张嘉佳《云边有个小卖部》</span><br></pre></td></tr></tbody></table></figure>

<p><strong>讲故事的人，总有一个故事不愿讲。</strong></p>
<p>这是一个关于云边小镇名叫刘十三少年的成长故事，一个关于梦想与遗憾、软弱与勇敢、遇见与错过的故事。</p>
<p>故事横跨他人生中的十五年，平平凡凡的刘十三每每遇到人生中的不可抗力，都会在脑海中回忆起自己的家乡——云边小镇.</p>
<p>这个平凡而普通的男孩，在外婆的呵护下长大。</p>
<span id="more"></span>

<p>背井离乡，他失恋又失业，在城市中跌跌撞撞地生活，甚至偶尔狼狈不堪。</p>
<p>那些温暖如刻在记忆胶片上的家乡画面：外婆院子里的小卖部、漫天飞舞的蒲公英和盛开的石榴树、清澈见底的河水…… 成为他挣扎着生存中最美好的治愈。</p>
<p>疲惫不堪、伤痕累累的刘十三，终于被外婆拽回家乡，同年少时的朋友、小女孩重逢，却观尽人间百态。</p>
<img src="/posts/17659/17659/image-20221009161638088.png" class="" title="image-20221009161638088">

<p><strong>山的这边是刘十三的童年， 山那边是外婆的海</strong></p>
<h2 id="02-1"><a href="#02-1" class="headerlink" title="02"></a>02</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">生命是有光的。</span><br><span class="line">在我熄灭以前，能够照亮你一点，就是我所有能做的了。</span><br><span class="line">我爱你，你要记得我。</span><br></pre></td></tr></tbody></table></figure>

<p>欢笑和感动，希望和悲伤。</p>
<p>张嘉佳笔下的每一个故事，温暖而柔软，仿佛驻足在时光的背后，赚足了读者的眼泪。</p>
<p>他的文字，好似夏日的风，清凉中夹杂着苦涩；又如同一枚催泪弹，不自觉的在某一刻，让阅读者还未察觉就泪流满面。</p>
<p>云边镇每一个普普通通的人物身上，都闪烁着平凡而动人的爱的光芒。</p>
<p>程霜、球球、王莹莹，性格迥异的三代人，她们每一个人身上，都有着难以诉说的苦楚和经历。然而每一个人，却勇敢而阳光的活着，带着对生命和生活傻傻的期待，带着对未来的憧憬和孤注一掷的希望。</p>
<p>如张嘉佳所说，<strong>悲伤和希望，都是一缕光。</strong>悲喜交加，才是生活本来的面目。那些曾以为撑不下去的时光，咬牙再坚持一下，终有一天你会发现，原来自己已经走过这么长的路，熬过这么多孤立无援的日子。</p>
<p><strong>生命是有光的。</strong></p>
<img src="/posts/17659/17659/image-20221009161959329.png" class="" title="image-20221009161959329">

<p><strong>这是最动人的夏夜，</strong> <strong>谁也不想说话</strong></p>
<h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">人和人之间舒服的关系，是可以一直不说话，也可以随时说话。</span><br></pre></td></tr></tbody></table></figure>

<p>每个人心中，都有一个“云边小镇”。</p>
<p>生活中有太多刘十三，故事千篇一律，结局却近乎相同。</p>
<p>生命有时，比想象中更加残忍。无论我们爱与不爱、无论有多少不舍与伤痛、无论在我们生命留下过怎样的足迹，每一个人，都会随着时光的流逝渐渐老去，会离开，回永别、再也不见。</p>
<p>那些曾在某一阶段或某一时刻照亮过生命轨迹的人，纵使不在身边，都会以各种各样的方式，浸润到我们的生命中去；总有一些念念不忘，以意想不到的方式，在心间回荡，不经意间掀起无数涟漪。</p>
<p>总有太多无奈的离开，连告别的机会都不曾有，每每回忆都勾起心中难以言说的酸楚。</p>
<img src="/posts/17659/17659/image-20221009162145962.png" class="" title="image-20221009162145962">

<p><strong>有些告别，就是最后一面</strong></p>
<h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">有朵盛开的云，</span><br><span class="line">缓缓滑过山顶，</span><br><span class="line">随风飘向天边，</span><br><span class="line">我们慢慢明白，</span><br><span class="line">有些告别，</span><br><span class="line">就是最后一面。</span><br></pre></td></tr></tbody></table></figure>

<p>十三，失散；程霜，成双。</p>
<p>两代人终归失散，一个人心念成双。</p>
<p>离去的人无法回来，而是活着的人不知该去往何方。</p>
<p>时光飞逝，悄悄话变成了纸张。</p>
<p>人们聚和离，云朵来又往。</p>
<img src="/posts/17659/17659/image-20221009162323262.png" class="" title="image-20221009162323262">

<p><strong>我爱你， 你要记得我</strong></p>
</body></html>]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>云边有个小卖部</tag>
      </tags>
  </entry>
  <entry>
    <title>《文城》-余华读后感</title>
    <url>/posts/28789.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="《文城》读后感"><a href="#《文城》读后感" class="headerlink" title="《文城》读后感"></a>《文城》读后感</h1><h2 id="“人生就是自己的往事和他人的序章”"><a href="#“人生就是自己的往事和他人的序章”" class="headerlink" title="“人生就是自己的往事和他人的序章”"></a>“人生就是自己的往事和他人的序章”</h2><h3 id="–大背景时代下的小人物"><a href="#–大背景时代下的小人物" class="headerlink" title="–大背景时代下的小人物"></a>–大背景时代下的小人物</h3><p>“文城在哪里？总有一个地方叫文城。”全文处处围绕着‘文城’在写，然而现实中并没有文城这个地方，‘文城’是阿强为了躲避林祥福随口说的谎言，然而却成了林祥福一生找寻的目标。文城是什么？文城真的存在吗？其实每个人心中都有自己的“文城”，只不过有人是用一生去寻找。有人说：“人世间最美好的爱情是一见钟情，而人世间最凄美的爱情也是一见钟情，因为它犹如烟花一样，瞬间辉煌，留下的多半是久久和惆怅和遗憾。</p>
<span id="more"></span>

<p>《文城》讲的是一个寻妻的故事，发生在清朝灭亡，民国初立时期。主人公林祥福与江南裁缝女季小美的相遇、相知及结合，然而，在小美诞下一女后，她悄然离去，自此，凭着小美‘哥哥’阿强口中的文城和小美与阿强对话的口音，林祥福带着女儿踏上了寻妻之路，最终在小美的家乡溪镇落脚，历经兵患匪乱，找寻爱人一生。</p>
<p>读到最后一章才发现，小美于十七年前死于冰冻，与丈夫阿强葬于西山，而林祥福最终死于土匪之手，魂归故里。书的结局是田氏兄弟带着林祥福的尸体经过西山，棺材板车短暂的停留在西山，林祥福的尸体放在棺材的左边，而左边的墓碑上小美的名字刻在了右边，棺材与墓碑的相遇是林祥福与小美的久别重逢，找寻了十七年，林祥福终于迎来了与小美的再次见面。</p>
<p>书中最让我深恶痛绝的是以张一斧为首的那群土匪，他们绑架平民百姓作为人质来换取钱财，他们在没有定期收到赎金时对人质施以暴行，用鞭子抽打，甚至割下了人质的耳朵。乱世之中还是有好人在的，并不是所有的土匪都那般可恶，与张一斧的残暴形成对比的是代号为和尚的土匪，他看不惯张一斧的残暴横行，最终与他成为对立面，最后也在战乱中死去。</p>
<p>书中让我触动的是，在那个离乱的年代，仍有忠义的存在。有忠心耿耿为林祥福守家的田氏五兄弟，到最后按照他的嘱托去接他回家；有当林祥福的女儿林百家被土匪绑架后，担心林百家被土匪欺辱而让大儿子去替代林百家的李美莲；有情同一家的好友陈永良，为给林祥福复仇组织民间武装对抗土匪并手刃张一斧；还有那许许多多在乱世中为守护家园而举刀的人们，忠义精神在那个年代被更加生动形象的展现出来。</p>
<p>或许有人会说：“这本书中有些描写过于残暴血腥，读者看了，可能会感到不适。”然而在我看来，历史和现实永远比文学真实和恐怖。</p>
</body></html>]]></content>
      <tags>
        <tag>名著《文城》读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>《程序员的自我修养》读后感</title>
    <url>/posts/39274.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="程序员的自我修养"><a href="#程序员的自我修养" class="headerlink" title="程序员的自我修养"></a>程序员的自我修养</h1><p>国庆期间， 读了这本《程序员的自我修养》，学到了很多东西， 下面分享给大家。</p>
<h2 id="享受职业素养"><a href="#享受职业素养" class="headerlink" title="享受职业素养"></a>享受职业素养</h2><p>​        我在招聘时常问的一个问题是：在你过去的工作中，遭遇过哪些印象深刻的困难，最后是怎么解决的？依我的经验，简历写得再漂亮的人，如果这个问题答不好，大都可以直接忽略。为什么会有这种结论？因为我们需要招聘的不是“经历丰富”的人，而是“有职业素养的人”。你遇到的问题可能很容易也可能很难，但我看重的并不是问题的难度，而是解决问题的方式、步骤以及反思的深度。拿恢复误删数据来说，这可能算非常简单的任务。我更感兴趣的是怎样分析问题，找了怎样的资料，采取了怎样的步骤，此后做了哪些措施来避免这种错误再次出现。在我看来，相比问题本身的难度，解决问题的方式和步骤以及反思的深度，都体现出一个人的职业素养。</p>
<span id="more"></span>

<p>​        该书中， 作者有一句原话：</p>
<p>​        <strong>所以，请你把这本书看成我的错误大全，它记录了我干过的所有蠢事；也请你把这本书当成一份指引，让它带你绕开我曾经走过的弯路。</strong></p>
<p>先看一个小故事：</p>
<img src="/posts/39274/39274/image-20221001180802613.png" class="" title="image-20221001180802613">

<p>​       1986 年 1 月 28 日，美国东部时间上午 11 : 39 , “挑战者”号航天飞机在发射仅 73 . 124 秒后，因右侧固体火箭推进器的故障，在 4 . 8 万英尺的高空化成碎片。七名航天勇士魂断苍穹，其中包括高中教师克丽斯塔 · 麦考利芙。麦考利芙的母亲亲眼目睹女儿在九英里高空中不幸遇难，彼时彼刻她脸上的表情，至今印刻在我的心头无法拂去。</p>
<p>​        挑战者号之所以解体，是由于高热气体从出现故障的固体火箭推进器的外壳接缝处泄露出来，喷到外部燃料舱体上。主液氢燃料舱底部发生爆炸，液氢被点燃，并将液氢燃料推人上方的液氧燃料舱中。与此同时，固体火箭推进器从下支架脱落，开始绕上支架滚动。推进器的机头捅破了液氧舱。整个飞行器因异常受力，逆向气流旋转，但同时仍然以 1 . 5 马赫的速度飞行。在巨大的过载下，挑战者号迅速被撕成碎片。</p>
<p>​       设计了推进器的莫顿 · 赛奥科公司的工程师事前已经知道密封圈有问题，并早在 7 年前就已经将这些问题报告给莫顿 · 赛奥科公司和美国宇航局的管理人员。事实上，在以前的发射中，密封圈就曾发生过类似的损坏，只是没有引发灾难而已。发射气温越低，后果就越严重。工程师们已经针对该问题设计了一个修复方案，但修复方案却迟迟未得以实施。</p>
<p>​       正是这个原因导致了悲剧的发生。</p>
<p>​      作为一个优秀的程序员应该有发现问题， 解决问题的能力。</p>
<h2 id="专业主义"><a href="#专业主义" class="headerlink" title="专业主义"></a>专业主义</h2><h3 id="1-清楚你要什么"><a href="#1-清楚你要什么" class="headerlink" title="1. 清楚你要什么"></a>1. 清楚你要什么</h3><p>​       “专业主义”有很深的含义，它不但象征着荣誉与骄傲，而且明确意味着责任与义务。这两者密切相关，因为从你无法负责的事情上不可能获得荣誉与骄傲。做个非专业人士可轻松多了。非专业人士不需要为自己所做的工作负责，他们大可把责任推给雇主。如果非专业人士把事情搞砸了，收拾摊子的往往是雇主；而专业人士如果犯了错，只好自己收拾残局。</p>
<p>​        如果你不小心放过了某个模块里的一个 bug ，以致公司损失了 l 万美元，结果将会怎样呢？非专业人士会耸耸肩说：“状况总是难免的嘛。”然后像没事儿人一样继续写下一个模块。而专业人士会自己为公司的那 1 万美元买单 </p>
<p>​        ！哇，自脚腰包？那可真让人心疼唉！但专业人士就必须这么做。实际上，专业主义的精髓就在于将公司利益视同个人利益。看到了吧，“专业主义”就意味着担当责任。</p>
<h3 id="2-担当责任"><a href="#2-担当责任" class="headerlink" title="2. 担当责任"></a>2. 担当责任</h3><p>​       作为程序员， 最常见的就是bug了，  故障排查非常困难，每次测试就要好几个小时。第一次修复失败了。第二次也没能成功。有时候试了好几次，等发现问题所在时，好几天已过去了。这期间， 如果每隔几小时就打电话问问题什么时候能解决，并一再告诉我让那些客户重新启用旧软件令他多么尴尬。最后，终于找出了缺陷所在，重新交付修复了问题的新程序，一切恢复正常。 老板也平静下来，不再提这段插曲，毕竟，他不是我的上司。事后，老板过来说：“你最好别再犯同样的错误。”我只能默默地点点头。经过反省，我意识到未对“例程”进行测试就交付软件是不负责任的。为了如期交付产品，忽略了测试环节，整个过程中只考虑要如何保全自己的颜面，却没顾及客户和雇主的声誉。本该早点儿担起责任，测试还未完成、自己不能按时交付产品。那么做绝非易事， 老板一定会不高兴，但客户不会丢失数据，客服经理也不会打电话来轰炸。</p>
<h3 id="3-了解你的领域"><a href="#3-了解你的领域" class="headerlink" title="3. 了解你的领域"></a>3. 了解你的领域</h3><p>比如作为一门前端工程师，就需要特别掌握自己需要的东西， 别想着样样精通， 这个世界是没有人都能样样精通的， 只能专注发展自己的领域， 这样才能收获自己想要的，所以就拿前端工程师来说：</p>
<ol>
<li><p>了解互联网产品开发相关流程和工作模式；</p>
</li>
<li><p>扎实的前端基础知识：HTML，CSS，JavaScript和jQuery；</p>
</li>
<li><p>了解和掌握HTTP协议，能从实际角度出发提升Web性能；</p>
</li>
<li><p>了解熟悉常见的前端框架、库、工具，例如：jQuery、AngularJS、vue.js、React、Grunt、Gulp 等</p>
</li>
<li><p>了解和使用过Node.js进行前端项目构建，熟悉Git</p>
<p>了解完这些后， 在这些基础上再进行深入学习，这样才会使你的技术进一步的更新</p>
<p><strong>再比如说你要优化你的项目， 想想该怎样优化：</strong></p>
<ol>
<li><p>尽量减少HTTP请求 (Make Fewer HTTP Requests)</p>
</li>
<li><p>减少DNS 查找 (Reduce DNS Lookups)</p>
</li>
<li><p>避免重定向 (Avoid Redirects)</p>
</li>
<li><p>使得 Ajax 可缓存 (Make Ajax Cacheable)</p>
</li>
<li><p>延迟载入组件 (Post-load Components)</p>
</li>
<li><p>预载入组件 (Preload Components)</p>
</li>
<li><p>减少DOM元素数量 (Reduce the Number of DOM Elements)</p>
</li>
<li><p>切分组件到多个域 (Split Components Across Domains)</p>
</li>
<li><p>最小化iframe的数量 (Minimize the Number of iframes)</p>
</li>
<li><p>杜绝 http404错误 (No 404s)</p>
</li>
</ol>
</li>
</ol>
<h3 id="4-坚持学习"><a href="#4-坚持学习" class="headerlink" title="4. 坚持学习"></a>4. 坚持学习</h3><p>​        软件行业的飞速改变，意味着软件开发人员必须坚持广泛学习才不至于落伍。不写代码的架构师必然遭殃，他们很快会发现自己跟不上时代了；不学习新语言的程序员同样会遭殃，他们只能眼睁睁看着软件业径直向前，把自己抛在后面；学不会新原则和技术的开发人员必将沦落，他们身边的人都日益卓越。你会找那些已经不看医学期刊的医生看病吗？你会聘请那些不了解最新税法和判例的税务律师吗？雇主们干嘛要聘用那些不能与时俱进的开发人员呢？</p>
<p>​        读书，看相关文章，关注博客和微博，参加技术大会，访问用户群，多参与读书与学习小组。如果你是． NET 程序员，就去学学 Java ; 如果你是 Java 程序员，就去学学 Ruby ；如果你是 C 语言程序员，就去学学 LisP ; 如果你真想练练脑子，就去学学 Prolog 和 Forth 吧！</p>
<h3 id="5-练习"><a href="#5-练习" class="headerlink" title="5. 练习"></a>5. 练习</h3><p>​        业精于勤。真正的专业人士往往勤学苦干，以求得自身技能的纯熟精炼。只完成日常工作是不足以称为练习的，那只能算是种执行性质的操作，而不是练习。练习，指的是在日常工作之中练习技能．以期自我提升。对软件开发人员来说，有什么可以用以操练的呢？乍一听，这概念显得荒唐。但是再仔细想一会儿，想想音乐家是如何掌握演练技能的。他们靠的不是表演，而是背后刻苦的练习</p>
<h3 id="6-合作"><a href="#6-合作" class="headerlink" title="6. 合作"></a>6. 合作</h3><p>​        学习的第二个最佳方法是与他人合作。专业软件开发人员往往会更加努力地尝试与他们一起编程、一起练习、一起设计、一起计划，这样他们可以从彼此身上学到很多东西，而且能在更短的时间内更高质量地完成更多工作。并不是让你花全部时间一直和别人共事。独处的时间也很重要。虽然我很喜欢和别人一起编程，但是如果不能经常独处，我也一样会发疯。</p>
<h3 id="7-辅导"><a href="#7-辅导" class="headerlink" title="7. 辅导"></a>7. 辅导</h3><p>​        俗话说：教学相长。想迅速牢固地掌握某些事实和观念，最好的方法就是与由你负责的人交流这些内容。这样，传道授业的同时．导师也会从中受益。</p>
<p>​        同样，让新人融入团队的最好专业众士会视辅导新人为己任．办法是和他们坐到一起，向他们传授工作要诀。他们不会放任未经辅导的新手乱打乱撞。</p>
<h3 id="8-了解业务领域"><a href="#8-了解业务领域" class="headerlink" title="8. 了解业务领域"></a>8. 了解业务领域</h3><p>​        每位专业软件开发人员都有义务了解自己开发的解决方案所对应的业务领域。如果编写财务系统，你就应该对财务领域有所了解；如果编写旅游应用程序，那么你需要了解旅游业。你未必需要成为该领域的专家，但你仍需要勤勉，付出相当的努力来认识业务领域。</p>
<p>​        开始一个新领域的项目时，应当读一两本该领域相关的书，要就该领域的基础架构与基本知识对客户和用户访谈，还应当花时间和业内专家交流，了解他们的原则与价值观念。</p>
<p>​        最糟糕、最不专业的做法是，简单按照规格说明来编写代码，但却对为什么那些业务需要那样的规格定义不求甚解。相反，你应该对这一领域有所了解，能辨别、质疑规格说明书中的错误。</p>
<h3 id="9-谦逊"><a href="#9-谦逊" class="headerlink" title="9. 谦逊"></a>9. 谦逊</h3><p>​        编程是一种创造性活动。写代码是无中生有的创造过程，我们大胆地从混沌之中创建秩序。我们自信地发布准确无误的指令，稍有差错，机器的错误行为就可能造成无法估量的损失。因此，编程也是极其自负的行为。专业人士知道自己自负，不会故作谦逊。他们熟知自己的工作，并引以为荣；</p>
<p>​        他们对自己的能力充满自信，并因此勇于承担有把握的风险。专业人士不是胆小鬼。然而，专业人士也知道自己会摔跟头，自己的风险评估也有出错的时候，自己也有力不从心的时候。</p>
<p>​        这时候，如果他们揽镜自照，会看到那个自负的傻瓜正对着自己笑。因此，在发现自己成为笑柄时，专业人士会第一个发笑。他从不会嘲讽别人，自作自受时他会接受别人的嘲讽。反之，他则会一笑了之。他不会因别人犯错就对之横加贬损，因为他知道，自己有可能就是下一个犯错的人。</p>
<p>​        专业人士都清楚自己的自负．也知道上天会注意到这种自负，并加以惩戒。如若果真遭遇挫折，上策就是一笑了之吧！</p>
<h2 id="说“不”"><a href="#说“不”" class="headerlink" title="说“不”"></a>说“不”</h2><p>引用尤达的一句名言：</p>
<p><strong>能就是能， 不能就是不能， 别说“试试看”            ———-尤达</strong></p>
<p>​        每位经理都承担着工作职责，绝大部分经理也知道该如何尽职尽责。其中一部分的工作职责，便是要竭尽所能追求和捍卫他们设定的目标。同样，程序员也自有其工作职责所在，绝大多数程序员也知道该如何写的尽职尽责。如果他们是专业程序员的话，他们也会竭尽所能地去追求和捍卫自舟的目标。</p>
<p>​        你的经理要求你在明天之前完成登录页面，这就是他在追求和捍卫的一个目标，那是尽他的工作职责。如果你明知第二天之前不可能完成登录页面，嘴上却说“好的，我会试试的”，那么便是你失职了。这时候．唯一的尽职方式便是说“不，这不可能”。可是难道你不该照经理说的话去做吗？当然不该，你的经理指望的是，你能像他那样竭尽所能地捍卫自己的目标。</p>
<p>​        这样你们俩才能得到可能的最好结果。可能的最好结果，是你和你的经理共同追求的目标。最关键的是要找到那个共同目标，而这往往有赖于协商。协商过程有时可以相当愉快。</p>
<p>​        但是到了第二天， 你的任务没有完成， 你的这句“我试试”就成了你的最大的败笔， 这也从侧面显示出你的不称职。 另外， 你觉得经理会怎样看待你， 会嫌你技术菜吗？当然， 万事皆有可能。</p>
<h2 id="说”是“"><a href="#说”是“" class="headerlink" title="说”是“"></a>说”是“</h2><p>​        很少有人会认真对待自己说的话，并且说到做到。有些人在说话时是认真的，但他从来都不会说到做到。而更多的人在做出承诺后，几乎从不会认真去履行诺言。是否听过有人经常说“天哪，我真该减减肥了”？但你知道其实他还会是老样子，什么改变都不会发生。这样的事确实屡见不鲜。为什么我们总会有种奇怪的感觉，觉得人们大多数时候并没有全力去兑现承诺呢？</p>
<p>​        更糟的是，我们常常会因为直觉摔跟头。有时我们轻信他人会说话算话说到做到，但事实上他并没有像承诺的那么去做。我们可能会相信某位开发人员所说的，他们能在一星期内完成原本两星期才能完成的任务，但其实他们是迫不得已才这么说的。我们不能轻易相信此类承诺。我们可以通过一些语言上的小花招，而非依靠直觉本能，来判断对方到底能不能“说话算话、说到做到”。同时，改变我们自己的说话方式和内容。当我承诺某事时，必须认真对待承诺。</p>
<h3 id="识别“缺乏承诺”的征兆"><a href="#识别“缺乏承诺”的征兆" class="headerlink" title="识别“缺乏承诺”的征兆"></a>识别“缺乏承诺”的征兆</h3><p>​        在承诺做某事时，应当留意自己的用词，因为这些用词透露了我们对待承诺的认真程度。实际情况当然不只是注意在我们所说的话中是否含有某几个词这么简单。但如果在其中找不到这几个神奇的词，很可能我们自己根本就没把承诺太当真，或者，这表明我们可能不相信这些词具备的功效。</p>
<p>​        以下示例中包含的几个用词和短语，会透露“缺乏承诺”的蛛丝马迹，要注意搜寻。</p>
<p>​        需要 l 应当。“我们要把这活做完。”“我需要减肥。”“有人应当负责去推动这件事。”</p>
<p>​        希望 l 但愿。“希望明天我能完成这个任务。”“希望改天我们能再见面。” ‘ ’但愿我有时间做这件事。”“但愿电脑能快点。</p>
<p>​        ”让我们（而不是“让我”）。“让我们回头再见。”“让我们把这事做完。</p>
<p>​        只要去搜寻你就会发现，在自己身边，此类词语比比皆是，甚至在你对别人说的话里也时常出现。</p>
<p>​        你会发现，我们有极力逃避承担责任的倾向。</p>
<p>​        如果你或者其他人工作的一部分依赖于那些承诺，那么大事不妙了。不过你已经迈开了第一步，开始能够在你周边的人（包括你自己）的话里捕获可能存在“缺乏承诺”的征兆了。</p>
<h2 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h2><h3 id="1-注意力"><a href="#1-注意力" class="headerlink" title="1. 注意力"></a>1. 注意力</h3><p>​        编程是需要持续投入精力和注意力的智力活动。注意力是稀缺的资源，它类似魔力点数．。如果你用光了自己的注意力点数，必须花一个小时或更多的时间做不需要注意力的事情，来补充它。</p>
<p>​        我不知道该怎么描述注意力点数，但是我感觉它是有形（或许无形）的，能影响注意力的集中和分散。无论如何，你肯定可以觉察到注意力点数的存在，也同样可以感知它是否耗尽。职业开发人员会学习安排时间，妥善使用自己的注意力点数。我们选择注愈力点数充裕的时候编程，在注意力点数缺乏时做其他事情。</p>
<p>​        注意力点数也会随时间流逝而减少。如果不及时使用，它就会消失。会议之所以具有巨大的破坏力，原因之一就在于此。如果你所有的注意力点数都用在了会议上，编程时就大脑空空了。</p>
<h3 id="2-咖啡因"><a href="#2-咖啡因" class="headerlink" title="2. 咖啡因"></a>2. 咖啡因</h3><p>​        毋庸置疑，对有些人来说，适量的咖啡因可以帮他们更有效地使用注意力点数。但是请小心，咖啡因也会给你的注意力添乱。太多咖啡因会把你的注意力偏转到奇怪的方向。太浓的咖啡会搞得你一整天都沉溺于不重要的事情。咖啡因的用量和接受程度因人而异。我个人的做法是，早上一杯浓咖啡，中午一杯无糖可乐。有时候会加倍．但通常这就是上限了。</p>
<h3 id="3-睡眠"><a href="#3-睡眠" class="headerlink" title="3. 睡眠"></a>3. 睡眠</h3><p>​        睡眠的重要性怎么强调都不为过。美美一觉醒来，我的注意力点数是最充裕的。好好睡上 7 个小时，我就有足够的注意力点数去做好 8 小时的工作。专业开发人员会安排好他们的睡眠，保证清晨有饱满的注意力点数去上班。</p>
<h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>​        我们并非是因为喜欢和人们在一起工作才选择做程序员的。人际关系一团糟，而且不可预见。编程用的机器则整洁，行为也可预见。如果可以一个人呆在房间里数个小时沉浸在一些真正有趣的问题里，那将会是最开心的时光。</p>
<p>​        好吧，我这么说可能有点儿以偏概全了，确实也有不少例外。有许多程序员很善于和别人共事合作，享受其中的挑战。但是整个群体的平均状况还是朝我所描述的方向发展的。我们，程序员们，还是最享受面无表情的沉思，把自己像蚕茧一样裹起来，沉浸于问题思考中。</p>
<p>​        专业程序员的首要职责是满足雇主的需求。这意味着要和你的经理们、业务分析师们、测试工程师们和其他团队成员很好地协作，深刻理解业务目标。这并不是说你必须要成为业务方面的老学究，而是说你需要理解手上正在编写的代码的业务价值是什么，了解雇你的企业将如何从你的工作中获得回报。</p>
<p>​        专业程序员最糟糕的表现是两耳不闻窗外事，只顾一头将自己埋在技术堆里，甚至连公司业务火烧眉毛臀崩溃了也不闻不问。你的工作职责就是要让业务免于陷入困顿，让公司可以长久发展下去。</p>
<p>​        因此，专业程序员会花时间去理解业务。他们会和用户讨论他们正在使用的软件，会和销售人员与市场人员讨论所遭遇的问题，会和经理们沟通，明确团队的短期目标和长期目标。简而言之，他们会将注意力放在如何与业务同舟共济上。</p>
<p>​        也许我们不是因为通过编程可以和人互相协作才选择从事这项工作的。但真不走运，编程就意味着与人协作。我们需要和业务人员一起工作，我们之间也需要互相合作。我知道，我知道。如果把我们关在一个有六个大屏幕显示器的房间里，里面有高速宽带网络，有一组超快的处理器并行队列，有用不尽的内存和磁盘，源源不断的健怡可乐和香脆的玉米薯条，”肠岂不是棒极了’唉，伙计，不是这样的。如果我们真想终生能以编程度日，那么，一定要学会交流 ― 和人们交流。</p>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>程序员的自我修养</tag>
      </tags>
  </entry>
  <entry>
    <title>《舆论》读后感</title>
    <url>/posts/bf436c73.html</url>
    <content><![CDATA[<html><head></head><body><p>这两天， 我的书友们，她们给我推荐了一本书， 这本书的名字就叫做《舆论》， 本来我抱着试一试的心态去尝试的读它， 但是自从看了这本书的简介， 我被深深地吸引了， 这本书确实是一本神作</p>
<p>在读这本书之前， 我也是像往常一样，先去看看这本书的口碑， 还有书友们对于这本书的评价， 值得一提的是：我的书友们都对这本书的评价非常高， 可以说是传播学的启蒙</p>
<span id="more"></span>

<p>刚开始， 我就被作者举得例子给深深地吸引了， 原来这个社会上的信息传播的方式还有这样一种情况吗？</p>
<p>这本书只能做简要的概括， 想只读一遍就发现其中的精髓真的是非常的困难， 于是我就在网上相应地搜索了一些书评， 今天我也就是斗胆稍稍地总结一下</p>
<p>本文书名叫“舆论”，但其实更多的偏向于个人想法的形成以及影响因素，以政治角度。</p>
<p><strong>第一章为导论</strong>，讲的是人的想法和现实的矛盾。</p>
<p><strong>第二章</strong>探讨了信息到人的过程中可能会受到何种的衰减。</p>
<p>首先，信息源会被审查，有些信息会被保密， 在有些国家就是这样的， 如果有一些不利于团结的东西是绝对不会被传播的</p>
<p>其次，人会处在不同的社交圈子中，而社交圈子会影响圈内人接收何种信息。</p>
<p>然后，不同人对于同一个信息源的注意力，用于分析的所用的时间和精力是不同的， 比如对于一个程序员， 在网上吃瓜也就是乐呵乐呵。 但是对于警察， 侦探， 记者等， 他们需要投入很大的精力处理这件事， 进而找到真相。</p>
<p>最后，人的理解力以及思考能力的本身也会受到不同因素的干扰。例如外界影响、习惯以及生活的影响，比如举一个浅显易懂的例子， 今天有一个热搜：“女司机逆行致使他人车祸”，这个时候的吃瓜网页就是言语攻击那个女司机， 《乌合之众》一书中也讲到了关于这方面的知识， 个体在群体之中会出现明显的降智。但是后来， 这件事发生了反转，真相变成了：“司机酒驾致使车祸”，大家又去言语攻击这个人了</p>
<p><strong>第三章</strong>讨论了刻板印象概念，产生原因（以及影响个人想法的方式。？）</p>
<p>刻板印象是一种填充物，被个体从不同事实中提取出来的事实的属性以及特质，用于填充其他的事实形象。如果要对抗刻板印象，需要时刻牢记个体对于世界万物来说是微不足道的，这样才能方便自己作出修正。</p>
<p>举一个简单的刻板印象的例子， 在外国人眼里， 中国的乒乓球是真正的厉害， 这就形成了一种刻板印象， 一个老外，只要见到一个中国人。就一定觉这个人的乒乓球打的特别的厉害， 然而事实上就是，这个人可能连乒乓球拍都没摸过。</p>
<p>刻板印象的产生原因：</p>
<p>首先，它是三观的基础，以某种印象阐释问题会让人感到舒适，让人有安全感。</p>
<p>其次，它是能够合理解释现实世界的问题。</p>
<p>然后，它能掩盖盲点，“消除”疑惑。（8-92）</p>
<p>最后，其存在具有合理性，能够降低人对于认知人性、社会以及历史的成本</p>
<p>然后本书以较大的篇幅探讨了如何发现刻板印象，最终这些刻板印象会导致绝对主义</p>
<ol>
<li>关注事物的矛盾之处</li>
<li>对空间概念的匮乏</li>
<li>对时间概念的匮乏：历史视角，社会领域视角，未来时间段</li>
<li>偶然性样本被用来代表整体情况</li>
</ol>
<p>文章也是提到了一个非常有趣的观点</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">对于现实注意以及浪漫主义的古老争论已经有了一个定论：现实的开端和美好的结尾是固定套路。</span><br><span class="line">人关于包括自身在内的一切事物的挂念都非与生俱来，而都是后天习得的（学校教育以及传统习惯设定）</span><br></pre></td></tr></tbody></table></figure>



<p>之后尝试解答了人如何理解世界这个问题：</p>
<ol>
<li>通过有权威的中介/专家来理解世界。</li>
<li>中介的权威性来自于等级制度，等级制度导致了下级对于上级的依附关系。</li>
<li>由于大众对于世界的理解处在空想的状态，需要有人来进行指引，所以出现了体制。</li>
<li>通过体制运作，才能让人群能作出实际的选择，而不被自己的个人利益所影响，丢失选择的机会。</li>
<li>最终结果是一小撮人代表大多数人作出了选择</li>
<li>选举的要素是将大众意见简单化处理，对于降低滥用权力没有帮助。</li>
</ol>
<p>对于体制以及良知不应该有半点依赖之念，体制为了维护稳定，必然会掩盖部分事实真相，所做的决定，往往对于弱者是残忍的，这种社会确实是最魔幻的</p>
<p>总体来说， 我认为这本书还是非常值得推荐的， 它会在一定程度上改善你的解决问题的方法和思路， 强烈安利给大家</p>
</body></html>]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>舆论</tag>
      </tags>
  </entry>
  <entry>
    <title>世界上最贵的bug</title>
    <url>/posts/58853.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="世界上最贵的bug"><a href="#世界上最贵的bug" class="headerlink" title="世界上最贵的bug"></a>世界上最贵的bug</h1><h2 id="一个价值8-7亿美元的bug"><a href="#一个价值8-7亿美元的bug" class="headerlink" title="一个价值8.7亿美元的bug"></a>一个价值8.7亿美元的bug</h2><img src="/posts/58853/58853/image-20221012160903562.png" class="" title="image-20221012160903562">

<p>一位资深程序员曾经说过:</p>
<p>没有经历过 P0级错误的职业生涯</p>
<span id="more"></span>

<p>上面这句话是我编的，但是作为一个程序员，bug 绝对不足为奇。</p>
<p>你的bug给公司造成了多大的损失？在这篇文章中，我们来看一个导致8.7亿美元损失的错误。</p>
<h3 id="整个事故"><a href="#整个事故" class="headerlink" title="整个事故:"></a>整个事故:</h3><p>1996年6月4日，第一枚阿丽亚娜5号火箭在法属圭亚那沿海发射。</p>
<p>这次发射耗资3.7亿美元，火箭搭载了一颗价值5亿美元的通信卫星，总投资为8.7亿美元。</p>
<img src="/posts/58853/58853/image-20221012161206893.png" class="" title="image-20221012161206893">

<p>起飞后37秒，火箭朝错误的方向转了90度，助推器在空中撕裂，飞船被一个巨大的液态氢火球吞没。</p>
<img src="/posts/58853/58853/image-20221012161237177.png" class="" title="image-20221012161237177">

<p>爆炸发生时，工程师甚至用法语报告说: “一切设置正常，轨道正常。”</p>
<p>主控室里威严的工程师和人群后面的骚动表明这一切发生得太突然了。</p>
<img src="/posts/58853/58853/image-20221012161335828.png" class="" title="image-20221012161335828">

<p>这场灾难性的事故引发了公众的调查，由于火箭携带的卫星受损，关于地球磁层运行的科学研究被推迟了近4年。</p>
<p>阿丽亚娜5号事故被广泛认为是最昂贵的历史bug之一。</p>
<img src="/posts/58853/58853/image-20221012161438048.png" class="" title="image-20221012161438048">

<h3 id="事故原因"><a href="#事故原因" class="headerlink" title="事故原因"></a>事故原因</h3><p>此事故的原因是浮点溢出。</p>
<p>用于应用的阿丽亚娜火箭包含一个决定火箭向上或向下的变量，称为水平偏差，以下简称为 BH。</p>
<p>在设计阿丽亚娜5号上一代火箭阿丽亚娜4号时，工程师分析了 BH 的边界条件，以确定哪一个永远不会超过16位整数表示范围(- 32768到32767) ，这个变量被定义为16位整数类型。</p>
<p>但是，由于阿丽亚娜5号火箭性能的改善，在大多数应用中，BH 被定义为64位浮点数，有些部分由于阿丽亚娜4号16位整数的疏忽仍在使用。</p>
<p>当这两部分代码组合使用时，它将尝试将一个64位浮点数赋给16位整数。</p>
<p>在火箭上升的头几秒钟，火箭的加速度非常低，所以这两个值之间的转换是成功的。</p>
<p>令人绝望的是，随着火箭加速度越来越高，当值超过16位整数时，就会发生溢出。</p>
<p>在正常情况下，火箭发动机喷管会接收飞行控制信息。但溢流发生后，接收到一个诊断位模式(表明溢流发生) ，导致喷嘴产生错误行为，最终发生悲剧..。</p>
<h3 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h3><p>最后，欧洲航天局成立了一个小组，从散落在约12平方公里的火箭残骸中寻找线索，并恢复了事故发生时的数据</p>
<p>这次事故可以说是令人印象深刻。给你留下深刻印象的 bug，欢迎在评论部分进行讨论。</p>
</body></html>]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>世界上最贵的bug</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解eslint</title>
    <url>/posts/24305.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="深入了解eslint"><a href="#深入了解eslint" class="headerlink" title="深入了解eslint"></a>深入了解eslint</h1><p>我们在学一个东西之前， 必须清楚的知道它是干什么的， 怎么用？ 之后我们才能将它融会贯通，学以致用</p>
<h2 id="JavaScript的编程风格"><a href="#JavaScript的编程风格" class="headerlink" title="JavaScript的编程风格"></a>JavaScript的编程风格</h2><p>在前端工程愈演愈大的情况下，JavaScript占的比例也很足，需要良好的书写风格，才能在多人协作code时提高效率，何况代码还是需要人来读的，所以可读性、可维护性高的代码很多时候有重要意义。这个时候我们的eslint横空出世</p>
<span id="more"></span>

<h2 id="什么是-EsLint"><a href="#什么是-EsLint" class="headerlink" title="什么是 EsLint"></a>什么是 EsLint</h2><p>ESLint是一个用来识别 ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。换句话说， 即使我们看了无数遍上面说到的Airbnb的JavaScript的编程风格，但是，不少情况下还是会写出不符合要求的代码，那么就需要工具来约束我们。我们通过配置一些风格，让IDE来强制提醒我们代码的风格是否符合规范，所以eslint就是很好的选择，但是eslint还需要和IDE的结合来使用。</p>
<p>知道了它是什么，接下来就是学习它是怎样使用的了</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p><strong>前提：Node.js(&gt;=12.0.0) 且项目目录中存在 package.json 文件</strong></p>
<p>eslint是一个node的包，需要类似npm、yarm来安装，也和其他的第三方包一样，可以全局安装，也可以本地安装</p>
<ol>
<li>安装</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm install --save-install eslint</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>初始化</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npx eslint --init</span><br><span class="line"></span><br><span class="line"># 注：npx 表示从当前路径下查找命令，即 ./node_modules/.bin/eslint --init</span><br></pre></td></tr></tbody></table></figure>

<p>需要配置，可以选择一个流行的风格，Airbnb或者标准，生成JSON文件，.eslintrc.json这个配置文件，<br><strong>需要注意，win10在git ui的命令窗口执行的话无法使用箭头按键来选择，所以最好还是使用win自带的cmd窗口</strong></p>
<p>接下来就会生成.eslint.*配置文件</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">$ npx eslint --init</span></span><br><span class="line"><span class="comment">✔ How would you like to use ESLint? · style</span></span><br><span class="line"><span class="comment">✔ What type of modules does your project use? · esm</span></span><br><span class="line"><span class="comment">✔ Which framework does your project use? · react</span></span><br><span class="line"><span class="comment">✔ Does your project use TypeScript? · No / Yes</span></span><br><span class="line"><span class="comment">✔ Where does your code run? · browser</span></span><br><span class="line"><span class="comment">✔ How would you like to define a style for your project? · guide</span></span><br><span class="line"><span class="comment">✔ Which style guide do you want to follow? · standard</span></span><br><span class="line"><span class="comment">✔ What format do you want your config file to be in? · JSON</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的回答对应下面的 .eslint.json 文件</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"env"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"browser"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"es2021"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"extends"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">"plugin:react/recommended"</span><span class="punctuation">,</span> <span class="string">"standard"</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"parser"</span><span class="punctuation">:</span> <span class="string">"@typescript-eslint/parser"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"parserOptions"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"ecmaFeatures"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"jsx"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"ecmaVersion"</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sourceType"</span><span class="punctuation">:</span> <span class="string">"module"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"plugins"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">"react"</span><span class="punctuation">,</span> <span class="string">"@typescript-eslint"</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"rules"</span><span class="punctuation">:</span> <span class="punctuation">{</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="在-VSCode-中使用"><a href="#在-VSCode-中使用" class="headerlink" title="在 VSCode 中使用"></a>在 VSCode 中使用</h3><p>vscode是一个微软开源的编辑器，很多插件可以辅助，这个eslint就是一个插件，安装eslint插件，安装插件后，会检测打开的工程是否存在一个eslint的配置文件，存在的话就会执行eslint的检测，不存在的话就不会检测。</p>
<p>首先，安装 <a href="https://link.juejin.cn/?target=https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">VSCode ESlint 插件</a>。 需要注意，<strong>插件并不内置 ESLint 核心代码</strong>，而是自动查找项目中的 ESLint 库，在用户每次输入时调用<code>lint</code>命令，并在编辑器中标记代码问题，文档这样说明：</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">The extension uses the ESLint library installed in the opened workspace folder. If the folder doesn't provide one the extension looks for a global install version.</span><br></pre></td></tr></tbody></table></figure>

<p>这样的好处是，编辑器能兼容不同项目中不同版本的 ESLint，同时，能保证同一项目中，团队成员的 ESLint 版本一致。</p>
<p>如果希望在每次保持时，自动 fix 可修复问题，可以在 VSCode 中设置保存时 fix：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* VSCode Settings JSON File</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"editor.codeActionsOnSave"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"source.fixAll.eslint"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>更多详细配置可前往官网查看</p>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>深入了解eslint</tag>
      </tags>
  </entry>
  <entry>
    <title>人类是一个技术性的物种</title>
    <url>/posts/6574.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="人类是一个技术性的物种"><a href="#人类是一个技术性的物种" class="headerlink" title="人类是一个技术性的物种"></a>人类是一个技术性的物种</h1><p>在这个社会， 要想生存下去， 就需要一门技术</p>
<p>​        ⼈类是地球上最聪明的物种。⽤技术来武装⾃⼰，就是聪明的表现。 在发展出较为复杂的技术之前，⼈类所赖以⽣存的优势，⼤约是善于⻓跑，通过漫⻓的追踪，让那些有散热缺陷的猎物热得跑不动， 然后围⽽杀之。从⾏为来看，原始狩猎的⼈类像是体型更⼤的狼群。 我不知道这种颇为有趣的说法是否得到了科学的验证，但狩猎曾经⻓期是⼈类的⽣存法⻔之⼀，和采集果实⼀道成为获取⻝物的主要⼿段，这倒是⼈类学家的共识。</p>
<span id="more"></span>

<p>​        在那个⻓跑狩猎的时代，⼈类就已经开始依赖技术了。那时的技术，是打磨⽯块、制造梭镖、削制⽊⽭，代替并不锋利的⽖⽛；是制造⼸箭，拥有远程攻击的独特能⼒……原始部落往往都有⼸箭设备， 都能制造⼀些简单但巧妙的狩猎武器。狩猎采集是⼀种⽣活⽅式，需 要配套的技术，⽽这⼀整套技术在⽂明起源之前就已经和⼈类相伴， 并决定了⼈类相对其他物种的优势。</p>
<p>​        然后是农业技术。世界上最早发展出农耕⽂明的地⽅，就是四⼤⽂明古国。古代埃及、古代巴⽐伦、古代印度和中国，这些地⽅的古 ⼈类了解四季的更替，分离出了最适合耕种的植物，并且不断地将它们培育成⾼产作物；驯化了适合与⼈类⼀起⽣活的动物，建⽴起了各具特⾊的农业技术。农业技术把⼈类推⼊了⽂明时代，因为农业可以 养活更多的⼈⼝，积累更多的财富，从⽽为复杂的社会上层建筑提供 物质保障。可以说，农业技术是⼈类⽂明的根基。</p>
<p>​        拥有了农业技术之后，⼈类社会变得更加复杂。随着时间流逝， 更多的技术被发明出来，它们或⽤于提⾼⽣产能⼒，⽐如各种农具和运输⼯具，或⽤于提⾼战⽃能⼒，⽐如各类兵器。⼈类通过技术进步和技术扩散，更⼴泛、更⾼效地从⾃然界获取了各类资源，并在⼈类社会内部的不同团体间进⾏竞争。这⼀过程贯穿了整个古代⽂明史。</p>
<p>​        第⼆次世界⼤战之后，计算机和互联⽹的发展引发了第三次⼯业⾰命——信息⾰命。信息的产⽣、收集和处理达到了⼀个前所未有的 ⾼度。信息化带给⼈类社会的好处不仅仅停留在信息技术本身。计算机能够进⾏⼤量的计算，代替⼤量⼈类脑⼒，提⾼⽣产效率，这只是信息技术的初级效应。信息技术更重要的作⽤，是让全⼈类以前所未 有的深度和⼴度结合在⼀起，提供了⼤量的有效市场机会，从⽽极⼤地促进了经济的发展。</p>
<p>​        眼下的世界到了另⼀个节骨眼上，那就是⼈⼯智能的发展。世界正在进⼊第四次⼯业⾰命。在这场⾰命中，⼈们所⾯临的技术选择很 多，可控核聚变、⾼效的太阳能、基因技术……然⽽所有这些，都可以认为是信息时代的进⼀步深化，并不会带来社会本质的改变，只有⼀种技术除外——⼈⼯智能。</p>
<p>​        由此可见， 拥有一门独到的技术可以使自己始终立于不败之地</p>
</body></html>]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>与优秀的人在一起， 真的是非常重要</title>
    <url>/posts/12110.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="与优秀的人在一起，-真的很重要"><a href="#与优秀的人在一起，-真的很重要" class="headerlink" title="与优秀的人在一起， 真的很重要"></a>与优秀的人在一起， 真的很重要</h1><p>孟母三迁的故事告诫我们，<strong>一个人的生活环境真的非常重要，跟优秀的人在一起，你也会变得优秀</strong>；而跟懒惰的人在一起，你也同样会被同化成懒惰之人。</p>
<span id="more"></span>

<h2 id="有人说过这样一句话："><a href="#有人说过这样一句话：" class="headerlink" title="有人说过这样一句话："></a>有人说过这样一句话：</h2><p><strong>你身边的每一个人，做的每一件事，都在悄无声息地影响着你的命运，带领着你走向不同的人生道路。</strong></p>
<p>的确，人生中最大的幸事莫过于有真心一人，知己两三。</p>
<p>与良人在一起，你才会拥有一生的幸福；与良友在一起，你才会收获帮助和快乐</p>
<p><strong>有句话叫，如果您想优秀，那您就要和优秀的人在一起，您才会出类拔萃。</strong></p>
<p>与人交往虽不能怀有目的性，但大家都希望自己与正能量的人交往，也可以提升自己的能量。</p>
<p>想成为怎样的人，就去结交怎样的人，并怀着一颗感恩的心态与之相处。去发现生命中更多的美好。</p>
<h2 id="靠近乐观的人让自己变得阳光正能量"><a href="#靠近乐观的人让自己变得阳光正能量" class="headerlink" title="靠近乐观的人让自己变得阳光正能量"></a><strong>靠近乐观的人</strong>让自己变得阳光正能量</h2><p>俗话说“积极的人像太阳，照到哪里哪里亮；消极的人像月亮，初一十五不一样”。</p>
<p><strong>积极乐观的人，像太阳一样，可以自主发光发热，还可以照亮身边人。</strong></p>
<p>在网上看到一位做销售的网友分享了他经历的一件事。</p>
<p>公司内有一个非常消极的大姐，到处传播负能量。在她眼中，好像任何事情都不会有好的结果，像祥林嫂一样，每天唉声叹气的。</p>
<p>对于没有发生过的事情，她也会给别人预测一个不好的结果。</p>
<p>同事谈了个异地恋女朋友，大家都送上祝福时，这位大姐却说，他们不会有结果的；</p>
<p>当大家都说努努力争取拿下意向客户时，她说，意向客户是谈不成的；</p>
<p>当同事分享自己打折买的大牌衣服时，她说，不喜欢那个牌子的衣服，而且打折后的基本没有可以穿的；</p>
<p>渐渐地大家都不愿意与那位大姐说话了。</p>
<p><strong>消极的人，会消耗你，跟她在一起，你会觉得非常压抑。反之，跟乐观的积极的人在一起，你也会变得开朗，乐观。</strong></p>
<p>乐观的人无关年龄，有的人虽然年龄大，也能在她身上看到青春活力；而有的人，明明很年轻，却也看得萎靡不振，有气无力。</p>
<p>网上看到有一位83岁的老大爷，每天穿着跟年轻人一样，特别潮牌，看起来特别精神。</p>
<p>很多人觉得时尚是年轻人的事，可这位大爷却非要赶潮牌。</p>
<p>大爷心态超级好，每天乐呵呵的，并且由于他的穿着年轻， 给人看上去也年轻了几十岁。他的孙子自爆说有时候觉得自己的衣服都没有爷爷潮，常常蹭爷爷的衣服穿。</p>
<p><strong>常言道：物以类聚，人以群分。</strong></p>
<p>靠近乐观的人吧，让自己也变得乐观，生活才会变美好。</p>
<p>跟乐观的人在一起，是治愈人生最好的解药。</p>
<h2 id="靠近欣赏你的人让自己变得自信又大方"><a href="#靠近欣赏你的人让自己变得自信又大方" class="headerlink" title="靠近欣赏你的人让自己变得自信又大方"></a><strong>靠近欣赏你的人</strong>让自己变得自信又大方</h2><p>有这样一句话：“同是一棵树，有的人看到的是郁郁葱葱，而有的人却只看到树梢上的毛毛虫，原因就在于有的人懂得赏识和赞美。”</p>
<p><strong>的确，一个总是否定你的人，是从你身上看不到郁郁葱葱的，而你从他身上感受到的也是满是自卑与消极的姿态。</strong></p>
<p>电影《煤气灯下》里，男主角通过长期否定女主角，导致女主角精神失常。</p>
<p>男主得知，女主宝拉继承了一笔遗产，于是动了谋取遗产的念头。</p>
<p>他用各种诈骗手段博得宝拉的信任，并成功爱上他，与他成婚。</p>
<p>婚后的他，没了之前的花言巧语，有的只是不断的否定宝拉做的任何事情，导致宝拉开始不断的怀疑自己是否真的做错事了。</p>
<p>他送给宝拉的胸针，自己又偷偷拿走，于是找宝拉要胸针；导致宝拉怎么样找不到，于是他就说宝拉健忘。</p>
<p>刚开始的时候宝拉还辩解，直到这样的次数越来越多，宝拉开始质疑自己。</p>
<p><strong>不断否定式的相处相当于慢性毒药，在不经意间，已让对方精神崩溃。</strong></p>
<p>前段时间与一个朋友见面，看到她容光焕发，大家都很意外，因为她之前由于原生家庭的缘故，极其不自信。</p>
<p>一聊才知道，原来她新交了男朋友，男朋友总是各种鼓励她，肯定她，即使很小很小的事情也在夸奖她。</p>
<p>慢慢地她从曾经的自卑转向自信，去勇敢追求自己喜欢的东西，现在的她做着自己喜欢的工作，时不时跟男朋友出去旅行，每天过得有滋有味。</p>
<p><strong>否定和打击，只会摧毁你，让你跌入深渊；只有肯定和赞美，才能给予你力量。</strong></p>
<p>远离否定你的人，靠近欣赏你的人。让自己变得越来越好。</p>
<p>人这一辈子，和谁在一起，真的很重要。</p>
<p>愿我们都能擦亮双眼，找到对的人，挥别错的人，生活就会如拨云见日，处处光明。</p>
<p>两三知己好友，一知心爱人在侧，这一生，足矣！</p>
<p>最美好的一生就是和最喜欢的人在一起。</p>
</body></html>]]></content>
      <categories>
        <category>好书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>作为前端， 你必须要知道的meta标签知识</title>
    <url>/posts/21213.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="你必须要知道的meta标签知识"><a href="#你必须要知道的meta标签知识" class="headerlink" title="你必须要知道的meta标签知识"></a>你必须要知道的meta标签知识</h1><p><code>meta</code>标签是<code>html</code>标记语言<code>head</code>区一个非常有用的一个辅助性标签，在所有网页中都可以看到以下代码：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<h2 id="meta标签的作用有："><a href="#meta标签的作用有：" class="headerlink" title="meta标签的作用有："></a>meta标签的作用有：</h2><ol>
<li>搜索引擎优化（SEO）</li>
<li>定义页面使用语言</li>
<li>自动刷新并指向新的页面</li>
<li>实现网页转换时的动态效果</li>
<li>控制页面缓冲</li>
<li>网页定级评价</li>
<li>控制网页显示的窗口等</li>
</ol>
<p>什么？meta标签居然能有这么多的作用？ 我竟然还不知道？那就让我们来探讨一下吧</p>
<h2 id="meta标签常见的属性："><a href="#meta标签常见的属性：" class="headerlink" title="meta标签常见的属性："></a>meta标签常见的属性：</h2><ol>
<li><p>charset（<a href="https://so.csdn.net/so/search?q=HTML5&amp;spm=1001.2101.3001.7020">HTML5</a>新增）</p>
</li>
<li><p>http-equiv</p>
</li>
<li><p>name</p>
</li>
<li><p>content</p>
</li>
</ol>
<p>下面我们就来简单的介绍一下这几个属性： </p>
<h3 id="charset属性："><a href="#charset属性：" class="headerlink" title="charset属性："></a>charset属性：</h3><p>它用来定义当前文档的编码方式，告诉浏览器如何解析当前页面:</p>
<meta charset=" utf-8">

<p>此属性定义了页面的编码集。建议 UTF-8。</p>
<h3 id="http-equiv属性："><a href="#http-equiv属性：" class="headerlink" title="http-equiv属性："></a>http-equiv属性：</h3><p>HTTP-EQUIV类似于HTTP的头部协议，它回应给浏览器一些有用的信息，以帮助正确和精确地显示网页内容。</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">meta`标签的`http-equiv`属性语法格式是：</span><br><span class="line">`＜meta http-equiv=”参数” content=”参数变量值”＞</span><br></pre></td></tr></tbody></table></figure>

<p>其中<code>http-equiv</code>属性主要有以下几种参数：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">1.<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">”Set-Cookie”</span> <span class="attr">content</span>=<span class="string">”cookievalue</span>=<span class="string">xxx;</span> <span class="attr">expires</span>=<span class="string">Friday,12-Jan-2001</span> <span class="attr">18:18:18</span> <span class="attr">GMT</span>; <span class="attr">path</span>=<span class="string">/”</span>&gt;</span>:如果网页过期，那么存盘的cookie将被删除。必须使用GMT的时间格式。</span><br><span class="line">2.<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">'expires'</span> <span class="attr">content</span>=<span class="string">'时间'</span> &gt;</span>：用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。</span><br><span class="line">3.<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">”Refresh”</span> <span class="attr">content</span>=<span class="string">”5;URL”</span>&gt;</span>：告诉浏览器在【数字】秒后跳转到【一个网址】</span><br><span class="line">4.<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">”content-Type”</span> <span class="attr">content</span>=<span class="string">”text/html;</span> <span class="attr">charset</span>=<span class="string">utf-8″</span>&gt;</span>：设定页面使用的字符集。</span><br><span class="line">5. <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">”utf-8″</span>&gt;</span>：在HTML5中设定字符集的简写写法。</span><br><span class="line">6.<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">”Pragma”</span> <span class="attr">content</span>=<span class="string">”no-cache”</span>&gt;</span>：禁止浏览器从本地计算机的缓存中访问页面内容。访问者将无法脱机浏览。</span><br><span class="line">7.<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">”Window-target”</span> <span class="attr">content</span>=<span class="string">”_top”</span>&gt;</span>：用来防止别人在iframe(框架)里调用自己的页面，这也算是一个非常实用的属性。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>当然也是有一些弃用的属性， 我就不多说了</p>
<h3 id="name属性："><a href="#name属性：" class="headerlink" title="name属性："></a>name属性：</h3><p>此属性主要用于描述网页，与之对应的属性为content。</p>
<p>content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。</p>
<p>下面是name属性的语法：</p>
<meta name="参数" content="具体的参数值">

<p>我在这里列举几个常用的：</p>
<ol>
<li><p>keywords(关键字)</p>
<p>用来告诉搜索引擎你网页的关键字是什么，代码实现： </p>
<meta name="keywords" content="欢迎来和我一起学习前端"></li>
<li><p>description(网站内容描述)</p>
<p>description用来告诉搜索引擎你的页面主要内容，代码实现：</p>
<meta name="兴趣部落是一个面向前端开发基础知识分享平台"></li>
<li><p>author(作者)</p>
<p>标注网页的作者，代码实现：</p>
<meta name="author" content="蚂蚁部落"></li>
<li><p>generator</p>
<p>说明网站的采用的什么软件制作，代码实现：</p>
<meta name="generator" content="信息参数"></li>
<li><p>COPYRIGHT</p>
<p>说明网站版权信息，代码实现：</p>
<meta name="COPYRIGHT" content="信息参数"></li>
</ol>
<p>更多的大家如果有需要， 可以去查官网</p>
<h3 id="content属性"><a href="#content属性" class="headerlink" title="content属性"></a>content属性</h3><p>此属性包含 <strong>http-equiv</strong> 或者 <strong>name</strong> 属性的值，具体取决于所使用的值</p>
<meta name="aaa" content="bbb">
<meta http-equiv="xxx" content="yyy">

</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>meta标签</tag>
      </tags>
  </entry>
  <entry>
    <title>函数的防抖与节流</title>
    <url>/posts/40065.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="函数防抖和节流"><a href="#函数防抖和节流" class="headerlink" title="函数防抖和节流"></a>函数防抖和节流</h1><h2 id="什么是函数防抖？"><a href="#什么是函数防抖？" class="headerlink" title="什么是函数防抖？"></a>什么是函数防抖？</h2><p>短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行</p>
<p>而我们的函数防抖分为立即执行版和非立即执行版：</p>
<h3 id="非立即执行版："><a href="#非立即执行版：" class="headerlink" title="非立即执行版："></a>非立即执行版：</h3><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) {</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>];</span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">      func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">    }, wait);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<p>非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p>
<h3 id="立即执行版："><a href="#立即执行版：" class="headerlink" title="立即执行版："></a>立即执行版：</h3><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 立即执行版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) {</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">      <span class="keyword">let</span> context = <span class="variable language_">this</span>; <span class="comment">// 这边的 this 指向谁?</span></span><br><span class="line">      <span class="keyword">let</span> args = <span class="variable language_">arguments</span>; <span class="comment">// arguments中存着e</span></span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">let</span> callNow = !timer;</span><br><span class="line"> </span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      }, wait)</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (callNow) func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果</p>
<h3 id="合成版："><a href="#合成版：" class="headerlink" title="合成版："></a>合成版：</h3><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * debounce:函数防抖</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@params</span></span></span><br><span class="line"><span class="comment"> *    func:要执行的函数</span></span><br><span class="line"><span class="comment"> *    wait:间隔时间</span></span><br><span class="line"><span class="comment"> *    immediate:触发的边界(TRUE==&gt;开始边界)</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *    可被调用的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait, immediate</span>) {</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>,</span><br><span class="line">      result = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) { </span><br><span class="line">    <span class="keyword">let</span> now = immediate &amp;&amp; !timeout</span><br><span class="line">    <span class="keyword">if</span>(timeout)<span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> { </span><br><span class="line">      <span class="keyword">if</span> (!immediate) result = func.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args)</span><br><span class="line">      timeout = <span class="literal">null</span></span><br><span class="line">    },wait)</span><br><span class="line">    <span class="keyword">if</span> (now) result = func.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>我们常见的工具库， 比如说lodash中就对我们的这个函数防抖做了一个封装， 如果我们的在工作中遇到类似的需求， 就可以直接自己写一个或者是用人家的</p>
<h3 id="函数防抖的主要使用场景："><a href="#函数防抖的主要使用场景：" class="headerlink" title="函数防抖的主要使用场景："></a>函数防抖的主要使用场景：</h3><p>函数防抖一般用在什么情况之下呢？一般用在，连续的事件只需触发一次回调的场合。具体有：</p>
<ul>
<li>搜索框搜索输入。只需用户最后一次输入完，再发送请求；</li>
<li>用户名、手机号、邮箱输入验证；</li>
<li>浏览器窗口大小改变后，只需窗口调整完后，再执行 resize 事件中的代码，防止重复渲染。</li>
</ul>
<h2 id="函数节流："><a href="#函数节流：" class="headerlink" title="函数节流："></a>函数节流：</h2><p>限制一个函数在一定时间内只能执行一次</p>
<p>主要实现思路就是通过 setTimeout 定时器，通过设置延时时间，在第一次调用时，创建定时器，先设定一个变量，然后把定时器赋值给这个变量，再写入需要执行的函数。第二次执行这个函数时，会判断变量是否true，是则返回。当第一次的定时器执行完函数最后会设定变量为false。那么下次判断变量时则为false，函数会依次运行。目的在于在一定的时间内，保证多次函数的请求只执行最后一次调用</p>
<p>节流也是有下面几个版本：</p>
<ol>
<li><p>时间戳版本:函数立即执行,间隔wait秒</p>
</li>
<li><p>定时器版本:间隔wait秒,函数执行,结束后函数在执行一次</p>
</li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * throttle:函数节流</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@version</span> </span></span><br><span class="line"><span class="comment"> *    时间戳版本</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@params</span></span></span><br><span class="line"><span class="comment"> *    fn:要执行的函数</span></span><br><span class="line"><span class="comment"> *    wait:间隔时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, wait</span>) {</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>,</span><br><span class="line">    per = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) {</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span></span><br><span class="line">    <span class="keyword">if</span> (now - per &gt; wait) {</span><br><span class="line">      result = fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args)</span><br><span class="line">      per = now</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * throttle:函数节流</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@version</span> </span></span><br><span class="line"><span class="comment"> *    定时器版本</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@params</span></span></span><br><span class="line"><span class="comment"> *    fn:要执行的函数</span></span><br><span class="line"><span class="comment"> *    wait:间隔时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, wait</span>) {</span><br><span class="line">  <span class="keyword">let</span> timerout = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) {</span><br><span class="line">    <span class="keyword">if</span> (!timerout) {</span><br><span class="line">      timerout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">        fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args)</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timerout)</span><br><span class="line">        timerout = <span class="literal">null</span></span><br><span class="line">      }, wait);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * throttle:函数节流</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@version</span></span></span><br><span class="line"><span class="comment"> *    plus版本</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@params</span></span></span><br><span class="line"><span class="comment"> *    fn:要执行的函数</span></span><br><span class="line"><span class="comment"> *    wait:间隔时间</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *    可被调用的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, wait</span>) {</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>,</span><br><span class="line">    timerout = <span class="literal">null</span>,</span><br><span class="line">    pre = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) {</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span></span><br><span class="line">    remaining = wait - (now - pre)</span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) {</span><br><span class="line">      pre = now</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timerout)</span><br><span class="line">      timerout = <span class="literal">null</span></span><br><span class="line">      result = fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args)</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!timerout) {</span><br><span class="line">      timerout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">        pre = <span class="keyword">new</span> <span class="title class_">Date</span></span><br><span class="line">        timerout = <span class="literal">null</span></span><br><span class="line">        result = fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args)</span><br><span class="line">      }, remaining);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ul>
<li>懒加载、滚动加载、加载更多或监听滚动条位置；</li>
<li>百度搜索框，搜索联想功能；</li>
<li>防止高频点击提交，防止表单重复提交；</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>函数防抖和节流</tag>
      </tags>
  </entry>
  <entry>
    <title>你了解ssr吗</title>
    <url>/posts/62053.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="你了解ssr吗？"><a href="#你了解ssr吗？" class="headerlink" title="你了解ssr吗？"></a>你了解ssr吗？</h1><h2 id="面试官：SSR解决了什么问题？有做过SSR吗？你是怎么做的？"><a href="#面试官：SSR解决了什么问题？有做过SSR吗？你是怎么做的？" class="headerlink" title="面试官：SSR解决了什么问题？有做过SSR吗？你是怎么做的？"></a>面试官：SSR解决了什么问题？有做过SSR吗？你是怎么做的？</h2><img src="/posts/62053/62053/image-20221104073621277.png" class="" title="image-20221104073621277">

<h3 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h3><p><code>Server-Side Rendering</code> 我们称其为<code>SSR</code>，意为服务端渲染</p>
<span id="more"></span>

<p>指由服务侧完成页面的 <code>HTML</code> 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程</p>
<p>先来看看<code>Web</code>3个阶段的发展史：</p>
<ul>
<li>传统服务端渲染SSR</li>
<li>单页面应用SPA</li>
<li>服务端渲染SSR</li>
</ul>
<h4 id="传统web开发"><a href="#传统web开发" class="headerlink" title="传统web开发"></a><strong>传统web开发</strong></h4><p>网页内容在服务端渲染完成，⼀次性传输到浏览器</p>
<img src="/posts/62053/62053/image-20221104073751582.png" class="" title="image-20221104073751582">

<p>打开页面查看源码，浏览器拿到的是全部的<code>dom</code>结构</p>
<h4 id="单页应用SPA"><a href="#单页应用SPA" class="headerlink" title="单页应用SPA"></a><strong>单页应用SPA</strong></h4><p>单页应用优秀的用户体验，使其逐渐成为主流，页面内容由<code>JS</code>渲染出来，这种方式称为客户端渲染</p>
<img src="/posts/62053/62053/image-20221104073909458.png" class="" title="image-20221104073909458">

<p>打开页面查看源码，浏览器拿到的仅有宿主元素<code>#app</code>，并没有内容</p>
<h4 id="服务端渲染SSR"><a href="#服务端渲染SSR" class="headerlink" title="服务端渲染SSR"></a>服务端渲染SSR</h4><p><code>SSR</code>解决方案，后端渲染出完整的首屏的<code>dom</code>结构返回，前端拿到的内容包括首屏及完整<code>spa</code>结构，应用激活后依然按照<code>spa</code>方式运行</p>
<img src="/posts/62053/62053/image-20221104074002378.png" class="" title="image-20221104074002378">

<p>看完前端发展，我们再看看<code>Vue</code>官方对<code>SSR</code>的解释：</p>
<blockquote>
<p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序</p>
<p>服务器渲染的 Vue.js 应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行</p>
</blockquote>
<p>我们从上门解释得到以下结论：</p>
<ul>
<li><code>Vue SSR</code>是一个在<code>SPA</code>上进行改良的服务端渲染</li>
<li>通过<code>Vue SSR</code>渲染的页面，需要在客户端激活才能实现交互</li>
<li><code>Vue SSR</code>将包含两部分：服务端渲染的首屏，包含交互的<code>SPA</code></li>
</ul>
<h3 id="二、解决了什么"><a href="#二、解决了什么" class="headerlink" title="二、解决了什么"></a>二、解决了什么</h3><p>SSR主要解决了以下两种问题：</p>
<ul>
<li>seo：搜索引擎优先爬取页面<code>HTML</code>结构，使用<code>ssr</code>时，服务端已经生成了和业务想关联的<code>HTML</code>，有利于<code>seo</code></li>
<li>首屏呈现渲染：用户无需等待页面所有<code>js</code>加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端）</li>
</ul>
<p>但是使用<code>SSR</code>同样存在以下的缺点：</p>
<ul>
<li>复杂度：整个项目的复杂度</li>
<li>库的支持性，代码兼容</li>
<li>性能问题<ul>
<li>每个请求都是<code>n</code>个实例的创建，不然会污染，消耗会变得很大</li>
<li>缓存 <code>node serve</code>、 <code>nginx</code>判断当前用户有没有过期，如果没过期的话就缓存，用刚刚的结果。</li>
<li>降级：监控<code>cpu</code>、内存占用过多，就<code>spa</code>，返回单个的壳</li>
</ul>
</li>
<li>服务器负载变大，相对于前后端分离服务器只需要提供静态资源来说，服务器负载更大，所以要慎重使用</li>
</ul>
<p>所以在我们选择是否使用<code>SSR</code>前，我们需要慎重问问自己这些问题：</p>
<ol>
<li>需要<code>SEO</code>的页面是否只是少数几个，这些是否可以使用预渲染（Prerender SPA Plugin）实现</li>
<li>首屏的请求响应逻辑是否复杂，数据返回是否大量且缓慢</li>
</ol>
<h3 id="三、如何实现"><a href="#三、如何实现" class="headerlink" title="三、如何实现"></a>三、如何实现</h3><p>对于同构开发，我们依然使用<code>webpack</code>打包，我们要解决两个问题：服务端首屏渲染和客户端激活</p>
<p>这里需要生成一个服务器<code>bundle</code>文件用于服务端首屏渲染和一个客户端<code>bundle</code>文件用于客户端激活</p>
<img src="/posts/62053/62053/image-20221104074122526.png" class="" title="image-20221104074122526">

<p>代码结构 除了两个不同入口之外，其他结构和之前<code>vue</code>应用完全相同</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">src</span><br><span class="line">├── router</span><br><span class="line">├────── index.<span class="property">js</span> # 路由声明</span><br><span class="line">├── store</span><br><span class="line">├────── index.<span class="property">js</span> # 全局状态</span><br><span class="line">├── main.<span class="property">js</span> # ⽤于创建vue实例</span><br><span class="line">├── entry-client.<span class="property">js</span> # 客户端⼊⼝，⽤于静态内容“激活”</span><br><span class="line">└── entry-server.<span class="property">js</span> # 服务端⼊⼝，⽤于⾸屏内容渲染</span><br></pre></td></tr></tbody></table></figure>

<p>路由配置</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Router</span> <span class="keyword">from</span> <span class="string">"vue-router"</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Router</span>);</span><br><span class="line"><span class="comment">//导出⼯⼚函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRouter</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Router</span>({</span><br><span class="line">        <span class="attr">mode</span>: <span class="string">'history'</span>,</span><br><span class="line">        <span class="attr">routes</span>: [</span><br><span class="line">            <span class="comment">// 客户端没有编译器，这⾥要写成渲染函数</span></span><br><span class="line">            { <span class="attr">path</span>: <span class="string">"/"</span>, <span class="attr">component</span>: { <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="string">'div'</span>, <span class="string">'index page'</span>) } },</span><br><span class="line">            { <span class="attr">path</span>: <span class="string">"/detail"</span>, <span class="attr">component</span>: { <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="string">'div'</span>, <span class="string">'detail page'</span>) } }</span><br><span class="line">        ]</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>主文件main.js</p>
<p>跟之前不同，主文件是负责创建<code>vue</code>实例的工厂，每次请求均会有独立的<code>vue</code>实例创建</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">"./App.vue"</span>;</span><br><span class="line"><span class="keyword">import</span> { createRouter } <span class="keyword">from</span> <span class="string">"./router"</span>;</span><br><span class="line"><span class="comment">// 导出Vue实例⼯⼚函数，为每次请求创建独⽴实例</span></span><br><span class="line"><span class="comment">// 上下⽂⽤于给vue实例传递参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createApp</span>(<span class="params">context</span>) {</span><br><span class="line">    <span class="keyword">const</span> router = <span class="title function_">createRouter</span>();</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>({</span><br><span class="line">        router,</span><br><span class="line">        context,</span><br><span class="line">        <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> { app, router };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编写服务端入口<code>src/entry-server.js</code></p>
<p>它的任务是创建<code>Vue</code>实例并根据传入<code>url</code>指定首屏</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { createApp } <span class="keyword">from</span> <span class="string">"./main"</span>;</span><br><span class="line"><span class="comment">// 返回⼀个函数，接收请求上下⽂，返回创建的vue实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; {</span><br><span class="line">    <span class="comment">// 这⾥返回⼀个Promise，确保路由或组件准备就绪</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">        <span class="keyword">const</span> { app, router } = <span class="title function_">createApp</span>(context);</span><br><span class="line">        <span class="comment">// 跳转到⾸屏的地址</span></span><br><span class="line">        router.<span class="title function_">push</span>(context.<span class="property">url</span>);</span><br><span class="line">        <span class="comment">// 路由就绪，返回结果</span></span><br><span class="line">        router.<span class="title function_">onReady</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">            <span class="title function_">resolve</span>(app);</span><br><span class="line">        }, reject);</span><br><span class="line">    });</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>编写客户端入口<code>entry-client.js</code></p>
<p>客户端入口只需创建<code>vue</code>实例并执行挂载，这⼀步称为激活</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { createApp } <span class="keyword">from</span> <span class="string">"./main"</span>;</span><br><span class="line"><span class="comment">// 创建vue、router实例</span></span><br><span class="line"><span class="keyword">const</span> { app, router } = <span class="title function_">createApp</span>();</span><br><span class="line"><span class="comment">// 路由就绪，执⾏挂载</span></span><br><span class="line">router.<span class="title function_">onReady</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    app.$mount(<span class="string">"#app"</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>对<code>webpack</code>进行配置</p>
<p>安装依赖</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">npm install webpack-node-externals lodash.<span class="property">merge</span> -D</span><br></pre></td></tr></tbody></table></figure>

<p>对<code>vue.config.js</code>进行配置</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 两个插件分别负责打包客户端和服务端</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VueSSRServerPlugin</span> = <span class="built_in">require</span>(<span class="string">"vue-server-renderer/server-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VueSSRClientPlugin</span> = <span class="built_in">require</span>(<span class="string">"vue-server-renderer/client-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">"webpack-node-externals"</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">"lodash.merge"</span>);</span><br><span class="line"><span class="comment">// 根据传⼊环境变量决定⼊⼝⽂件和相应配置项</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TARGET_NODE</span> = process.<span class="property">env</span>.<span class="property">WEBPACK_TARGET</span> === <span class="string">"node"</span>;</span><br><span class="line"><span class="keyword">const</span> target = <span class="variable constant_">TARGET_NODE</span> ? <span class="string">"server"</span> : <span class="string">"client"</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = {</span><br><span class="line">    <span class="attr">css</span>: {</span><br><span class="line">        <span class="attr">extract</span>: <span class="literal">false</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">outputDir</span>: <span class="string">'./dist/'</span>+target,</span><br><span class="line">    <span class="attr">configureWebpack</span>: <span class="function">() =&gt;</span> ({</span><br><span class="line">        <span class="comment">// 将 entry 指向应⽤程序的 server / client ⽂件</span></span><br><span class="line">        <span class="attr">entry</span>: <span class="string">`./src/entry-<span class="subst">${target}</span>.js`</span>,</span><br><span class="line">        <span class="comment">// 对 bundle renderer 提供 source map ⽀持</span></span><br><span class="line">        <span class="attr">devtool</span>: <span class="string">'source-map'</span>,</span><br><span class="line">        <span class="comment">// target设置为node使webpack以Node适⽤的⽅式处理动态导⼊，</span></span><br><span class="line">        <span class="comment">// 并且还会在编译Vue组件时告知`vue-loader`输出⾯向服务器代码。</span></span><br><span class="line">        <span class="attr">target</span>: <span class="variable constant_">TARGET_NODE</span> ? <span class="string">"node"</span> : <span class="string">"web"</span>,</span><br><span class="line">        <span class="comment">// 是否模拟node全局变量</span></span><br><span class="line">        <span class="attr">node</span>: <span class="variable constant_">TARGET_NODE</span> ? <span class="literal">undefined</span> : <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">output</span>: {</span><br><span class="line">            <span class="comment">// 此处使⽤Node⻛格导出模块</span></span><br><span class="line">            <span class="attr">libraryTarget</span>: <span class="variable constant_">TARGET_NODE</span> ? <span class="string">"commonjs2"</span> : <span class="literal">undefined</span></span><br><span class="line">        },</span><br><span class="line">        <span class="comment">// https://webpack.js.org/configuration/externals/#function</span></span><br><span class="line">        <span class="comment">// https://github.com/liady/webpack-node-externals</span></span><br><span class="line">        <span class="comment">// 外置化应⽤程序依赖模块。可以使服务器构建速度更快，并⽣成较⼩的打包⽂件。</span></span><br><span class="line">        <span class="attr">externals</span>: <span class="variable constant_">TARGET_NODE</span></span><br><span class="line">        ? <span class="title function_">nodeExternals</span>({</span><br><span class="line">            <span class="comment">// 不要外置化webpack需要处理的依赖模块。</span></span><br><span class="line">            <span class="comment">// 可以在这⾥添加更多的⽂件类型。例如，未处理 *.vue 原始⽂件，</span></span><br><span class="line">            <span class="comment">// 还应该将修改`global`（例如polyfill）的依赖模块列⼊⽩名单</span></span><br><span class="line">            <span class="attr">whitelist</span>: [<span class="regexp">/\.css$/</span>]</span><br><span class="line">        })</span><br><span class="line">        : <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">optimization</span>: {</span><br><span class="line">            <span class="attr">splitChunks</span>: <span class="literal">undefined</span></span><br><span class="line">        },</span><br><span class="line">        <span class="comment">// 这是将服务器的整个输出构建为单个 JSON ⽂件的插件。</span></span><br><span class="line">        <span class="comment">// 服务端默认⽂件名为 `vue-ssr-server-bundle.json`</span></span><br><span class="line">        <span class="comment">// 客户端默认⽂件名为 `vue-ssr-client-manifest.json`。</span></span><br><span class="line">        <span class="attr">plugins</span>: [<span class="variable constant_">TARGET_NODE</span> ? <span class="keyword">new</span> <span class="title class_">VueSSRServerPlugin</span>() : <span class="keyword">new</span></span><br><span class="line">                  <span class="title class_">VueSSRClientPlugin</span>()]</span><br><span class="line">    }),</span><br><span class="line">    <span class="attr">chainWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> {</span><br><span class="line">        <span class="comment">// cli4项⽬添加</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable constant_">TARGET_NODE</span>) {</span><br><span class="line">            config.<span class="property">optimization</span>.<span class="title function_">delete</span>(<span class="string">'splitChunks'</span>)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        config.<span class="property">module</span></span><br><span class="line">            .<span class="title function_">rule</span>(<span class="string">"vue"</span>)</span><br><span class="line">            .<span class="title function_">use</span>(<span class="string">"vue-loader"</span>)</span><br><span class="line">            .<span class="title function_">tap</span>(<span class="function"><span class="params">options</span> =&gt;</span> {</span><br><span class="line">            <span class="title function_">merge</span>(options, {</span><br><span class="line">                <span class="attr">optimizeSSR</span>: <span class="literal">false</span></span><br><span class="line">            });</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>对脚本进行配置，安装依赖</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">npm i cross-env -D</span><br></pre></td></tr></tbody></table></figure>

<p>定义创建脚本<code>package.json</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: {</span><br><span class="line"> <span class="string">"build:client"</span>: <span class="string">"vue-cli-service build"</span>,</span><br><span class="line"> <span class="string">"build:server"</span>: <span class="string">"cross-env WEBPACK_TARGET=node vue-cli-service build"</span>,</span><br><span class="line"> <span class="string">"build"</span>: <span class="string">"npm run build:server &amp;&amp; npm run build:client"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>执行打包：npm run build</p>
<p>最后修改宿主文件<code>/public/index.html</code></p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--vue-ssr-outlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>是服务端渲染入口位置，注意不能为了好看而在前后加空格</p>
<p>安装<code>vuex</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">npm install -S vuex</span><br></pre></td></tr></tbody></table></figure>

<p>创建<code>vuex</code>工厂函数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createStore</span> () {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>({</span><br><span class="line">        <span class="attr">state</span>: {</span><br><span class="line">            <span class="attr">count</span>:<span class="number">108</span></span><br><span class="line">        },</span><br><span class="line">        <span class="attr">mutations</span>: {</span><br><span class="line">            <span class="title function_">add</span>(<span class="params">state</span>){</span><br><span class="line">                state.<span class="property">count</span> += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>main.js</code>文件中挂载<code>store</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { createStore } <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createApp</span> (context) {</span><br><span class="line">    <span class="comment">// 创建实例</span></span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">createStore</span>()</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>({</span><br><span class="line">        store, <span class="comment">// 挂载</span></span><br><span class="line">        <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">    })</span><br><span class="line">    <span class="keyword">return</span> { app, router, store }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>服务器端渲染的是应用程序的”快照”，如果应用依赖于⼀些异步数据，那么在开始渲染之前，需要先预取和解析好这些数据</p>
<p>在<code>store</code>进行一步数据获取</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createStore</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>({</span><br><span class="line">        <span class="attr">mutations</span>: {</span><br><span class="line">            <span class="comment">// 加⼀个初始化</span></span><br><span class="line">            <span class="title function_">init</span>(<span class="params">state, count</span>) {</span><br><span class="line">                state.<span class="property">count</span> = count;</span><br><span class="line">            },</span><br><span class="line">        },</span><br><span class="line">        <span class="attr">actions</span>: {</span><br><span class="line">            <span class="comment">// 加⼀个异步请求count的action</span></span><br><span class="line">            <span class="title function_">getCount</span>(<span class="params">{ commit }</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> {</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">                        <span class="title function_">commit</span>(<span class="string">"init"</span>, <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>);</span><br><span class="line">                        <span class="title function_">resolve</span>();</span><br><span class="line">                    }, <span class="number">1000</span>);</span><br><span class="line">                });</span><br><span class="line">            },</span><br><span class="line">        },</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>组件中的数据预取逻辑</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">    <span class="title function_">asyncData</span>(<span class="params">{ store, route }</span>) { <span class="comment">// 约定预取逻辑编写在预取钩⼦asyncData中</span></span><br><span class="line">        <span class="comment">// 触发 action 后，返回 Promise 以便确定请求结果</span></span><br><span class="line">        <span class="keyword">return</span> store.<span class="title function_">dispatch</span>(<span class="string">"getCount"</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>服务端数据预取，<code>entry-server.js</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { createApp } <span class="keyword">from</span> <span class="string">"./app"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">        <span class="comment">// 拿出store和router实例</span></span><br><span class="line">        <span class="keyword">const</span> { app, router, store } = <span class="title function_">createApp</span>(context);</span><br><span class="line">        router.<span class="title function_">push</span>(context.<span class="property">url</span>);</span><br><span class="line">        router.<span class="title function_">onReady</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">            <span class="comment">// 获取匹配的路由组件数组</span></span><br><span class="line">            <span class="keyword">const</span> matchedComponents = router.<span class="title function_">getMatchedComponents</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若⽆匹配则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (!matchedComponents.<span class="property">length</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">reject</span>({ <span class="attr">code</span>: <span class="number">404</span> });</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对所有匹配的路由组件调⽤可能存在的`asyncData()`</span></span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">all</span>(</span><br><span class="line">                matchedComponents.<span class="title function_">map</span>(<span class="function"><span class="params">Component</span> =&gt;</span> {</span><br><span class="line">                    <span class="keyword">if</span> (<span class="title class_">Component</span>.<span class="property">asyncData</span>) {</span><br><span class="line">                        <span class="keyword">return</span> <span class="title class_">Component</span>.<span class="title function_">asyncData</span>({</span><br><span class="line">                            store,</span><br><span class="line">                            <span class="attr">route</span>: router.<span class="property">currentRoute</span>,</span><br><span class="line">                        });</span><br><span class="line">                    }</span><br><span class="line">                }),</span><br><span class="line">            )</span><br><span class="line">                .<span class="title function_">then</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">                <span class="comment">// 所有预取钩⼦ resolve 后，</span></span><br><span class="line">                <span class="comment">// store 已经填充⼊渲染应⽤所需状态</span></span><br><span class="line">                <span class="comment">// 将状态附加到上下⽂，且 `template` 选项⽤于 renderer 时，</span></span><br><span class="line">                <span class="comment">// 状态将⾃动序列化为 `window.__INITIAL_STATE__`，并注⼊ HTML</span></span><br><span class="line">                context.<span class="property">state</span> = store.<span class="property">state</span>;</span><br><span class="line"></span><br><span class="line">                <span class="title function_">resolve</span>(app);</span><br><span class="line">            })</span><br><span class="line">                .<span class="title function_">catch</span>(reject);</span><br><span class="line">        }, reject);</span><br><span class="line">    });</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>客户端在挂载到应用程序之前，<code>store</code> 就应该获取到状态，<code>entry-client.js</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 导出store</span></span><br><span class="line"><span class="keyword">const</span> { app, router, store } = <span class="title function_">createApp</span>();</span><br><span class="line"><span class="comment">// 当使⽤ template 时，context.state 将作为 window.__INITIAL_STATE__ 状态⾃动嵌⼊到最终的 HTML </span></span><br><span class="line"><span class="comment">// 在客户端挂载到应⽤程序之前，store 就应该获取到状态：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">__INITIAL_STATE__</span>) {</span><br><span class="line">    store.<span class="title function_">replaceState</span>(<span class="variable language_">window</span>.<span class="property">__INITIAL_STATE__</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>客户端数据预取处理，<code>main.js</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>({</span><br><span class="line">    <span class="title function_">beforeMount</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">const</span> { asyncData } = <span class="variable language_">this</span>.<span class="property">$options</span>;</span><br><span class="line">        <span class="keyword">if</span> (asyncData) {</span><br><span class="line">            <span class="comment">// 将获取数据操作分配给 promise</span></span><br><span class="line">            <span class="comment">// 以便在组件中，我们可以在数据准备就绪后</span></span><br><span class="line">            <span class="comment">// 通过运⾏ `this.dataPromise.then(...)` 来执⾏其他任务</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">dataPromise</span> = <span class="title function_">asyncData</span>({</span><br><span class="line">                <span class="attr">store</span>: <span class="variable language_">this</span>.<span class="property">$store</span>,</span><br><span class="line">                <span class="attr">route</span>: <span class="variable language_">this</span>.<span class="property">$route</span>,</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>修改服务器启动文件</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获取⽂件路径</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resolve</span> = dir =&gt; <span class="built_in">require</span>(<span class="string">'path'</span>).<span class="title function_">resolve</span>(__dirname, dir)</span><br><span class="line"><span class="comment">// 第 1 步：开放dist/client⽬录，关闭默认下载index⻚的选项，不然到不了后⾯路由</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="title function_">resolve</span>(<span class="string">'../dist/client'</span>), {<span class="attr">index</span>: <span class="literal">false</span>}))</span><br><span class="line"><span class="comment">// 第 2 步：获得⼀个createBundleRenderer</span></span><br><span class="line"><span class="keyword">const</span> { createBundleRenderer } = <span class="built_in">require</span>(<span class="string">"vue-server-renderer"</span>);</span><br><span class="line"><span class="comment">// 第 3 步：服务端打包⽂件地址</span></span><br><span class="line"><span class="keyword">const</span> bundle = <span class="title function_">resolve</span>(<span class="string">"../dist/server/vue-ssr-server-bundle.json"</span>);</span><br><span class="line"><span class="comment">// 第 4 步：创建渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="title function_">createBundleRenderer</span>(bundle, {</span><br><span class="line">    <span class="attr">runInNewContext</span>: <span class="literal">false</span>, <span class="comment">// https://ssr.vuejs.org/zh/api/#runinnewcontext</span></span><br><span class="line">    <span class="attr">template</span>: <span class="built_in">require</span>(<span class="string">'fs'</span>).<span class="title function_">readFileSync</span>(<span class="title function_">resolve</span>(<span class="string">"../public/index.html"</span>), <span class="string">"utf8"</span>), <span class="comment">// 宿主⽂件</span></span><br><span class="line">    <span class="attr">clientManifest</span>: <span class="built_in">require</span>(<span class="title function_">resolve</span>(<span class="string">"../dist/client/vue-ssr-clientmanifest.json"</span>)) <span class="comment">// 客户端清单</span></span><br><span class="line">});</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'*'</span>, <span class="keyword">async</span> (req,res)=&gt;{</span><br><span class="line">    <span class="comment">// 设置url和title两个重要参数</span></span><br><span class="line">    <span class="keyword">const</span> context = {</span><br><span class="line">        <span class="attr">title</span>:<span class="string">'ssr test'</span>,</span><br><span class="line">        <span class="attr">url</span>:req.<span class="property">url</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">const</span> html = <span class="keyword">await</span> renderer.<span class="title function_">renderToString</span>(context);</span><br><span class="line">    res.<span class="title function_">send</span>(html)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>使用<code>ssr</code>不存在单例模式，每次用户请求都会创建一个新的<code>vue</code>实例</p>
</li>
<li><p>实现<code>ssr</code>需要实现服务端首屏渲染和客户端激活</p>
</li>
<li><p>服务端异步获取数据</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">asyncData</span><br></pre></td></tr></tbody></table></figure>

<p>可以分为首屏异步获取和切换组件获取</p>
<ul>
<li>首屏异步获取数据，在服务端预渲染的时候就应该已经完成</li>
<li>切换组件通过<code>mixin</code>混入，在<code>beforeMount</code>钩子完成数据获取</li>
</ul>
</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://juejin.cn/post/6896007907050487816">https://juejin.cn/post/6896007907050487816</a></li>
<li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>什么是ssr</tag>
      </tags>
  </entry>
  <entry>
    <title>参观巴州博物馆</title>
    <url>/posts/17399f0c.html</url>
    <content><![CDATA[<html><head></head><body><p>大约是花了3个小时参观了一下巴州的博物馆， 我也是非常的激动， 特意拍了很多的照片。</p>
<span id="more"></span>

<img src="/posts/17399f0c/17399f0c/IMG_1807.jpg" class="" title="IMG_1807">

<img src="/posts/17399f0c/17399f0c/IMG_1806.jpg" class="" title="IMG_1806">

<img src="/posts/17399f0c/17399f0c/IMG_1811.jpg" class="" title="IMG_1811">

<img src="/posts/17399f0c/17399f0c/IMG_1808.jpg" class="" title="IMG_1808">

<img src="/posts/17399f0c/17399f0c/IMG_1810.jpg" class="" title="IMG_1810">

<img src="/posts/17399f0c/17399f0c/IMG_1809.jpg" class="" title="IMG_1809">

<img src="/posts/17399f0c/17399f0c/IMG_1795.jpg" class="" title="IMG_1795">

<img src="/posts/17399f0c/17399f0c/IMG_1816.jpg" class="" title="IMG_1816"><img src="/posts/17399f0c/17399f0c/IMG_1796.jpg" class="" title="IMG_1796">

<img src="/posts/17399f0c/17399f0c/IMG_1814.jpg" class="" title="IMG_1814">

<img src="/posts/17399f0c/17399f0c/IMG_1812.jpg" class="" title="IMG_1812">

<img src="/posts/17399f0c/17399f0c/IMG_1818.jpg" class="" title="IMG_1818">

<img src="/posts/17399f0c/17399f0c/IMG_1819.jpg" class="" title="IMG_1819">

<img src="/posts/17399f0c/17399f0c/IMG_1817.jpg" class="" title="IMG_1817">

<img src="/posts/17399f0c/17399f0c/IMG_1803.jpg" class="" title="IMG_1803">

<img src="/posts/17399f0c/17399f0c/IMG_1802.jpg" class="" title="IMG_1802">

<img src="/posts/17399f0c/17399f0c/IMG_1801.jpg" class="" title="IMG_1801">

<img src="/posts/17399f0c/17399f0c/IMG_1805.jpg" class="" title="IMG_1805">

<img src="/posts/17399f0c/17399f0c/IMG_1804.jpg" class="" title="IMG_1804">

<img src="/posts/17399f0c/17399f0c/IMG_1797.jpg" class="" title="IMG_1797"><img src="/posts/17399f0c/17399f0c/IMG_1800.jpg" class="" title="IMG_1800">

<img src="/posts/17399f0c/17399f0c/IMG_1798.jpg" class="" title="IMG_1798">

<img src="/posts/17399f0c/17399f0c/IMG_1799.jpg" class="" title="IMG_1799">

<p>每次看到文明的发展，我都会想到三体，汪淼玩的游戏，见证了一代代的文明兴衰，但是宇宙中的法则还是没变</p>
<p>每到一个城市，我都会在那边游玩，每个城市实际上是有着自己的一些文化特色的，当然，作为丝绸之路的一个主要城市，这边当然是也不会例外的，我拍了很多的照片</p>
<p>其中也是有着非常多的感想，见到干尸的那种对于生命的敬畏，那种情况真的是令我流连忘返，我试着和旁边的一位大叔交流一个叫木尸的东西，感觉大叔懂得好多呀，情不自禁，我好像是被带到了以前的那种状态，那里的东西见证了一个文明的发展和一个个鲜活的生命，这真的是非常的令人惊奇</p>
<p>我其实是不会拍照的，我只能按照我自己的理解，拍出自以为比较好的角度和自己觉得最重要的东西，那种值得记录的东西，以后不管到了哪里，只要拿出这些东西，就会充满美好的回忆？我之前看家里以前的照片，想起了小时候的玩具，真的令我不知道说什么好，只是感慨时间的回忆。我已经有十几年没有见到过我的叔叔了，想起了以前小时候，我问人家要零花钱，要到几块钱就可以开心一整天，要是在晚上，肯定会开心的睡不着，以前生活比较穷，我都会一直计划着明天买什么零食吃，就像这种情况的夜晚，我都会睡的非常开心，想起以前的事，未免有些心痛</p>
<p>看到那些干尸，更加敬畏生命，生命就是这样，说长也长，说短也短，我们可以把这段时间过得非常的快乐，可以把这段时间过得非常的难受，关键就是我们对待生活的态度</p>
<p>我对UI懂得并不是很多，我拍了一个视频，背景是关于下着的雪，一群骆驼在沙地上行走，那种感觉非常的唯美，还有我爷爷时期的各种家具，说实话，当时是我自己一个人参观的，我真想把爷爷叫过来一起参观，听听爷爷给我讲讲改革开放的故事，爷爷当过民兵，当过生产队长。那些我都没有经历过，我觉得那些还挺有意思的，我们真的是变化太大了，我们的技术，我们的社会，我们的亲戚朋友。</p>
<p>文明经历过这么多次的兴衰，这次的人类文明不知道能持续多久？ 人类过度开矿，过度释放二氧化碳，导致其他动物无家可归，我们应该何去何从？可持续发展战略，战略储备能源</p>
<p>想起了人类简史，一代代人为了生存，为了发展，都会努力扩大自己的势力范围，自古以来都是这样的，我们没有任何的办法</p>
<p>我喜欢把已有的知识了解在一起，试着总结出其中的规律，上次火车票买票的时候，就试着总结出车票放票出票的规律，但是对于火鸡和标靶上面的二维生物来说， 这种规律真的是非常的难以预测</p>
</body></html>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游玩</tag>
      </tags>
  </entry>
  <entry>
    <title>在大型项目中如何区分结构和组件</title>
    <url>/posts/15149.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="在大型项目中如何区分结构和组件"><a href="#在大型项目中如何区分结构和组件" class="headerlink" title="在大型项目中如何区分结构和组件"></a>在大型项目中如何区分结构和组件</h1><h2 id="面试官：说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？"><a href="#面试官：说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？" class="headerlink" title="面试官：说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？"></a>面试官：说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？</h2><img src="/posts/15149/15149/image-20221105170721137.png" class="" title="image-20221105170721137">

<h3 id="一、为什么要划分"><a href="#一、为什么要划分" class="headerlink" title="一、为什么要划分"></a>一、为什么要划分</h3><p>使用<code>vue</code>构建项目，项目结构清晰会提高开发效率，熟悉项目的各种配置同样会让开发效率更高</p>
<p>在划分项目结构的时候，需要遵循一些基本的原则：</p>
<span id="more"></span>

<ul>
<li>文件夹和文件夹内部文件的语义一致性</li>
<li>单一入口/出口</li>
<li>就近原则，紧耦合的文件应该放到一起，且应以相对路径引用</li>
<li>公共的文件应该以绝对路径的方式从根目录引用</li>
<li><code>/src</code> 外的文件不应该被引入</li>
</ul>
<h4 id="文件夹和文件夹内部文件的语义一致性"><a href="#文件夹和文件夹内部文件的语义一致性" class="headerlink" title="文件夹和文件夹内部文件的语义一致性"></a>文件夹和文件夹内部文件的语义一致性</h4><p>我们的目录结构都会有一个文件夹是按照路由模块来划分的，如<code>pages</code>文件夹，这个文件夹里面应该包含我们项目所有的路由模块，并且仅应该包含路由模块，而不应该有别的其他的非路由模块的文件夹</p>
<p>这样做的好处在于一眼就从 <code>pages</code>文件夹看出这个项目的路由有哪些</p>
<h4 id="单一入口-出口"><a href="#单一入口-出口" class="headerlink" title="单一入口/出口"></a>单一入口/出口</h4><p>举个例子，在<code>pages</code>文件夹里面存在一个<code>seller</code>文件夹，这时候<code>seller</code> 文件夹应该作为一个独立的模块由外部引入，并且 <code>seller/index.js</code> 应该作为外部引入 seller 模块的唯一入口</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 错误用法</span></span><br><span class="line"><span class="keyword">import</span> sellerReducer <span class="keyword">from</span> <span class="string">'src/pages/seller/reducer'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确用法</span></span><br><span class="line"><span class="keyword">import</span> { reducer <span class="keyword">as</span> sellerReducer } <span class="keyword">from</span> <span class="string">'src/pages/seller'</span></span><br></pre></td></tr></tbody></table></figure>

<p>这样做的好处在于，无论你的模块文件夹内部有多乱，外部引用的时候，都是从一个入口文件引入，这样就很好的实现了隔离，如果后续有重构需求，你就会发现这种方式的优点</p>
<h4 id="就近原则，紧耦合的文件应该放到一起，且应以相对路径引用"><a href="#就近原则，紧耦合的文件应该放到一起，且应以相对路径引用" class="headerlink" title="就近原则，紧耦合的文件应该放到一起，且应以相对路径引用"></a>就近原则，紧耦合的文件应该放到一起，且应以相对路径引用</h4><p>使用相对路径可以保证模块内部的独立性</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 正确用法</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.module.scss'</span></span><br><span class="line"><span class="comment">// 错误用法</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'src/pages/seller/index.module.scss'</span></span><br></pre></td></tr></tbody></table></figure>

<p>举个例子</p>
<p>假设我们现在的 seller 目录是在 <code>src/pages/seller</code>，如果我们后续发生了路由变更，需要加一个层级，变成 <code>src/pages/user/seller</code>。</p>
<p>如果我们采用第一种相对路径的方式，那就可以直接将整个文件夹拖过去就好，<code>seller</code> 文件夹内部不需要做任何变更。</p>
<p>但是如果我们采用第二种绝对路径的方式，移动文件夹的同时，还需要对每个 <code>import</code> 的路径做修改</p>
<h4 id="公共的文件应该以绝对路径的方式从根目录引用"><a href="#公共的文件应该以绝对路径的方式从根目录引用" class="headerlink" title="公共的文件应该以绝对路径的方式从根目录引用"></a>公共的文件应该以绝对路径的方式从根目录引用</h4><p>公共指的是多个路由模块共用，如一些公共的组件，我们可以放在<code>src/components</code>下</p>
<p>在使用到的页面中，采用绝对路径的形式引用</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 错误用法</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Input</span> <span class="keyword">from</span> <span class="string">'../../components/input'</span></span><br><span class="line"><span class="comment">// 正确用法</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Input</span> <span class="keyword">from</span> <span class="string">'src/components/input'</span></span><br></pre></td></tr></tbody></table></figure>

<p>同样的，如果我们需要对文件夹结构进行调整。将 <code>/src/components/input</code> 变成 <code>/src/components/new/input</code>，如果使用绝对路径，只需要全局搜索替换</p>
<p>再加上绝对路径有全局的语义，相对路径有独立模块的语义</p>
<h4 id="src-外的文件不应该被引入"><a href="#src-外的文件不应该被引入" class="headerlink" title="/src 外的文件不应该被引入"></a>/src 外的文件不应该被引入</h4><p><code>vue-cli</code>脚手架已经帮我们做了相关的约束了，正常我们的前端项目都会有个<code>src</code>文件夹，里面放着所有的项目需要的资源，<code>js</code>,<code>css</code>, <code>png</code>, <code>svg</code> 等等。<code>src</code> 外会放一些项目配置，依赖，环境等文件</p>
<p>这样的好处是方便划分项目代码文件和配置文件</p>
<h3 id="二、目录结构"><a href="#二、目录结构" class="headerlink" title="二、目录结构"></a>二、目录结构</h3><p>单页面目录结构</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">project</span><br><span class="line">│  .<span class="property">browserslistrc</span></span><br><span class="line">│  .<span class="property">env</span>.<span class="property">production</span></span><br><span class="line">│  .<span class="property">eslintrc</span>.<span class="property">js</span></span><br><span class="line">│  .<span class="property">gitignore</span></span><br><span class="line">│  babel.<span class="property">config</span>.<span class="property">js</span></span><br><span class="line">│  package-lock.<span class="property">json</span></span><br><span class="line">│  package.<span class="property">json</span></span><br><span class="line">│  <span class="variable constant_">README</span>.<span class="property">md</span></span><br><span class="line">│  vue.<span class="property">config</span>.<span class="property">js</span></span><br><span class="line">│  yarn-error.<span class="property">log</span></span><br><span class="line">│  yarn.<span class="property">lock</span></span><br><span class="line">│</span><br><span class="line">├─public</span><br><span class="line">│      favicon.<span class="property">ico</span></span><br><span class="line">│      index.<span class="property">html</span></span><br><span class="line">│</span><br><span class="line">|-- src</span><br><span class="line">    |-- components</span><br><span class="line">        |-- input</span><br><span class="line">            |-- index.<span class="property">js</span></span><br><span class="line">            |-- index.<span class="property">module</span>.<span class="property">scss</span></span><br><span class="line">    |-- pages</span><br><span class="line">        |-- seller</span><br><span class="line">            |-- components</span><br><span class="line">                |-- input</span><br><span class="line">                    |-- index.<span class="property">js</span></span><br><span class="line">                    |-- index.<span class="property">module</span>.<span class="property">scss</span></span><br><span class="line">            |-- reducer.<span class="property">js</span></span><br><span class="line">            |-- saga.<span class="property">js</span></span><br><span class="line">            |-- index.<span class="property">js</span></span><br><span class="line">            |-- index.<span class="property">module</span>.<span class="property">scss</span></span><br><span class="line">        |-- buyer</span><br><span class="line">            |-- index.<span class="property">js</span></span><br><span class="line">        |-- index.<span class="property">js</span></span><br></pre></td></tr></tbody></table></figure>

<p>多页面目录结构</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">my-vue-<span class="attr">test</span>:.</span><br><span class="line">│  .<span class="property">browserslistrc</span></span><br><span class="line">│  .<span class="property">env</span>.<span class="property">production</span></span><br><span class="line">│  .<span class="property">eslintrc</span>.<span class="property">js</span></span><br><span class="line">│  .<span class="property">gitignore</span></span><br><span class="line">│  babel.<span class="property">config</span>.<span class="property">js</span></span><br><span class="line">│  package-lock.<span class="property">json</span></span><br><span class="line">│  package.<span class="property">json</span></span><br><span class="line">│  <span class="variable constant_">README</span>.<span class="property">md</span></span><br><span class="line">│  vue.<span class="property">config</span>.<span class="property">js</span></span><br><span class="line">│  yarn-error.<span class="property">log</span></span><br><span class="line">│  yarn.<span class="property">lock</span></span><br><span class="line">│</span><br><span class="line">├─public</span><br><span class="line">│      favicon.<span class="property">ico</span></span><br><span class="line">│      index.<span class="property">html</span></span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">    ├─apis <span class="comment">//接口文件根据页面或实例模块化</span></span><br><span class="line">    │      index.<span class="property">js</span></span><br><span class="line">    │      login.<span class="property">js</span></span><br><span class="line">    │</span><br><span class="line">    ├─components <span class="comment">//全局公共组件</span></span><br><span class="line">    │  └─header</span><br><span class="line">    │          index.<span class="property">less</span></span><br><span class="line">    │          index.<span class="property">vue</span></span><br><span class="line">    │</span><br><span class="line">    ├─config <span class="comment">//配置（环境变量配置不同passid等）</span></span><br><span class="line">    │      env.<span class="property">js</span></span><br><span class="line">    │      index.<span class="property">js</span></span><br><span class="line">    │</span><br><span class="line">    ├─contant <span class="comment">//常量</span></span><br><span class="line">    │      index.<span class="property">js</span></span><br><span class="line">    │</span><br><span class="line">    ├─images <span class="comment">//图片</span></span><br><span class="line">    │      logo.<span class="property">png</span></span><br><span class="line">    │</span><br><span class="line">    ├─pages <span class="comment">//多页面vue项目，不同的实例</span></span><br><span class="line">    │  ├─index <span class="comment">//主实例</span></span><br><span class="line">    │  │  │  index.<span class="property">js</span></span><br><span class="line">    │  │  │  index.<span class="property">vue</span></span><br><span class="line">    │  │  │  main.<span class="property">js</span></span><br><span class="line">    │  │  │  router.<span class="property">js</span></span><br><span class="line">    │  │  │  store.<span class="property">js</span></span><br><span class="line">    │  │  │</span><br><span class="line">    │  │  ├─components <span class="comment">//业务组件</span></span><br><span class="line">    │  │  └─pages <span class="comment">//此实例中的各个路由</span></span><br><span class="line">    │  │      ├─amenu</span><br><span class="line">    │  │      │      index.<span class="property">vue</span></span><br><span class="line">    │  │      │</span><br><span class="line">    │  │      └─bmenu</span><br><span class="line">    │  │              index.<span class="property">vue</span></span><br><span class="line">    │  │</span><br><span class="line">    │  └─login <span class="comment">//另一个实例</span></span><br><span class="line">    │          index.<span class="property">js</span></span><br><span class="line">    │          index.<span class="property">vue</span></span><br><span class="line">    │          main.<span class="property">js</span></span><br><span class="line">    │</span><br><span class="line">    ├─scripts <span class="comment">//包含各种常用配置，工具函数</span></span><br><span class="line">    │  │  map.<span class="property">js</span></span><br><span class="line">    │  │</span><br><span class="line">    │  └─utils</span><br><span class="line">    │          helper.<span class="property">js</span></span><br><span class="line">    │</span><br><span class="line">    ├─store <span class="comment">//vuex仓库</span></span><br><span class="line">    │  │  index.<span class="property">js</span></span><br><span class="line">    │  │</span><br><span class="line">    │  ├─index</span><br><span class="line">    │  │      actions.<span class="property">js</span></span><br><span class="line">    │  │      getters.<span class="property">js</span></span><br><span class="line">    │  │      index.<span class="property">js</span></span><br><span class="line">    │  │      mutation-types.<span class="property">js</span></span><br><span class="line">    │  │      mutations.<span class="property">js</span></span><br><span class="line">    │  │      state.<span class="property">js</span></span><br><span class="line">    │  │</span><br><span class="line">    │  └─user</span><br><span class="line">    │          actions.<span class="property">js</span></span><br><span class="line">    │          getters.<span class="property">js</span></span><br><span class="line">    │          index.<span class="property">js</span></span><br><span class="line">    │          mutation-types.<span class="property">js</span></span><br><span class="line">    │          mutations.<span class="property">js</span></span><br><span class="line">    │          state.<span class="property">js</span></span><br><span class="line">    │</span><br><span class="line">    └─styles <span class="comment">//样式统一配置</span></span><br><span class="line">        │  components.<span class="property">less</span></span><br><span class="line">        │</span><br><span class="line">        ├─animation</span><br><span class="line">        │      index.<span class="property">less</span></span><br><span class="line">        │      slide.<span class="property">less</span></span><br><span class="line">        │</span><br><span class="line">        ├─base</span><br><span class="line">        │      index.<span class="property">less</span></span><br><span class="line">        │      style.<span class="property">less</span></span><br><span class="line">        │      <span class="keyword">var</span>.<span class="property">less</span></span><br><span class="line">        │      widget.<span class="property">less</span></span><br><span class="line">        │</span><br><span class="line">        └─common</span><br><span class="line">                index.<span class="property">less</span></span><br><span class="line">                reset.<span class="property">less</span></span><br><span class="line">                style.<span class="property">less</span></span><br><span class="line">                transition.<span class="property">less</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>项目的目录结构很重要，因为目录结构能体现很多东西，怎么规划目录结构可能每个人有自己的理解，但是按照一定的规范去进行目录的设计，能让项目整个架构看起来更为简洁，更加易用</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://juejin.cn/post/6844904129186234381#heading-0">https://juejin.cn/post/6844904129186234381#heading-0</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/89693668">https://zhuanlan.zhihu.com/p/89693668</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>如何区分结构和组件</tag>
      </tags>
  </entry>
  <entry>
    <title>声明式框架和命令式框架</title>
    <url>/posts/11819.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="声明式框架和命令式框架"><a href="#声明式框架和命令式框架" class="headerlink" title="声明式框架和命令式框架"></a>声明式框架和命令式框架</h1><p>最近读了霍春阳大佬的《vue.js设计与实现》， 里面提到了有关声明式框架和命令式框架的一些概念， 根据它的介绍， 加上我网上找的资料， 在我自己理解的基础上， 写下了这篇文章</p>
<h2 id="声明式框架"><a href="#声明式框架" class="headerlink" title="声明式框架"></a>声明式框架</h2><p>早年间流行的 jQuery 就是典型的命令式框架。命令式框架的一大特点就是关注过程。例如，我们把下面这段话翻译成对应的代码：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">- 获取 id 为 app 的 div 标签</span><br><span class="line">- 它的文本内容为 hello world</span><br><span class="line">- 为其绑定点击事件</span><br><span class="line">- 当点击时弹出提示： ok</span><br></pre></td></tr></tbody></table></figure>

<p>对应的代码为： </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$('#app')  // 获取 div</span><br><span class="line">	.text('hello world')  // 设置文本内容</span><br><span class="line">	.on('click', () =&gt; { alert('ok') }) //绑定单击事件</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，自然语言描述能够与代码产生一一对应的关系，代码本身描述的是“做事的过程”，这符合我们的逻辑直觉。那么，什么是声明式框架呢？与命令式框架更加关注过程不同，声明式框架更加关注结果。结合 Vue.js，我们来看看如何实现上面自然语言描述的功能：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">01 &lt;div @click="() =&gt; alert('ok')"&gt;hello world&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>这段类 HTML 的模板就是 Vue.js 实现如上功能的方式。可以看到，我们提供的是一个“结果”，至于如何实现这个“结果”，我们并不关心，这就像我们在告诉 Vue.js：“嘿，Vue.js，看到没，我要的就是一个 div，文本内容是 hello world，它有个事件绑定，你帮我搞定吧。”至于实现该“结果”的过程，则是由 Vue.js 帮我们完成的。换句话说，Vue.js 帮我们封装了过程。因此，我们能够猜到 Vue.js 的内部实现一定是命令式的，而暴露给用户的却更加声明式。</p>
<p><strong>简单总结</strong>：命令式更加关注过程，而声明式更加关注结果。命令式在理论上可以做到极致优化，但是用户要承受巨大的心智负担；而声明式能够有效减轻用户的心智负担，但是在性能上有一定的牺牲。</p>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>声明式框架和命令式框架</tag>
      </tags>
  </entry>
  <entry>
    <title>好用的七个JavaScript库</title>
    <url>/posts/19496.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="您可以在下一个项目中使用的7个有用的-JavaScript-库"><a href="#您可以在下一个项目中使用的7个有用的-JavaScript-库" class="headerlink" title="您可以在下一个项目中使用的7个有用的 JavaScript 库"></a>您可以在下一个项目中使用的7个有用的 JavaScript 库</h1><img src="/posts/19496/19496/image-20221109185755478.png" class="" title="image-20221109185755478">

<p>有一句谚语“你不必重新发明轮子”。工具库就是最好的例子。它可以帮助您以简单的方式编写复杂且耗时的功能。根据我的观点，一个好的项目会使用一些最好的库</p>
<p>我不认为 JavaScript 需要任何介绍。它几乎是用途最广泛的编程语言之一。在这里，我编译了7个有用的 JavaScript 库，它们将在您的开发之旅中为您提供帮助。</p>
<span id="more"></span>

<h2 id="1-date-fns"><a href="#1-date-fns" class="headerlink" title="1. date-fns"></a>1. date-fns</h2><img src="/posts/19496/19496/image-20221109190150325.png" class="" title="image-20221109190150325">

<p>这是获星最高的工具库之一，有超过3万颗星星。处理日期是开发人员的常见任务之一，此库将帮助您完成此任务。它为在浏览器和 Node.js 中操作 JavaScript 日期提供了最全面、最简单和最一致的工具集。它包含了很多特性，比如适用于所有场合的200 + 函数，可以与 Webpack、 Browserify、 Rollup 或者 tree-shaking 一起工作，支持 Flow 和 TypeScript 等等。</p>
<h2 id="2-Ladda"><a href="#2-Ladda" class="headerlink" title="2. Ladda"></a>2. Ladda</h2><img src="/posts/19496/19496/image-20221109190515949.png" class="" title="image-20221109190515949">

<p>在加载数据时显示进度条是获得良好用户体验的常用方法之一。这个库提供了一个内置加载指示器的按钮，有效地弥合了动作和反馈之间的差距。它主要用于在用户提交表单时给予即时反馈，而不是让他们在浏览器完成任务时感到困惑。它在 GitHub 上有超过75000颗星星。</p>
<h2 id="3-i18next"><a href="#3-i18next" class="headerlink" title="3. i18next"></a>3. i18next</h2><img src="/posts/19496/19496/image-20221109190552934.png" class="" title="image-20221109190552934">

<p>如果你想添加国际化到你的应用程序，那么这是一个很好的资源。这是一个非常流行的浏览器或任何其他 javascript 环境的国际化框架(例如。Node.js，Deno).它包括许多特性，如可选缓存、用户语言检测、正确的多元化、灵活的后端连接等等。它在 GitHub 上有超过65000颗星星。</p>
<h2 id="4-URI-js"><a href="#4-URI-js" class="headerlink" title="4. URI.js"></a>4. URI.js</h2><img src="/posts/19496/19496/image-20221109190642636.png" class="" title="image-20221109190642636">

<p>这是一个用于处理 URL 的 javascript 库。它提供了一个“ jQuery-style”API (Fluent Interface，Method Chaining)来读写所有常规组件和许多方便的方法，比如 .<a href="http://medialize.github.io/URI.js/docs.html#accessors-directory">directory</a>()和 .<a href="http://medialize.github.io/URI.js/docs.html#accessors-directory">directory</a>()。虽然这个库提供了一个 jQuery 插件，但是你不需要 jQuery 来使用它。它在 GitHub 上有超过6000颗星星。</p>
<h2 id="5-Loglevel"><a href="#5-Loglevel" class="headerlink" title="5. Loglevel"></a>5. Loglevel</h2><img src="/posts/19496/19496/image-20221109190820547.png" class="" title="image-20221109190820547">

<p>我认为日志记录是调试应用程序最常用的方法之一。这个库用基于级别的日志记录和过滤代替了 console.log ()并更友好的适配了日志记录和过滤，而且没有任何控制台的缺点。它包括一些特性，比如在给定级别记录事件(跟踪/调试/信息/警告/错误)到控制台对象，按级别筛选日志记录，等等。它在 GitHub 上有超过2000颗星星。</p>
<h2 id="6-diff2html"><a href="#6-diff2html" class="headerlink" title="6. diff2html"></a>6. diff2html</h2><img src="/posts/19496/19496/image-20221109191042589.png" class="" title="image-20221109191042589">

<p>顾名思义，这是一个 Diff 解析器库和一个漂亮的 HTML 生成器。每个差异都提供了代码更改的全面可视化，帮助开发人员识别问题并更好地理解更改。它包括诸如支持 git 和统一差异、逐行、并行差异、类似 GitHub 的视觉风格等特性。它在 GitHub 上有超过2000颗星星。</p>
<h2 id="7-TimelineJS3"><a href="#7-TimelineJS3" class="headerlink" title="7. TimelineJS3"></a>7. TimelineJS3</h2><img src="/posts/19496/19496/image-20221109191128524.png" class="" title="image-20221109191128524">

<p>这是一个工具，旨在帮助人们与最低限度的技术技能告诉丰富，动态的故事在网络上。大多数人会使用官方的创作工具来创建时间线，然后使用在创作过程结束时提供的一小段 HTML 代码来嵌入他们的创作。它在 GitHub 上有超过25000颗星星。</p>
</body></html>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js库</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写出一个人人爱的组件？</title>
    <url>/posts/f2e2f71d.html</url>
    <content><![CDATA[<html><head></head><body><p>前端中， 随着技术的迭代更新， 组件化的思想已经成为一种浪潮， 如何封装一个人人都爱的组件呢？</p>
<span id="more"></span>

<ol>
<li>功能是否满足需求：用户对组件的需求是使用它来完成某些功能，因此组件设计的功能必须满足用户的需求。如果组件不能满足用户的需求，就无法达到好的效果。</li>
<li>性能是否优秀：组件的各种操作都需要时间和资源，因此组件的性能表现直接决定了用户体验的好坏。优秀的组件需要具备快速启动、快速响应、不会造成页面卡顿等性能要求。</li>
<li>可访问性是否良好：组件应该能够满足不同用户群体的使用需求，比如视觉障碍者、听觉障碍者等。因此，组件的可访问性也是评价好坏的一个重要标准。</li>
<li>易用性是否高：良好的组件应该简单易用，具有清晰的交互和界面视觉设计。对于用户而言，使用组件的入门门槛应该尽量低，才能真正获得好的使用体验。</li>
<li>可扩展性是否好：随着项目的深入开发，组件也需要适应不断变化的需求。组件的可扩展性就决定了我们在二次开发中是否能够快速地对其进行应用。因此，良好的组件必须具备较好的可扩展性，方便开发者进行二次开发和维护。</li>
<li>代码质量：良好的组件需要保持代码清晰、结构合理、易于维护等标准，这需要组件程序员在开发中始终遵循编码规范和最佳实践。</li>
<li>兼容性：组件需要能够兼容各种浏览器、不同版本的操作系统等，这是保证良好用户体验的重要因素之一。</li>
<li>UI 设计与交互是否符合用户心理：一个好的组件应该不光是能提供完整的、正确的功能，而且还应该从人机交互的角度来考虑用户体验。（比如：需要简洁、直观易用，主次分明、兼容性良好等）</li>
</ol>
<p>总之，判断一个组件的好坏要考虑多个方面。只有当组件在每个方面表现优秀的时候，才能真正被认定为好的组件。</p>
</body></html>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>如何写出一个人人爱的组件</tag>
      </tags>
  </entry>
  <entry>
    <title>如何将一辈子活成N辈子</title>
    <url>/posts/59654.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="如何将一辈子活成N辈子"><a href="#如何将一辈子活成N辈子" class="headerlink" title="如何将一辈子活成N辈子"></a>如何将一辈子活成N辈子</h1><blockquote>
<p>日子过得真快，—— 尤其对于中年以后的人，十年八年都好像是指缝间的事。可是对于年轻人，三年五载就可以是一生一世……</p>
<p>　　—— 张爱玲《半生缘》第一段</p>
</blockquote>
<img src="/posts/59654/59654/another-life-01.jpg" class="" title="人生逆天技能：如何扭曲主观时空，一辈子活成 N 辈子">


<h2 id="一、为何我们感觉时间越过越快？"><a href="#一、为何我们感觉时间越过越快？" class="headerlink" title="一、为何我们感觉时间越过越快？"></a>一、为何我们感觉时间越过越快？</h2><p>　　我们每个人，都会有这样的感受：小时候总觉得时间特别漫长。</p>
<p>　　—— 每个漫长的学年，要经历两个学期，两次长假，两次期中考试，两次期末考试，每月有测验，每周有考核，成绩起起伏伏，状态时好有坏，有时候被当成学霸典型接受表扬，有时候又因调皮被请家长打得皮开肉绽。</p>
<span id="more"></span>

<p>　　如果说，小学的时间，是一周一周的过；那么高中大学，时间一学期一学期的过；而工作结婚生子，时间则是一年一年地过；至于到了五六十岁，十年前的事情，仍历历在目。想起了我当年一个人去上海， 什么都是一个人， 一个人吃饭， 一个人睡觉······</p>
<p>　　为什么我们会有这样的时间观感？在网上搜到一些讲<strong>主观时空扭曲</strong>的文章，其中《<a href="http://www.sohu.com/a/120826135_355048">感知时间的对数效应</a>》一文用<strong>记忆增量</strong>来解释，很有道理：</p>
<blockquote>
<p>　　五岁的时候人的记忆有五年，这时候到六岁时，过了一年，记忆增加五分之一，六岁到七岁时，记忆增加了六分之一。以此类推，到了二十岁的时候，多过一年，记忆只增大二十分之一。这一年虽然时光没变，但是参照物变了。所以大家就觉得时间变得快了。可能等你到了60岁的时候，过一年记忆只增加了六十分之一，那时觉得时间过得更快了。</p>
<p>　　在相对参照物改变之下，同时记忆的增量变缓（变缓的原因就是以前我们128MB内存来处理的问题，现在可以用8G来处理了，很多事情变得不再有难度，人变得轻松而乐于去做重复简单的事），导致了我们觉得时间过的很快。</p>
<p>　　时间当然是客观不变的，一天24小时，一小时60分，但每一个人在不同的年龄体验到的时间并不是相同的，因为我们感知的时间是我们实际生命长短的一部分。</p>
</blockquote>
<p>　　从漫长而又短暂的人生旅程来说，不同年龄体验到的主观时间并不相同，是很有必要的：</p>
<ul>
<li>对青少年来说，年轻，就是他们最大的财富，他们可以无忧无虑地成长，从从容容地学习各种新知识；</li>
<li>对成年人来说，时间不再等人，所以珍惜光阴，不虚度每一天，变得更重要。</li>
</ul>
<p>　　不管怎么活，人的生命只有一次。如果能够扭曲主观时空，将主观时间放缓，那么，我们岂不是能比别人多活一辈子甚至 N 辈子？</p>
<img src="/posts/59654/59654/another-life-08.jpg" class="" title="如何扭曲主观时空，将主观时间放缓？">


<h2 id="二、如何扭曲主观时空，比别人多活更长的时间？"><a href="#二、如何扭曲主观时空，比别人多活更长的时间？" class="headerlink" title="二、如何扭曲主观时空，比别人多活更长的时间？"></a>二、如何扭曲主观时空，比别人多活更长的时间？</h2><p>　　如何将时间过得不那么短？其实我们每个人已经有这样的体会了：</p>
<ul>
<li>如果有天，我们懒癌发作，睡到十点才起，抱着手机慢悠悠地坐在马桶上刷下微信，再晃悠悠地去楼下梭碗粉当早中餐，下午躺沙发上拿起手机或遥控器刷美剧逛网店追网络小说，再睡一觉，就到了晚上，一整天没有任何新记忆产生，仿佛这一天不存在，一瞬间就过去了。</li>
<li>如果同样是早上十点起来，如果吃个早餐后出门，陪孩子去图书馆借书看书，下午同样睡个午觉，醒来后再去游泳或打球，晚上再约个朋友聚聚，喝喝茶聊聊天。虽然这一天同样是看起来比较琐碎，但睡前回想这一天，就不会觉得那么短了。</li>
</ul>
<p>　　用<strong>记忆增量理论</strong>来解释，我们在成年后的工作和生活，都是在简单重复，大脑中的总数据没有像儿时那样处于迅猛增长的阶段，大脑处理今天的24小时，都是几年前就存在大脑里的东西，主观上感受到的“新东西”当然就少，而体验“新东西”恰恰是放慢主观时间的命门。</p>
<p>　　琐碎的生活，忙碌的工作，这是我们每个人的<strong>记忆熟悉区</strong>。记忆熟悉区是时间黑洞，会不断消耗、吞噬你的时间与生命。</p>
<p>　　在前面的第二个例子中，我们觉得时间没那么短，是因为我们走了不同的路，去了不同的地方，见了不同的人，新的记忆产生了。</p>
<p>　　<strong>如果，我们走更长的路，去更远的远方呢？</strong></p>
<h2 id="三、旅行能让你延续生命，让你活的更长久"><a href="#三、旅行能让你延续生命，让你活的更长久" class="headerlink" title="三、旅行能让你延续生命，让你活的更长久"></a>三、旅行能让你延续生命，让你活的更长久</h2><p>　　没错，远方的旅行能让你延续生命，让你活得更长久。这是各路奢侈大牌化妆品与眼花缭乱的药物、保健品，甚至最新粉墨登场争议不断的“换头手术”所达不到的疗效。</p>
<p>　　因为，<strong>旅行给你延续的生命，是青春的生命，是灵魂打磨后的生命</strong>，而不是苟留残喘时的生命。</p>
<p>　　日常的人生，有时候就象被设计好的游戏，各种元素组合循环，让我们处于慢性应激的“记忆熟悉区”中，难以逃出。</p>
<p>　　古人说：“读万卷书不如行万里路”。而贩卖情怀的大V们则将“生活不止眼前的苟且，还有诗和远方的田野”谱成了歌曲传唱。如果你走出家庭或者办公室，去陌生的国家旅行一个月甚至更长的时间，你就会发现，这段时间，并没有象朝九晚五的生活那样，在你的记忆中消失不见，不会过完星期三就感觉一周已经结束了；而是给我们提供了学习不同地域、不同民族、不同文化、不同生存状态的机会，让我们从日常生活中解脱出来，从负面情绪中抽离出来，与自己对话，对自己的人生进行重新思考。</p>
<p>　　</p>
<p>　　—— 并不是只有旅行，才会有这样的效果。</p>
<h2 id="四、管理好个人黄金时间"><a href="#四、管理好个人黄金时间" class="headerlink" title="四、管理好个人黄金时间"></a>四、管理好个人黄金时间</h2><p>　　如果你象一个救火队长或打地鼠专家一样，深陷于繁琐的工作与生活的泥沼，所谓的旅行，不过是一种奢望，那么，你需要改造自己的工作系统，掌控你的<strong>个人黄金时间</strong>。</p>
<img src="/posts/59654/59654/another-life-13.jpg" class="" title="你是打地鼠专家吗？">


<p>　　萨姆·卡彭特的《用系统来工作 Work The System》一书，在讲实施小细节的时候，谈到了这个黄金时间这个概念。黄金时间分为两种：</p>
<ul>
<li>第一种叫<strong>生理黄金时间</strong>(Biological Prime Time, BPT)。是你每天精力最充沛的时间段。</li>
<li>第二种是<strong>机械黄金时间</strong>(Mechanical Prime Time, MPT)。是你针对时间的利用。</li>
</ul>
<p>　　<strong>生理黄金时间很好理解，就是一天中，效率最好、精力最充沛的时间段</strong>。我们一天24小时内，仅有几个小时能发挥最高效率。例如我曾是夜猫族，只有晚上十点以后才最有效率；而最近几年女儿上学后，调整了作息，早晨和上午的时间则最有效率。到了下午，如果没有睡午觉，用长沙话说，就象被鬼打晕了一样。所以一般都在下午处理不太重要或不太费脑子的事务; 生活中需要出门办理的种种琐事、聚会、健身、锻炼，都安排在午睡之后的下午。</p>
<p>　　而机械黄金时间从字面上不太好理解。首先我们要对<strong>真正的生意</strong>进行严格的定义，才能定义机械黄金时间。一个人，要么是老板，要么不是老板；一个人要么拥有生意，要么为生意打工。</p>
<p>　　在真正的生意里，如果你只是制造产品或者提供服务的实际工作者，那么你只是在打工，你拥有是职业，而不是生意。职业的关键指标就是：人必须到场，而生意则不需要。医生、律师、跨国企业的经理人、演员、程序员，这都不是生意，只是职业。——当然，他们都是很棒的职业。而生意，则是拥有一套自行运转的系统，你无需到场，仍然可以创造利润。</p>
<p>　　<strong>机械黄金时间，是指花在为实现自动运转系统而进行的创造性工作的时间</strong>，而不是为生意打工或者处理日常事务的时间。</p>
<p>　　水库欧神 yevon_ou 曾在文章里说过一个例子：上班族，老板打电话过来，要他第二天上午到办公室谈升职加工资的事；而另一边，某某小区出了一套笋盘，明天上午可以看房。小白领该如何选择？ 欧神说：选择看房。如果用机械黄金时间的原理来解释，则很好理解：老板加薪，这只不过是一份职业；而投资房产，他便拥有了生意。</p>
<p>　　用好生理黄金时间和机械黄金时间，我们就可以摆脱“记忆熟悉区”，从平庸毫无满足感的琐碎中抽身出来，不用再当一名救火队长或打地鼠专家，不用再疲于应付无休无止的燃眉之急。同样是一天，但我们从此拥有了更多的个人时间，人生的长度从此不同。</p>
<h2 id="五、花钱购买时间"><a href="#五、花钱购买时间" class="headerlink" title="五、花钱购买时间"></a>五、花钱购买时间</h2><p>　　年少的时候，时间是不值钱的。年轻就是他们最大的财富。但是随着年龄的增长，感知时间的对数效应导致我们感觉时间越过越快。为了应付这个问题，我们还有一招：</p>
<p>　　<strong>花钱买时间</strong>。</p>
<p>　　是的，最值钱最硬通的货币，其实不是美元黄金，也不是比特币以太币，而是时间。</p>
<p>　　<strong>时间才是最硬的货币</strong>。</p>
<p>　　当你明白了这点，你就会愿意花钱在提高效率、节省时间的工具、课程、事物之上。说得直白一点：花钱买时间，本质就是花钱买别人的寿命。</p>
<p>　　当你明白了这点，你就会更有动力提高自己的赚钱能力，赚更多的钱，然后用钱尽可能的买别人的时间；然后将自己的时间，更多的用在对自己有意义的人和事之上。继往的空余时间，虽然“空余”，但绝不再“空虚”了。</p>
<img src="/posts/59654/59654/another-life-17.jpg" class="" title="花钱购买别人的时间">


<h2 id="六、尝试不同的角色或领域"><a href="#六、尝试不同的角色或领域" class="headerlink" title="六、尝试不同的角色或领域"></a>六、尝试不同的角色或领域</h2><blockquote>
<p>　　Some people die at 25 and aren’t buried until 75. 有的人25岁就死了,只是到75岁才埋葬。</p>
<p>　　——本杰明·富兰克林</p>
</blockquote>
<p>　　我们经常看到报道：有些人，一生只做一件事，承载住岁月的反复，孤独而勇敢地坚持着。这样的人，做着自己喜欢的事，他们是幸福的。</p>
<p>　　然而，从另一个角度来说：人生苦短，为何不在不同的领域尝试不同的角色？ 一辈子的时间很短，100年也不过是 36524 天(或36525天)，但如果我们在有限的生命里，将我们每个不同阶段的角色或事业，做到自己能力的极致，获取更可能多的美好体验，那岂不是相当于比别人多活了一辈子或者N辈子？</p>
<p>　　那么，成为一个领域的专家，将一份新的事业或职业做到极致，需要多久的时间？</p>
<p>　　2009年左右，丹尼尔·科伊尔写了本《一万小时天才理论》的书，马尔科姆·格拉德韦尔写了本《异类》，其核心都是<strong>一万小时定律</strong>：“人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。<strong>一万小时的锤炼是任何人从平凡变成世界级大师的必要条件</strong>。”</p>
<p>　　一万小时是多长的时间呢？如果每天专注4小时，那么就是 2500天，约 6.84年。2016年李笑来出了一本书《七年就是一辈子》，我看了一下简介，没有买。因为他讲的，其实不过是 10000小时的理论的升级，很好理解：</p>
<p>　　每个人从零开始，到成为一个领域的专家，需要七年的时间。如果你从11岁开始，活到88岁，那么，你有11次机会成为某个领域的专家。</p>
<p>　　按照7年一次的机会，你有11次生命。</p>
<p>　　而许多人，<strong>死于25岁，葬于75岁</strong>，想想挺惊悚的。为什么有些人25岁的时候，就可以看到75岁的死亡？因为他放弃了理想，放弃了学习，习惯了平庸。</p>
<p>　　问一问自己：我们究竟是活了365天，还是活了1天，重复了364遍？</p>
<h2 id="七、多活几辈子应该是我们追求的生活方式"><a href="#七、多活几辈子应该是我们追求的生活方式" class="headerlink" title="七、多活几辈子应该是我们追求的生活方式"></a>七、多活几辈子应该是我们追求的生活方式</h2><p>　　想要多活几辈子，其实还有许多方法。例如，多与阳光的人、优秀的人、有趣的人做朋友，你会懂得尊重他人的时间，同时也会让自己变得优秀。又例如，多读书，思考一下内心的信仰，想一想为何而活，—— 我们的第一次生命，大多是为他人而活，为金钱而活；想明白了自己为何而来，为谁而活，那么你所拥有的，则不只是一生。</p>
<p>　　<strong>多活几辈子应该是我们追求的生活方式</strong>。</p>
<p>　　这是最好的时代。</p>
<p>　　虽然我们会在岁月的流逝中走向衰老，但不管现在是青春年少，还是垂垂暮年，只要远离环形跑道，向上攀登，都有机会成为不一样的自己。</p>
<p>　　想拥有比别人多出几辈子的生活，那就开始行动吧。</p>
<img src="/posts/59654/59654/another-life-16.jpg" class="" title="想拥有比别人多出几辈子的生活，那就开始行动吧">

<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>·<a href="https://www.xiaohui.com/weekly">https://www.xiaohui.com/weekly</a></p>
<p>·<a href="https://www.sohu.com/a/120826135_355048">https://www.sohu.com/a/120826135_355048</a></p>
</body></html>]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>如何将一辈子活成N辈子</tag>
      </tags>
  </entry>
  <entry>
    <title>如何应对信息污染</title>
    <url>/posts/7156f191.html</url>
    <content><![CDATA[<html><head></head><body><h3 id="如何才能远离信息污染？"><a href="#如何才能远离信息污染？" class="headerlink" title="如何才能远离信息污染？"></a>如何才能远离信息污染？</h3><p>午夜的火车或长途汽车上， 你和其他乘客正在昏昏欲睡，突然传来嘶哑而又亢奋的声音， “某某某地特产， 买不了吃亏， 买不了上当”， 顿时所有乘客睡意全无， 带着赞美的目光看向这个人</p>
<span id="more"></span>

<p>这类信息对你有用吗？我想对于大部分人来说是没有任何作用的， 对你有用的信息，比如乘务员通知大家下一站叫什么，前方要过隧道等等。</p>
<p>我的爷爷70多岁， 他很少玩手机，每天最多半小时，都是晚上睡觉前和子女聊天， 平时他获取信息的主要方式就是和朋友在下棋的过程中聊天。</p>
<p>到我们这一代的信息获取方式发生了截然不同的变化</p>
<p>现代的互联网传播信息的速度远远高于传统的纸质的信息传送方式，现代人每天都要接触和处理大量信息， 这些信息对我们都是有用的吗？</p>
<figure class="highlight txt"><table><tbody><tr><td class="code"><pre><span class="line">我们在粪便般的信息环境里生存                 -----宾斯法尼亚大学的传播学博士方可成</span><br></pre></td></tr></tbody></table></figure>

<p>信息污染是指无用信息、劣质信息或有害信息渗透到信息资源中，对信息资源的收集、开发和利用造成干扰，影响信息传播的速度与效率，增加信息筛选、甄别的难度，信息污染中的有些信息还会对用户和国家产生危害</p>
<p>前一段时间， 我在下载软件的时候， 被流氓软件给支配了， 看似我打开了官网， 但那个就不是官网，于是我花了很长时间才解决掉了流氓软件</p>
<p>信息过载是指人们接受了过多信息，但却无法有效整合、组织及内化成自己需要的信息，以致影响到工作、学习和人际关系，我们每天都会在社交平台或短视频平台花费大量的时间来获取信息， 这些信息对我们有用吗？这些信息充斥着我们的大脑使我们无法专注， 注意力下降，到头来还是一种自嗨</p>
<p>随着 5G 技术的推广应用，我国行将进入“人 － 事 － 物”全面互联的万联时代。万联时代的网络信息环境有着更为混浊化的可能性。万联时代的网络更加智能化，智能化不仅能给社会成员带来诸多福祉，而且可能促长网络失范行为的智能性、隐秘性、多样性和严重性等</p>
<p>所以看来， 这种信息污染将来只会更严重</p>
<p>确实是这样，写出十篇研究不足的通用文章要比一篇深思熟虑的文章容易得多。比起分享一个链接或者编造一些东西，我们需要花费更多的工作和时间去核实错误的信息或者证明一个谎言是错误的。此外，自动化的工具和机器人使得生成垃圾邮件/劣质内容变得更加容易，搜索引擎很难区分哪些内容是丰富的、有用的。互联网的广告模式说到底还是一个错误。</p>
<p>参差不齐的内容水平， 眼花缭乱的排版， 发自内心地问一句： 编辑你写这些真的想要我看吗？他可能只是想要拿几块钱一篇地工资而已吧</p>
<p>中国网信网“执法督查”栏目自 2015 年 2 月 2 日到 2020 年 4 月 24 日公开发布多条对网站的执 法督查新闻，其中具有明确查处原因和执行方式 的新闻 38 条。从中可以看出，我国的网络信息环境即使在管控甚严的情况下仍然存在着某些污浊化现象。从网站角度讲，这些执法督查对象有门户网站、商业网站、娱乐网站以及搜索引擎、微博、 APP 等，涉及网站数量不少。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">我们已经把信息变成了某种形式的垃圾          ------美国学者尼尔·波斯特曼</span><br></pre></td></tr></tbody></table></figure>

<p>同样， 我们最常使用的微信也存在着信息污染。</p>
<p>随着微信功能的不断完善，它已经建构起多 节点的信息传播系统，每一个节点都是信息生产 者、传播者和接收者的随机切换，信息在这个场域能够实现大批量生产和病毒式传播，这些信息如潮水一般涌向用户，超出了他们的信息接受能力， 变成无用信息，造成信息污染。研究结果表明，即时通信、朋友圈和微信公众号是微信信息污染最严重的三个领域，且每个功能领域的污染形势各有不同。</p>
<p>即时通讯是微信最基础的功能，通过点对点的个人对话或者点对面的微信群交流，支持文字、 图片、语音、视频等多种形式的信息传递，是用户使用最多的微信功能，也是用户最易遭受信息污染的地方。微信群发功能将广告信息、节日祝福、 点赞邀请、诱导分享链接等信息发送给微信上的每一个好友，完成一次精准的点对面的传播；微信群更是让人不胜其烦，无关紧要的垃圾资讯，集体狂欢的表情包大战，低俗的搞笑视频，让微信群中有价值的通知、公告淹没在信息的洪流中，增加了群成员获取信息的难度</p>
<p>此外，著名的“150 定律”认为，人类智力将允许人类拥有稳定社交网络的人数是150左右，一 旦圈子超过这个理想模式，人们大脑处理信息的能力就会下降，会感到无所适从，成员之间的关系就会淡化。调查结果显示，有 67.3%的用户好友超过200人，也就是说多数用户微信好友事实上超过了自己能够维持经常互动的能力范围。社交媒体只是在技术层面消灭了时空观念，实现同时与多人在线，但并没有带来深度和广度的延伸，更多时候那些关系淡化的好友推送的内容往往并非用户所需要的，这部分信息就成了无用的污染信息。</p>
<p>其实全世界都存在信息污染，但中文世界信息污染严重的一大原因，是我们和世界不是连通的，事实上我们得到的信息是二手的，是经过一遍筛查再让我们看到的。</p>
<p>我们的互联网如此，我们的电影如此，我们的书籍也是如此。</p>
<p>比如说如果不会英语，你首先要面对的是中文互联网中大批量的信息错误。</p>
<p>就拿最近的新西兰枪击案来说吧，3月15日，举世震惊的新西兰枪击案发生后，国内不少主流媒体的报道中不约而同地提到一点，注意是主流媒体。</p>
<p>在行凶过程中，枪手在腿上绑着很多本杂志。</p>
<img src="/posts/7156f191/7156f191/image-20221214083647596.png" class="" title="image-20221214083647596">

<p>继而很多媒体开始进行一些匪夷所思的猜测，说杂志中可能包含着行凶者的动机、信仰等，让很多国内的读者摸不着头脑。</p>
<p>实际上，magazine不仅仅是指杂志的意思，他还有另一个意思是“弹匣”，但是翻译成杂志这个风马牛不相及的意思就很是典型的信息错误了。</p>
<img src="/posts/7156f191/7156f191/image-20221214083733672.png" class="" title="image-20221214083733672">









<p>再比如：</p>
<p>女大学生从直升机上跳下</p>
<p>这几个字极具冲击力。</p>
<p>看了以后，</p>
<p>是不是以为这个女大学生遇到了什么人生困难想自杀？</p>
<p>是不是疑惑为什么直升机上没人阻拦？</p>
<p>是不是立马脑补了一出大戏？</p>
<p>我是的。</p>
<p>然而，当我点开这则新闻以后，看到的内容却是：</p>
<p>翼装飞行员从直升机上起跳，进行翼装飞行。</p>
<p>这件事，初看只觉得可笑。</p>
<p>但细想起来，又觉得可悲。</p>
<p>信息污染真的太严重了，我们每天都要接受和处理那么多的信息， 到底多少是正确的呢？标题党把互联网环境弄得乌烟瘴气的</p>
<p>Adobe之前宣布了一个新的 Photoshop 功能，可以让你合成任何人的声音，本来说是一个非常好的项目， 但是它也允许坏人为假新闻生成辅助文档，直到它与现实无法区分。如果我们不开发一个信息免疫系统，优先考虑科学的，基于事实的真相，即使它伤害了我们个人，那么我们的文明将死于信息污染，如细菌填满培养皿，然后死于自己的废物产品。</p>
<p>有人说， 人类有一个天然的信息免疫系统， 叫做大脑， 自己会区分那种无用的信息， 我认为人类的大脑对无用， 错误信息的处理就好像是温水煮青蛙， 刚开始可能会排斥， 先是享受在舒服的温水中， 最后迷失在自己的幻想中</p>
<p>有的人在网络空间大肆传播谬误信息、谎言信息、迷信信息、恐怖信息等，更有甚者，为谋取利益不惜出卖人格，或通过微博微信大肆传播这类信息信息。这些行为更是直接造成网络信息环境的混浊化。</p>
<p>所以，我们获取信息的过程中要做到全面，所谓兼听则明， 偏听则暗，跳出自己的圈子，独立思考。掌握正确的信息获取方式，并教给我们的后代，避免大脑每天被那些无用的信息覆盖，在大量信息冲击你大脑之前设置一道防线，方能使得自己立于不败之地</p>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/82993392">https://zhuanlan.zhihu.com/p/82993392</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/142187041">https://zhuanlan.zhihu.com/p/142187041</a></p>
<p>[1] 西南民族大学学报：人文科学社会版</p>
<p>[2] 微信信息污染及其影响因素研究</p>
</body></html>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>如何应对信息污染</tag>
      </tags>
  </entry>
  <entry>
    <title>如何让自己慢下来</title>
    <url>/posts/84866147.html</url>
    <content><![CDATA[<html><head></head><body><p>现代人都是在追求快节奏和高效率， 特别是自从电脑出现后， 我们处理事情的效率变得越来越高，如此的追求效率给我们带来的却是，我们并没有闲下来，而是更忙了</p>
<span id="more"></span>

<p>比如一个小时的事情， 我能不能半小时干完， 而且干得好？<br>人生一共才700个月，大约两万天， 其中的1/3的时间我们都在睡觉， 剩下的2/3我们开始追求高效率， 高节奏的生活，我们这样的作法对不对？</p>
<p>我喜欢那种语言简洁明了的， 就是如果能一句话说的足够清楚明白， 就绝对不说第二句，让语言变得高效； 在网上看到程序员大佬们研发各种各样的工具， 他们是为了节省人类的时间， 让我们能从重复， 繁琐的工作中解放出来，让时间变得高效；在这类理念的长期引导下， 人就会变得追求效率， 但是节省下来的时间并没有陪陪家人，这样就陷入了一种无法轮回的境界。</p>
<p>木心说：“从前书信很慢，车马很远，一生只够爱一个人。”</p>
<p>我们习惯了在事业里奔波劳累，但在光阴的故事里一定要慢下来，因为太着急的人生，仓促而粗糙。</p>
<p><strong>慢下来，不是无为，是让心安静下来，修复残破的灵魂，拾遗幸福的碎片</strong></p>
<p><strong>慢下来，才能更好地欣赏身边的风景。</strong>  </p>
<p>春有百花秋有月，夏有凉风冬有雪，大自然赋予人们无尽的财富，而我们却因为着急赶路，对这一切视而不见。</p>
<p>小草葳蕤而生，人生蓬勃向阳。世界上没有真正的穷人，只有贫瘠的心灵。</p>
<p>慢下来，会听见一朵花开的声音；慢下来，能看见树叶在枝丫跳舞；慢下来，能触摸到岁月划过琴弦的震颤。</p>
<p>大自然次第绽放的华章，需要我们慢下脚步，用心聆听，用心感受。</p>
<p>  <strong>慢下来，才能更有力地拥抱身边的人。</strong>  </p>
<p>人与人之间的相遇是多么的奇妙，没有早一步，也没有晚一步，就在那个恰好的时间遇见了彼此。</p>
<p>如果步子走得急了，来不及拥抱所爱之人，来不及牵起那双温暖的手。</p>
<p>当遇见变成错过，再怎样地捶足顿胸，终究是一场迟到。不如趁着春光明媚，鸟语花香，拥抱生活，拥抱亲情、友情、爱情。</p>
<p>把岁月交给时间，把温情交给身边的人，不要辜负人生最美的遇见。</p>
<p>慢慢走，用力爱，且行切珍惜，因为，下辈子不一定遇见。</p>
<p><strong>慢下来，才能品味到人间有味是清欢。</strong>  </p>
<p>现代快节奏的生活，人们的味蕾变得麻木，习惯了大鱼大肉，习惯了醴醪浓香，习惯了快餐文化。</p>
<p>快节奏的生活是一把双刃剑，给人们带来财富与便利的同时，也打乱了日子原本的宁静。</p>
<p>苏轼说：“雪漠乳花浮午盏，蓼茸高笋试春盘。人间有味是清欢，”</p>
<p>在一个午后，泡上一杯淡淡的清茶，品尝才采下的嫩嫩的野菜，人生的滋味就隐藏在这淡淡的欢愉里。</p>
<p>细细算来，人生也不过短短两万多天，民以食为天，吃给人类提供最基本的生命保证，也是健康的源泉。</p>
<p>不要再让快餐文化危害自己的健康，慢下来，自己熬碗粥，炒一盘素净的小菜，生活的真谛就隐藏在这简简单单的一粥一饭中。</p>
<p>不必非要去远方寻求唯美和浪漫，当远方也变成了身边，我们又会疲惫不堪。</p>
<p>只有从内心散发的热爱，才会地久天长。</p>
<p><strong>慢下来，才能读懂人生。</strong>  </p>
<p>沈从文说：“人生实在是一本书，内容复杂，分量沉重，值得翻到个人所能翻到的最后一页，而且必须慢慢地翻。”</p>
<p>读万卷书，行万里路，只有这样，我们才能和这个世界更好地对话。人世间走一遭，谁都不想空空儿而来，又空空而去。</p>
<p>人生这本书，如何来品读，有的人囫囵吞枣，合上书，大脑一片空白；有的人，捧起来甘之如饴，合上它，灵魂如入兰芝之室，散发着芳香。</p>
<p>我们都喜欢和品德高尚的人对话，折服于他非凡的气度，敬仰他耀眼的才华</p>
<p>一颗被学识浸染过的灵魂使人心生愉悦，人生这本书被他们细细品、慢慢翻，整个人变得和书成了一体，书的灵魂也变成了人的灵魂。</p>
<p><strong>人生之路千万不要走得太急，等一等灵魂，别活成一具空壳。</strong></p>
<p><strong>泰戈尔说：“不要着急，最好的总会在不经意的时候出现。”</strong></p>
</body></html>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>如何让自己慢下来</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样理解module？</title>
    <url>/posts/64527.html</url>
    <content><![CDATA[<html><head></head><body><h2 id="怎样理解module？"><a href="#怎样理解module？" class="headerlink" title="怎样理解module？"></a>怎样理解module？</h2><h2 id="面试官：你是怎么理解ES6中Module的？使用场景？"><a href="#面试官：你是怎么理解ES6中Module的？使用场景？" class="headerlink" title="面试官：你是怎么理解ES6中Module的？使用场景？"></a>面试官：你是怎么理解ES6中Module的？使用场景？</h2><img src="/posts/64527/64527/image-20221126084836725.png" class="" title="image-20221126084836725">

<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>模块，（Module），是能够单独命名并独立地完成一定功能的程序语句的<strong>集合（即程序代码和数据结构的集合体）</strong>。</p>
<span id="more"></span>

<p>两个基本的特征：外部特征和内部特征</p>
<ul>
<li>外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能</li>
<li>内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码）</li>
</ul>
<h4 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h4><ul>
<li>代码抽象</li>
<li>代码封装</li>
<li>代码复用</li>
<li>依赖管理</li>
</ul>
<p>如果没有模块化，我们代码会怎样？</p>
<ul>
<li>变量和方法不容易维护，容易污染全局作用域</li>
<li>加载资源的方式通过script标签从上到下。</li>
<li>依赖的环境主观逻辑偏重，代码较多就会比较复杂。</li>
<li>大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃</li>
</ul>
<p>因此，需要一种将<code>JavaScript</code>程序模块化的机制，如</p>
<ul>
<li>CommonJs (典型代表：node.js早期)</li>
<li>AMD (典型代表：require.js)</li>
<li>CMD (典型代表：sea.js)</li>
</ul>
<h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p><code>Asynchronous ModuleDefinition</code>（AMD），异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行</p>
<p>代表库为<code>require.js</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.<span class="title function_">config</span>({</span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">"js/lib"</span>,</span><br><span class="line">  <span class="attr">paths</span>: {</span><br><span class="line">    <span class="string">"jquery"</span>: <span class="string">"jquery.min"</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">"underscore"</span>: <span class="string">"underscore.min"</span>,</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"jquery"</span>,<span class="string">"underscore"</span>],<span class="keyword">function</span>(<span class="params">$,_</span>){</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h4 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h4><p><code>CommonJS</code> 是一套 <code>Javascript</code> 模块规范，用于服务端</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>={ foo , bar}</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">const</span> { foo,bar } = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>其有如下特点：</p>
<ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域</li>
<li>模块是同步加载的，即只有加载完成，才能执行后面的操作</li>
<li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li>
<li><code>require</code>返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值</li>
</ul>
<p>既然存在了<code>AMD</code>以及<code>CommonJs</code>机制，<code>ES6</code>的<code>Module</code>又有什么不一样？</p>
<p>ES6 在语言标准的层面上，实现了<code>Module</code>，即模块功能，完全可以取代 <code>CommonJS</code>和 <code>AMD</code>规范，成为浏览器和服务器通用的模块解决方案</p>
<p><code>CommonJS</code> 和<code>AMD</code> 模块，都只能在运行时确定这些东西。比如，<code>CommonJS</code>模块就是对象，输入时必须查找对象属性</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> { stat, exists, readfile } = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.<span class="property">stat</span>;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.<span class="property">exists</span>;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.<span class="property">readfile</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>ES6</code>设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> { stat, exists, readFile } <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码，只加载3个方法，其他方法不加载，即 <code>ES6</code> 可以在编译时就完成模块加载</p>
<p>由于编译加载，使得静态分析成为可能。包括现在流行的<code>typeScript</code>也是依靠静态分析实现功能</p>
<h3 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h3><p><code>ES6</code>模块内部自动采用了严格模式，这里就不展开严格模式的限制，毕竟这是<code>ES5</code>之前就已经规定好</p>
<p>模块功能主要由两个命令构成：</p>
<ul>
<li><code>export</code>：用于规定模块的对外接口</li>
<li><code>import</code>：用于输入其他模块提供的功能</li>
</ul>
<h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line">或 </span><br><span class="line"><span class="comment">// 建议使用下面写法，这样能瞬间确定输出了哪些变量</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> { firstName, lastName, year };</span><br></pre></td></tr></tbody></table></figure>

<p>输出函数或类</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">x, y</span>) {</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>通过<code>as</code>可以进行输出变量的重命名</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">v1</span>(<span class="params"></span>) { ... }</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">v2</span>(<span class="params"></span>) { ... }</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> {</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> { firstName, lastName, year } <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">element</span>) {</span><br><span class="line">  element.<span class="property">textContent</span> = firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同样如果想要输入变量起别名，通过<code>as</code>关键字</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { lastName <span class="keyword">as</span> surname } <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>当加载整个模块的时候，需要用到星号<code>*</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">area</span>(<span class="params">radius</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * radius * radius;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">circumference</span>(<span class="params">radius</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span> * radius;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle)   <span class="comment">// {area:area,circumference:circumference}</span></span><br></pre></td></tr></tbody></table></figure>

<p>输入的变量都是只读的，不允许修改，但是如果是对象，允许修改属性</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> {a} <span class="keyword">from</span> <span class="string">'./xxx.js'</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">foo</span> = <span class="string">'hello'</span>; <span class="comment">// 合法操作</span></span><br><span class="line">a = {}; <span class="comment">// Syntax Error : 'a' is read-only;</span></span><br></pre></td></tr></tbody></table></figure>

<p>不过建议即使能修改，但我们不建议。因为修改之后，我们很难差错</p>
<p><code>import</code>后面我们常接着<code>from</code>关键字，<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { a } <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>如果只有一个模块名，需要有配置文件，告诉引擎模块的位置</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { myMethod } <span class="keyword">from</span> <span class="string">'util'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>在编译阶段，<code>import</code>会提升到整个模块的头部，首先执行</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> { foo } <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>多次重复执行同样的导入，只会执行一次</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>上面的情况，大家都能看到用户在导入模块的时候，需要知道加载的变量名和函数，否则无法加载</p>
<p>如果不需要知道变量名或函数就完成加载，就要用到<code>export default</code>命令，为模块指定默认输出</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'foo'</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>加载该模块的时候，<code>import</code>命令可以为该函数指定任意名字</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br><span class="line"><span class="title function_">customName</span>(); <span class="comment">// 'foo'</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h4><p>允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势</p>
<p>这个新功能允许您将<code>import()</code>作为函数调用，将其作为参数传递给模块的路径。 它返回一个 <code>promise</code>，它用一个模块对象来实现，让你可以访问该对象的导出</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'/modules/myModule.mjs'</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params"><span class="variable language_">module</span></span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">// Do something with the module.</span></span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure>

<h4 id="复合写法"><a href="#复合写法" class="headerlink" title="复合写法"></a>复合写法</h4><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> { foo, bar } <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> { foo, bar } <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">export</span> { foo, bar };</span><br></pre></td></tr></tbody></table></figure>

<p>同理能够搭配<code>as</code>、<code>*</code>搭配使用</p>
<h3 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h3><p>如今，<code>ES6</code>模块化已经深入我们日常项目开发中，像<code>vue</code>、<code>react</code>项目搭建项目，组件化开发处处可见，其也是依赖模块化实现</p>
<p><code>vue</code>组件</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"App"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      组件化开发 ---- 模块化</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">'HelloWorld'</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">msg</span>: <span class="title class_">String</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  }</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">}</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<p><code>react</code>组件</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"App"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		组件化开发 ---- 模块化</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>包括完成一些复杂应用的时候，我们也可以拆分成各个模块</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://macsalvation.net/the-history-of-js-module/">https://macsalvation.net/the-history-of-js-module/</a></li>
<li><a href="https://es6.ruanyifeng.com/#docs/module">https://es6.ruanyifeng.com/#docs/module</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>如何理解module</tag>
      </tags>
  </entry>
  <entry>
    <title>对keep-alive的理解</title>
    <url>/posts/28754.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="说说你对对keep-alive的理解"><a href="#说说你对对keep-alive的理解" class="headerlink" title="说说你对对keep-alive的理解"></a>说说你对对keep-alive的理解</h1><h2 id="面试官：说说你对keep-alive的理解是什么？"><a href="#面试官：说说你对keep-alive的理解是什么？" class="headerlink" title="面试官：说说你对keep-alive的理解是什么？"></a>面试官：说说你对keep-alive的理解是什么？</h2><img src="/posts/28754/28754/image-20221027065251281.png" class="" title="image-20221027065251281">

<h3 id="一、Keep-alive-是什么"><a href="#一、Keep-alive-是什么" class="headerlink" title="一、Keep-alive 是什么"></a>一、Keep-alive 是什么</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">keep-alive`是`vue`中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染`DOM</span><br></pre></td></tr></tbody></table></figure>

<p><code>keep-alive</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们</p>
<span id="more"></span>

<p><code>keep-alive</code>可以设置以下<code>props</code>属性：</p>
<ul>
<li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存</li>
<li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存</li>
<li><code>max</code> - 数字。最多可以缓存多少组件实例</li>
</ul>
<p>关于<code>keep-alive</code>的基本用法：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component :is=<span class="string">"view"</span>&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>使用<code>includes</code>和<code>exclude</code>：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">&lt;keep-alive include=<span class="string">"a,b"</span>&gt;</span><br><span class="line">  &lt;component :is=<span class="string">"view"</span>&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 正则表达式 (使用 <span class="string">`v-bind`</span>) --&gt;</span><br><span class="line">&lt;keep-alive :include=<span class="string">"/a|b/"</span>&gt;</span><br><span class="line">  &lt;component :is=<span class="string">"view"</span>&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数组 (使用 <span class="string">`v-bind`</span>) --&gt;</span><br><span class="line">&lt;keep-alive :include=<span class="string">"['a', 'b']"</span>&gt;</span><br><span class="line">  &lt;component :is=<span class="string">"view"</span>&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>匹配首先检查组件自身的 <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的局部注册名称 (父组件 <code>components</code> 选项的键值)，匿名组件不能被匹配</p>
<p>设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（<code>activated</code>与<code>deactivated</code>）：</p>
<ul>
<li>首次进入组件时：<code>beforeRouteEnter</code> &gt; <code>beforeCreate</code> &gt; <code>created</code>&gt; <code>mounted</code> &gt; <code>activated</code> &gt; … … &gt; <code>beforeRouteLeave</code> &gt; <code>deactivated</code></li>
<li>再次进入组件时：<code>beforeRouteEnter</code> &gt;<code>activated</code> &gt; … … &gt; <code>beforeRouteLeave</code> &gt; <code>deactivated</code></li>
</ul>
<h3 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h3><p>使用原则：当我们在某些场景下不需要让页面重新加载时我们可以使用<code>keepalive</code></p>
<p>举个栗子:</p>
<p>当我们从<code>首页</code>–&gt;<code>列表页</code>–&gt;<code>商详页</code>–&gt;<code>再返回</code>，这时候列表页应该是需要<code>keep-alive</code></p>
<p>从<code>首页</code>–&gt;<code>列表页</code>–&gt;<code>商详页</code>–&gt;<code>返回到列表页(需要缓存)</code>–&gt;<code>返回到首页(需要缓存)</code>–&gt;<code>再次进入列表页(不需要缓存)</code>，这时候可以按需来控制页面的<code>keep-alive</code></p>
<p>在路由中设置<code>keepAlive</code>属性判断是否需要缓存</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  path: <span class="string">'list'</span>,</span><br><span class="line">  name: <span class="string">'itemList'</span>, <span class="comment">// 列表页</span></span><br><span class="line">  component (resolve) {</span><br><span class="line">    require([<span class="string">'@/pages/item/list'</span>], resolve)</span><br><span class="line"> },</span><br><span class="line"> meta: {</span><br><span class="line">  keepAlive: <span class="literal">true</span>,</span><br><span class="line">  title: <span class="string">'列表页'</span></span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用<code>&lt;keep-alive&gt;</code></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span> class=<span class="string">'wrapper'</span>&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">        &lt;!-- 需要缓存的视图组件 --&gt; </span><br><span class="line">        &lt;router-view v-<span class="keyword">if</span>=<span class="string">"$route.meta.keepAlive"</span>&gt;&lt;/router-view&gt;</span><br><span class="line">     &lt;/keep-alive&gt;</span><br><span class="line">      &lt;!-- 不需要缓存的视图组件 --&gt;</span><br><span class="line">     &lt;router-view v-<span class="keyword">if</span>=<span class="string">"!$route.meta.keepAlive"</span>&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a>三、原理分析</h3><p><code>keep-alive</code>是<code>vue</code>中内置的一个组件</p>
<p>源码位置：src/core/components/keep-alive.js</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">export <span class="keyword">default</span> {</span><br><span class="line">  name: <span class="string">'keep-alive'</span>,</span><br><span class="line">  abstract: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  props: {</span><br><span class="line">    include: [String, RegExp, Array],</span><br><span class="line">    exclude: [String, RegExp, Array],</span><br><span class="line">    max: [String, Number]</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  created () {</span><br><span class="line">    this.cache = Object.create(null)</span><br><span class="line">    this.keys = []</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  destroyed () {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key in this.cache) {</span><br><span class="line">      pruneCacheEntry(this.cache, key, this.keys)</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  mounted () {</span><br><span class="line">    this.$watch(<span class="string">'include'</span>, val =&gt; {</span><br><span class="line">      pruneCache(this, name =&gt; matches(val, name))</span><br><span class="line">    })</span><br><span class="line">    this.$watch(<span class="string">'exclude'</span>, val =&gt; {</span><br><span class="line">      pruneCache(this, name =&gt; !matches(val, name))</span><br><span class="line">    })</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  render() {</span><br><span class="line">    <span class="comment">/* 获取默认插槽中的第一个组件节点 */</span></span><br><span class="line">    <span class="keyword">const</span> slot = this.$slots.<span class="keyword">default</span></span><br><span class="line">    <span class="keyword">const</span> vnode = getFirstComponentChild(slot)</span><br><span class="line">    <span class="comment">/* 获取该组件节点的componentOptions */</span></span><br><span class="line">    <span class="keyword">const</span> componentOptions = vnode &amp;&amp; vnode.componentOptions</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (componentOptions) {</span><br><span class="line">      <span class="comment">/* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */</span></span><br><span class="line">      <span class="keyword">const</span> name = getComponentName(componentOptions)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> { include, exclude } = this</span><br><span class="line">      <span class="comment">/* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">        <span class="comment">// excluded</span></span><br><span class="line">        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">      ) {</span><br><span class="line">        <span class="keyword">return</span> vnode</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> { cache, keys } = this</span><br><span class="line">      <span class="comment">/* 获取组件的key值 */</span></span><br><span class="line">      <span class="keyword">const</span> key = vnode.key == null</span><br><span class="line">        <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">        <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">        ? componentOptions.Ctor.cid + (componentOptions.tag ? <span class="string">`::${componentOptions.tag}`</span> : <span class="string">''</span>)</span><br><span class="line">        : vnode.key</span><br><span class="line">     <span class="comment">/*  拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存 */</span></span><br><span class="line">      <span class="keyword">if</span> (cache[key]) {</span><br><span class="line">        vnode.componentInstance = cache[key].componentInstance</span><br><span class="line">        <span class="comment">// make current key freshest</span></span><br><span class="line">        remove(keys, key)</span><br><span class="line">        keys.push(key)</span><br><span class="line">      }</span><br><span class="line">        <span class="comment">/* 如果没有命中缓存，则将其设置进缓存 */</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">        cache[key] = vnode</span><br><span class="line">        keys.push(key)</span><br><span class="line">        <span class="comment">// prune oldest entry</span></span><br><span class="line">        <span class="comment">/* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */</span></span><br><span class="line">        <span class="keyword">if</span> (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) {</span><br><span class="line">          pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, this._vnode)</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      vnode.data.keepAlive = <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>])</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>81</p>
<p>可以看到该组件没有<code>template</code>，而是用了<code>render</code>，在组件渲染的时候会自动执行<code>render</code>函数</p>
<p><code>this.cache</code>是一个对象，用来存储需要缓存的组件，它将以如下形式存储：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">this.cache = {</span><br><span class="line">    <span class="string">'key1'</span>:<span class="string">'组件1'</span>,</span><br><span class="line">    <span class="string">'key2'</span>:<span class="string">'组件2'</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在组件销毁的时候执行<code>pruneCacheEntry</code>函数</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">function pruneCacheEntry (</span><br><span class="line">  cache: VNodeCache,</span><br><span class="line">  key: <span class="type">string</span>,</span><br><span class="line">  keys: Array&lt;<span class="type">string</span>&gt;,</span><br><span class="line">  current?: VNode</span><br><span class="line">) {</span><br><span class="line">  <span class="keyword">const</span> cached = cache[key]</span><br><span class="line">  <span class="comment">/* 判断当前没有处于被渲染状态的组件，将其销毁*/</span></span><br><span class="line">  <span class="keyword">if</span> (cached &amp;&amp; (!current || cached.tag !== current.tag)) {</span><br><span class="line">    cached.componentInstance.$destroy()</span><br><span class="line">  }</span><br><span class="line">  cache[key] = null</span><br><span class="line">  remove(keys, key)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>mounted</code>钩子函数中观测 <code>include</code> 和 <code>exclude</code> 的变化，如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">mounted () {</span><br><span class="line">    this.$watch(<span class="string">'include'</span>, val =&gt; {</span><br><span class="line">        pruneCache(this, name =&gt; matches(val, name))</span><br><span class="line">    })</span><br><span class="line">    this.$watch(<span class="string">'exclude'</span>, val =&gt; {</span><br><span class="line">        pruneCache(this, name =&gt; !matches(val, name))</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果<code>include</code> 或<code>exclude</code> 发生了变化，即表示定义需要缓存的组件的规则或者不需要缓存的组件的规则发生了变化，那么就执行<code>pruneCache</code>函数，函数如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">function pruneCache (keepAliveInstance, filter) {</span><br><span class="line">  <span class="keyword">const</span> { cache, keys, _vnode } = keepAliveInstance</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key in cache) {</span><br><span class="line">    <span class="keyword">const</span> cachedNode = cache[key]</span><br><span class="line">    <span class="keyword">if</span> (cachedNode) {</span><br><span class="line">      <span class="keyword">const</span> name = getComponentName(cachedNode.componentOptions)</span><br><span class="line">      <span class="keyword">if</span> (name &amp;&amp; !filter(name)) {</span><br><span class="line">        pruneCacheEntry(cache, key, keys, _vnode)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在该函数内对<code>this.cache</code>对象进行遍历，取出每一项的<code>name</code>值，用其与新的缓存规则进行匹配，如果匹配不上，则表示在新的缓存规则下该组件已经不需要被缓存，则调用<code>pruneCacheEntry</code>函数将其从<code>this.cache</code>对象剔除即可</p>
<p>关于<code>keep-alive</code>的最强大缓存功能是在<code>render</code>函数中实现</p>
<p>首先获取组件的<code>key</code>值：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> key = vnode.key == null? </span><br><span class="line">componentOptions.Ctor.cid + (componentOptions.tag ? <span class="string">`::${componentOptions.tag}`</span> : <span class="string">''</span>)</span><br><span class="line">: vnode.key</span><br></pre></td></tr></tbody></table></figure>

<p>拿到<code>key</code>值后去<code>this.cache</code>对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存，如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 如果命中缓存，则直接从缓存中拿 vnode 的组件实例 */</span></span><br><span class="line"><span class="keyword">if</span> (cache[key]) {</span><br><span class="line">    vnode.componentInstance = cache[key].componentInstance</span><br><span class="line">    <span class="comment">/* 调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个 */</span></span><br><span class="line">    remove(keys, key)</span><br><span class="line">    keys.push(key)</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<p>直接从缓存中拿 <code>vnode</code> 的组件实例，此时重新调整该组件<code>key</code>的顺序，将其从原来的地方删掉并重新放在<code>this.keys</code>中最后一个</p>
<p><code>this.cache</code>对象中没有该<code>key</code>值的情况，如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 如果没有命中缓存，则将其设置进缓存 */</span></span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">    cache[key] = vnode</span><br><span class="line">    keys.push(key)</span><br><span class="line">    <span class="comment">/* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */</span></span><br><span class="line">    <span class="keyword">if</span> (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) {</span><br><span class="line">        pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, this._vnode)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>表明该组件还没有被缓存过，则以该组件的<code>key</code>为键，组件<code>vnode</code>为值，将其存入<code>this.cache</code>中，并且把<code>key</code>存入<code>this.keys</code>中</p>
<p>此时再判断<code>this.keys</code>中缓存组件的数量是否超过了设置的最大缓存数量值<code>this.max</code>，如果超过了，则把第一个缓存组件删掉</p>
<h3 id="四、思考题：缓存后如何获取数据"><a href="#四、思考题：缓存后如何获取数据" class="headerlink" title="四、思考题：缓存后如何获取数据"></a>四、思考题：缓存后如何获取数据</h3><p>解决方案可以有以下两种：</p>
<ul>
<li>beforeRouteEnter</li>
<li>actived</li>
</ul>
<h4 id="beforeRouteEnter"><a href="#beforeRouteEnter" class="headerlink" title="beforeRouteEnter"></a>beforeRouteEnter</h4><p>每次组件渲染的时候，都会执行<code>beforeRouteEnter</code></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">beforeRouteEnter(to, from, next){</span><br><span class="line">    next(vm=&gt;{</span><br><span class="line">        console.log(vm)</span><br><span class="line">        <span class="comment">// 每次进入路由执行</span></span><br><span class="line">        vm.getData()  <span class="comment">// 获取数据</span></span><br><span class="line">    })</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure>

<h4 id="actived"><a href="#actived" class="headerlink" title="actived"></a>actived</h4><p>在<code>keep-alive</code>缓存的组件被激活的时候，都会执行<code>actived</code>钩子</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">activated(){</span><br><span class="line">   this.getData() <span class="comment">// 获取数据</span></span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure>

<p>注意：服务器端渲染期间<code>avtived</code>不被调用</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://www.cnblogs.com/dhui/p/13589401.html">https://www.cnblogs.com/dhui/p/13589401.html</a></li>
<li><a href="https://www.cnblogs.com/wangjiachen666/p/11497200.html">https://www.cnblogs.com/wangjiachen666/p/11497200.html</a></li>
<li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>keep-alive</tag>
      </tags>
  </entry>
  <entry>
    <title>我们应该结交怎样的朋友</title>
    <url>/posts/9bf59f17.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="我们应该结交怎样的朋友"><a href="#我们应该结交怎样的朋友" class="headerlink" title="我们应该结交怎样的朋友"></a>我们应该结交怎样的朋友</h1><h2 id="谈谈我认为最值得交往的朋友"><a href="#谈谈我认为最值得交往的朋友" class="headerlink" title="谈谈我认为最值得交往的朋友"></a>谈谈我认为最值得交往的朋友</h2><p>昨天11点40左右，我问了朋友一个问题，随后引发了很多朋友的思考，并给出了不同的思考和解答，更有甚者，直接将自己的思考结果写成了自己的故事发表到了个人网站上，供更多人思考和感悟</p>
<span id="more"></span>

<img src="/posts/9bf59f17/9bf59f17/image-20221219093534021.png" class="" title="image-20221219093534021">

<h2 id="浅谈开源精神"><a href="#浅谈开源精神" class="headerlink" title="浅谈开源精神"></a>浅谈开源精神</h2><p>人类为什么能进步？不就是前辈用自己的努力一生做出来的研究成果无私的分享给后代，这就是人类的伟大之处</p>
<img src="/posts/9bf59f17/9bf59f17/image-20221219091035075.png" class="" title="image-20221219091035075">



<img src="/posts/9bf59f17/9bf59f17/image-20221219093939064.png" class="" title="image-20221219093939064">

<img src="/posts/9bf59f17/9bf59f17/image-20221219093653225.png" class="" title="image-20221219093653225">





<p>我是支持知识付费的，在如今互联网发展迅猛的这样的一个时代，既要能正确有效的使用互联网，又要避免其中的信息污染，对自己无用的信息要尽量远离，举一个浅显的例子，你坐在火车上，这个时候大家都在睡觉，突然进来一个推销特产的，这对于无意购买的人就是一种信息污染<br>拿别人的代码来学习，看看别人实现这个需求是怎样一个思路，在自己一筹莫展中突然又一村，另外多多结识有趣，积极的朋友，对自己的生活的影响的作用是至关重要的</p>
<h2 id="天赋"><a href="#天赋" class="headerlink" title="天赋"></a>天赋</h2><p>天赋是一个很神奇的东西， 我是和我的很多朋友一样， 都是不相信天赋的， 因为没有任何证据可以证明刚出生的婴儿的大脑有什么很大的区别， 但是你不得不承认， 确实有那么一些人 ，在学一些特定的东西的时候， 就是比常人快， 而且他们的思维， 思考方式， 都显得那么的与众不同， 就比如， 有些人就是被苹果砸死， 都绝对不可能思考出万有引力定律，所以， 思维方式真的很重要。</p>
<p>之前有一个脍炙人口的作品叫做《一个出租车司机给我上的MBA课》，读完就是会让你感觉到统计， 总结的作用， 如果有的朋友不了解， 可以尝试去阅读。同样是出租车司机， 他赚的钱就是别人的几倍还多， 这其中的道理确实值得我们大家总结和思考，为什么他能异于常人的去总结和观察？这其中值得你去反思。</p>
<p>但是无可否认， 你天生身高就矮， 所以你一辈子打不了篮球吗？梅西， 就是为了足球而生， 科比， 李小龙。都是值得学习的传奇， 他们的人生是当之无愧的传奇</p>
<p>社会中有非常多的不确定性， 那么如果你想要成功的话， 还是有一定的运气成分的，但是这其中绝大多数的还是努力， 选择一条自己喜欢的道路， 比如我， 一名前端工程师， 然后去干。至少对得起自己的青春</p>
</body></html>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>我们应该结交怎样的朋友</tag>
      </tags>
  </entry>
  <entry>
    <title>我喜欢的vscode插件</title>
    <url>/posts/30222.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="我爱上的-VSCode-扩展"><a href="#我爱上的-VSCode-扩展" class="headerlink" title="我爱上的 VSCode 扩展"></a>我爱上的 VSCode 扩展</h1><h2 id="CodeSnap"><a href="#CodeSnap" class="headerlink" title="CodeSnap"></a><a href="https://marketplace.visualstudio.com/items?itemName=adpyke.codesnap">CodeSnap</a></h2><p>通过简单地突出显示项目中各自的代码段，可以快速创建代码的屏幕快照。就这么简单！不再需要打开新的选项卡、复制代码并保存照片。该图像将生成现场并排与选项，以剪切，复制和粘贴。相当于一种简化版的代码美化工具。</p>
<span id="more"></span>

<img src="/posts/30222/30222/image-20221101191617644.png" class="" title="image-20221101191617644">

<h2 id="Colorize"><a href="#Colorize" class="headerlink" title="Colorize"></a><a href="https://marketplace.visualstudio.com/items?itemName=kamikillerto.vscode-colorize">Colorize</a></h2><p>通过突出显示颜色变量的颜色值，可视化颜色变量。这是一个方便的时间节省翻译十六进制代码和变量名称。</p>
<img src="/posts/30222/30222/image-20221101191752756.png" class="" title="image-20221101191752756">

<h2 id="Beautify"><a href="#Beautify" class="headerlink" title="Beautify"></a><a href="https://marketplace.visualstudio.com/items?itemName=HookyQR.beautify">Beautify</a></h2><p>Beautify 将很容易地帮助您解决代码可读性等方面的任何问题。您需要的所有东西是: 按 F1并选择“美化文件”。它会自动修复你想要的东西。</p>
<img src="/posts/30222/30222/image-20221101191909371.png" class="" title="image-20221101191909371">

<h2 id="Live-Server"><a href="#Live-Server" class="headerlink" title="Live Server"></a><a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer">Live Server</a></h2><p>当你写你的 HTML，CSS，或者 JavaScript 文件时，你可以在你的 VSCode 窗口的底部按下“ Go Live”，它会自动添加你在网页上的更改，而不需要重新加载，等等。</p>
<img src="/posts/30222/30222/image-20221101191948536.png" class="" title="image-20221101191948536">

<p>autoDocstring</p>
<p>文档字符串使用“’三重单引号”或“”三重双引号“”在类、方法或函数声明的下面声明。所有函数都应该有一个 docstring</p>
<img src="/posts/30222/30222/image-20221101192046974.png" class="" title="image-20221101192046974">

<h2 id="GitLens"><a href="#GitLens" class="headerlink" title="GitLens"></a><a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens">GitLens</a></h2><p>GitLens 是 VisualStudio 代码的开源扩展。GitLens 只是帮助您更好地理解代码。快速了解行或代码块更改的对象、原因和时间。回顾历史，进一步了解代码是如何以及为什么发展的。</p>
<p>.gitignore</p>
<p>允许你从 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 库中提取.gitignore 模板。</p>
<h2 id="Remote-SSH"><a href="#Remote-SSH" class="headerlink" title="Remote SSH"></a><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh">Remote SSH</a></h2><p>Remote ー SSH 扩展允许您使用任何具有 SSH 服务器的远程计算机作为开发环境。这可以极大地简化各种情况下的开发和故障排除。</p>
<img src="/posts/30222/30222/image-20221101192157627.png" class="" title="image-20221101192157627">

<h2 id="Auto-Rename-Tag"><a href="#Auto-Rename-Tag" class="headerlink" title="Auto Rename Tag"></a><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag">Auto Rename Tag</a></h2><p>自动重命名成对的 HTML/XML 标记</p>
<img src="/posts/30222/30222/image-20221101192230364.png" class="" title="image-20221101192230364">

<h2 id="CSS-Peek"><a href="#CSS-Peek" class="headerlink" title="CSS Peek"></a><a href="https://marketplace.visualstudio.com/items?itemName=pranaygp.vscode-css-peek">CSS Peek</a></h2><p>允许查看 CSS ID 和类字符串作为从 html 文件到各自 CSS 的定义。允许偷看和定义。</p>
<img src="/posts/30222/30222/image-20221101192257315.png" class="" title="image-20221101192257315">

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>您最喜欢的 VSCode 扩展是什么？</p>
<p>happy coding ！！！</p>
</body></html>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vscode插件</tag>
      </tags>
  </entry>
  <entry>
    <title>我的英语学习方法</title>
    <url>/posts/3185.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="我的英语学习方法"><a href="#我的英语学习方法" class="headerlink" title="我的英语学习方法"></a>我的英语学习方法</h1><p>在写这篇文章之前， 我先来说说我为什么要学英语</p>
<p>我是一个程序员， 平时经常会看国外的文档， 这些文档基本都是英文的， 所以说， 在没有翻译工具的情况下，尤其是针对于技术文档， 要看懂其中要表达的意思还是很难的， 所以，这就是我学习英语的主要原因</p>
<p>还有一个原因就是， 我喜欢旅游， 更想去国外好好看看， 学英语的目的就是为了交流， 语言嘛， 就是用来交流的嘛，而不是为了考试而学英语， 本人非常不喜欢阅读理解， 绕来绕去的是真没意思 </p>
<p>所以， 我会列出我平时学习英语的方法</p>
<span id="more"></span>

<h2 id="社交工具"><a href="#社交工具" class="headerlink" title="社交工具"></a>社交工具</h2><p>既然我们说到英语是用来交流的， 那么就要给自己创建一个英语的学习环境， 像国外的那些社交软件</p>
<h3 id="facebook"><a href="#facebook" class="headerlink" title="facebook"></a>facebook</h3><p>Facebook是一款非常好用的社交软件， 里面有很多的英语帖子， 而配套的messager无疑是一款非常好用的工具， 比国内的vx之类的好用多了， 安全性更是不用说了</p>
<h3 id="whatsApp"><a href="#whatsApp" class="headerlink" title="whatsApp"></a>whatsApp</h3><p>这是一款国外的聊天软件， 刚才我们提到英语就是用来交流的一个工具， 那么用它来和自己的国外朋友交流， 一起互相进步， 这样才能让自己的交流能力得到一个提升</p>
<h2 id="论坛"><a href="#论坛" class="headerlink" title="论坛"></a>论坛</h2><h3 id="quora"><a href="#quora" class="headerlink" title="quora"></a>quora</h3><img src="/posts/3185/3185/image-20221120195701264.png" class="" title="image-20221120195701264">

<p>这是国外的一个知识问答网站， 特别好用， 类似于国内的知乎， 里面的帖子都是英文的， 平时看看帖子， 把刷抖音的时候用来看看帖子， 既能增长自己的知识广度， 更重要的是间接地提高了自己的英语水平</p>
<h3 id="reddit"><a href="#reddit" class="headerlink" title="reddit"></a>reddit</h3><img src="/posts/3185/3185/image-20221120200131526.png" class="" title="image-20221120200131526">

<p>与quora类似，也是一个特别好用的知识问答网站</p>
<h3 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h3><img src="/posts/3185/3185/image-20221120200036935.png" class="" title="image-20221120200036935">

<p> 这个网站用英文分享一些业内知识， 类似于国内的掘金，画面整洁， 我很喜欢</p>
<h3 id="discord"><a href="#discord" class="headerlink" title="discord"></a>discord</h3><p>非常好的一个交流软件， 里面可以找到自己志同道合的朋友， 这样的话， 自己学起英语也是非常的轻松， 关键是能和外国朋友实时交流， 这个是一个非常不错的选择</p>
<img src="/posts/3185/3185/image-20221120200715769.png" class="" title="image-20221120200715769">

<p>比如， 我问了一个朋友你吃过中国的辣条吗 ，她说， 我可以为了辣条出卖自己的灵魂， 是不是很有意思？</p>
<h2 id="看书"><a href="#看书" class="headerlink" title="看书"></a>看书</h2><p>因为我是贝爷的fans， 所以我会看他的书， 特别有意思。 所以我建议可以多看看国外的好书， 比如说狄金森的诗歌集就是我非常喜欢的，有的时候英文的文档反而更容易理解 ，因为不同的人会有不同的翻译， 比如server这个词， 翻译到大陆是服务器， 翻译到台湾那边就叫伺服器， 是不是感觉有点麻烦呢？难道不是吗？</p>
<p>看书的作用就是把前辈总结的经验拿来自己用， 这个就是人类进步的意义</p>
<p>比如我最近看了一本书， 是教怎么学习英语的，</p>
<img src="/posts/3185/3185/image-20221120201317162.png" class="" title="image-20221120201317162">

<p>写的很不错， 总结就是</p>
<img src="/posts/3185/3185/image-20221120201339432.png" class="" title="image-20221120201339432">

<p>所以说， 学自己喜欢的， 自己感兴趣的才是王道</p>
<p>之前有个大佬说过这样一句话， 我很赞同， 任何学历，在一个有目标并且有强大执行力的人面前， 根本什么都不是</p>
<p>所以， 找对适合自己的方法很重要！！！ </p>
</body></html>]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>英语学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的常用方法</title>
    <url>/posts/35161.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="数据的常用方法"><a href="#数据的常用方法" class="headerlink" title="数据的常用方法"></a>数据的常用方法</h1><h1 id="面试官：数组的常用方法有哪些？"><a href="#面试官：数组的常用方法有哪些？" class="headerlink" title="面试官：数组的常用方法有哪些？"></a>面试官：数组的常用方法有哪些？</h1><img src="/posts/35161/35161/5842e560-67b6-11eb-85f6-6fac77c0c9b3.png" class="" title="img">

<h2 id="一、操作方法"><a href="#一、操作方法" class="headerlink" title="一、操作方法"></a>一、操作方法</h2><p>数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生影响，哪些方法不会</p>
<p>下面对数组常用的操作方法做一个归纳</p>
<span id="more"></span>

<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响</p>
<ul>
<li>push()</li>
<li>unshift()</li>
<li>splice()</li>
<li>concat()</li>
</ul>
<h4 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h4><p><code>push()</code>方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = []; <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">// 推入两项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// 2</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><p>unshift()在数组开头添加任意多个值，然后返回新的数组长度</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">unshift</span>(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">// 从数组开头推入两项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 2</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h4><p>传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"yellow"</span>, <span class="string">"orange"</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors) <span class="comment">// red,yellow,orange,green,blue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed) <span class="comment">// []</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><p>首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"brown"</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// ["red", "green","blue"]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2); <span class="comment">// ["red", "green", "blue", "yellow", "black", "brown"]</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>下面三种都会影响原数组，最后一项不影响原数组：</p>
<ul>
<li>pop()</li>
<li>shift()</li>
<li>splice()</li>
<li>slice()</li>
</ul>
<h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><p><code>pop()</code> 方法用于删除数组的最后一项，同时减少数组的<code>length</code> 值，返回被删除的项</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>]</span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">pop</span>(); <span class="comment">// 取得最后一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// green</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="property">length</span>) <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h4><p><code>shift()</code>方法用于删除数组的第一项，同时减少数组的<code>length</code> 值，返回被删除的项</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>]</span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">shift</span>(); <span class="comment">// 取得第一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// red</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="property">length</span>) <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="splice-1"><a href="#splice-1" class="headerlink" title="splice()"></a>splice()</h4><p>传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 删除第一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// green,blue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed); <span class="comment">// red，只有一个元素的数组</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> colors3 = colors.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors)   <span class="comment">// red,green,blue,yellow,purple</span></span><br><span class="line">concole.<span class="title function_">log</span>(colors2); <span class="comment">// green,blue,yellow,purple</span></span><br><span class="line">concole.<span class="title function_">log</span>(colors3); <span class="comment">// green,blue,yellow</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><p>即修改原来数组的内容，常用<code>splice</code></p>
<h4 id="splice-2"><a href="#splice-2" class="headerlink" title="splice()"></a>splice()</h4><p>传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"red"</span>, <span class="string">"purple"</span>); <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// red,red,purple,blue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed); <span class="comment">// green，只有一个元素的数组</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>即查找元素，返回元素坐标或者元素值</p>
<ul>
<li>indexOf()</li>
<li>includes()</li>
<li>find()</li>
</ul>
<h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h4><p>返回要查找的元素在数组中的位置，如果没找到则返回 -1</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>) <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h4><p>返回要查找的元素在数组中的位置，找到返回<code>true</code>，否则<code>false</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">includes</span>(<span class="number">4</span>) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>返回第一个匹配的元素</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">    {</span><br><span class="line">        <span class="attr">name</span>: <span class="string">"Matt"</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">27</span></span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        <span class="attr">name</span>: <span class="string">"Nicholas"</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line">    }</span><br><span class="line">];</span><br><span class="line">people.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>) <span class="comment">// // {name: "Matt", age: 27}</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="二、排序方法"><a href="#二、排序方法" class="headerlink" title="二、排序方法"></a>二、排序方法</h2><p>数组有两个方法可以用来对元素重新排序：</p>
<ul>
<li>reverse()</li>
<li>sort()</li>
</ul>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>顾名思义，将数组元素方向反转</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">values.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>sort()方法接受一个比较函数，用于判断哪个值应该排在前面</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) {</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.<span class="title function_">sort</span>(compare);</span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 0,1,5,10,15</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="三、转换方法"><a href="#三、转换方法" class="headerlink" title="三、转换方法"></a>三、转换方法</h2><p>常见的转换方法有：</p>
<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">","</span>)); <span class="comment">// red,green,blue</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">"||"</span>)); <span class="comment">// red||green||blue</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="四、迭代方法"><a href="#四、迭代方法" class="headerlink" title="四、迭代方法"></a>四、迭代方法</h2><p>常用来迭代数组的方法（都不改变原数组）有如下：</p>
<ul>
<li>some()</li>
<li>every()</li>
<li>forEach()</li>
<li>filter()</li>
<li>map()</li>
</ul>
<h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p>对数组每一项都运行传入的测试函数，如果至少有1个元素返回 true ，则这个方法返回 true</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> someResult = numbers.<span class="title function_">some</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(someResult) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p>对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> everyResult = numbers.<span class="title function_">every</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(everyResult) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>对数组每一项都运行传入的函数，没有返回值</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>对数组每一项都运行传入的函数，函数返回 <code>true</code> 的项会组成数组之后返回</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filterResult); <span class="comment">// 3,4,5,4,3</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapResult) <span class="comment">// 2,4,6,8,10,8,6,4,2</span></span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>数组的常用方法</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟实现axios发送请求</title>
    <url>/posts/42461.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="模拟实现axios发送请求"><a href="#模拟实现axios发送请求" class="headerlink" title="模拟实现axios发送请求"></a>模拟实现axios发送请求</h1><span id="more"></span>

<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;script src="https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.js"&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 1. 声明构造函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">Axios</span> (config){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">config</span> = config</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//发送请求</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//创建一个promise对象</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(config)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//声明一个数组</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> chains = [dispatchRequest, <span class="literal">undefined</span>] <span class="comment">//undefined 的作用就是占位</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//调用then方法执行回调</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> result = promise.<span class="title function_">then</span>(chains[<span class="number">0</span>], chains[<span class="number">1</span>])</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//返回promise的结果</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> result</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 2. dispatchRequest函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 调用适配器发送请求</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="title function_">xhrAdapter</span>(config).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//    对响应的结果进行转化处理</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> response</span></span><br><span class="line"><span class="language-javascript">            },<span class="function"><span class="params">err</span> =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">throw</span> err</span></span><br><span class="line"><span class="language-javascript">            })</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 3. adapter适配器</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">xhrAdapter</span> (config){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'adapter函数执行了'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>{</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//发送ajax请求</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="title function_">open</span>(config.<span class="property">method</span>, config.<span class="property">url</span>)</span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="title function_">send</span>()</span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//判断成功的条件</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span>(xhr.<span class="property">onreadystatechange</span> = <span class="number">4</span>){</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">//判断成功的条件</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>){</span></span><br><span class="line"><span class="language-javascript">                            <span class="comment">// 成功的状态</span></span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">resolve</span>({</span></span><br><span class="line"><span class="language-javascript">                                <span class="comment">//配置对象</span></span></span><br><span class="line"><span class="language-javascript">                                <span class="attr">config</span>: config,</span></span><br><span class="line"><span class="language-javascript">                                <span class="comment">//响应体</span></span></span><br><span class="line"><span class="language-javascript">                                <span class="attr">data</span>: xhr.<span class="property">response</span>,</span></span><br><span class="line"><span class="language-javascript">                                <span class="comment">//响应头</span></span></span><br><span class="line"><span class="language-javascript">                                <span class="attr">headers</span>: xhr.<span class="title function_">getAllResponseHeaders</span>(),</span></span><br><span class="line"><span class="language-javascript">                                <span class="comment">//xhr的请求对象</span></span></span><br><span class="line"><span class="language-javascript">                                <span class="attr">request</span>: xhr,</span></span><br><span class="line"><span class="language-javascript">                                <span class="comment">//响应的状态码</span></span></span><br><span class="line"><span class="language-javascript">                                <span class="attr">status</span>: xhr.<span class="property">status</span>,</span></span><br><span class="line"><span class="language-javascript">                                <span class="comment">//响应字符串</span></span></span><br><span class="line"><span class="language-javascript">                                <span class="attr">statusText</span>: xhr.<span class="property">statusText</span></span></span><br><span class="line"><span class="language-javascript">                            })</span></span><br><span class="line"><span class="language-javascript">                        }<span class="keyword">else</span>{</span></span><br><span class="line"><span class="language-javascript">                            <span class="comment">// 失败的状态</span></span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'请求失败'</span> + xhr.<span class="property">status</span>))</span></span><br><span class="line"><span class="language-javascript">                        }</span></span><br><span class="line"><span class="language-javascript">                    }</span></span><br><span class="line"><span class="language-javascript">                    </span></span><br><span class="line"><span class="language-javascript">                }</span></span><br><span class="line"><span class="language-javascript">            })</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 4.创建axios函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> axios = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(<span class="literal">null</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// axios的发送请求</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">axios</span>({</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">method</span>: <span class="string">"GET"</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>:<span class="string">"http://localhost:3000/posts"</span></span></span><br><span class="line"><span class="language-javascript">        }).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span></span><br><span class="line"><span class="language-javascript">        }).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span></span><br><span class="line"><span class="language-javascript">        })</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>最终的结果就是：</p>
<img src="/posts/42461/42461/image-20221004095137369.png" class="" title="image-20221004095137369"></body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>模拟实现axios发送请求</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟实现axios取消请求</title>
    <url>/posts/45367.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="模拟实现axios取消请求"><a href="#模拟实现axios取消请求" class="headerlink" title="模拟实现axios取消请求"></a>模拟实现axios取消请求</h1><span id="more"></span>

<!-- more-->

<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;script src="https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.js"&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span> = <span class="string">'btn btn-primary'</span>&gt;</span>发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span> = <span class="string">'btn btn-warning'</span>&gt;</span>取消请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//构造函数: </span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">config</span> = config</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//原型request方法</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="title function_">dispatchRequest</span>(config)</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//dispatchRequest函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="title function_">xhrAdapter</span>(config)</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//xhrAdapter</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">xhrAdapter</span>(<span class="params">config</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 实例化对象</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="title function_">open</span>(config.<span class="property">method</span>, config.<span class="property">url</span>)</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//发送</span></span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="title function_">send</span>()</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 处理结果</span></span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>){</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>){</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">//判断结果</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>){</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">resolve</span>({</span></span><br><span class="line"><span class="language-javascript">                                <span class="attr">status</span>: xhr.<span class="property">status</span>,</span></span><br><span class="line"><span class="language-javascript">                                <span class="attr">statusText</span>: xhr.<span class="property">statusText</span></span></span><br><span class="line"><span class="language-javascript">                            })</span></span><br><span class="line"><span class="language-javascript">                        }<span class="keyword">else</span>{</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'错误'</span>))</span></span><br><span class="line"><span class="language-javascript">                        }</span></span><br><span class="line"><span class="language-javascript">                    }</span></span><br><span class="line"><span class="language-javascript">                }</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//关于取消请求的处理</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(config.<span class="property">cancelToken</span>){</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//对canceltoken对象身上的promise对象指定成功的回调</span></span></span><br><span class="line"><span class="language-javascript">                    config.<span class="property">cancelToken</span>.<span class="property">promise</span>.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">                        xhr.<span class="title function_">abort</span>();</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// 将请求结果设置为失败</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'请求已被取消'</span>))</span></span><br><span class="line"><span class="language-javascript">                    })</span></span><br><span class="line"><span class="language-javascript">                    </span></span><br><span class="line"><span class="language-javascript">                }</span></span><br><span class="line"><span class="language-javascript">              </span></span><br><span class="line"><span class="language-javascript">            })</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建axios函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>({})</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> axios = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(context)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// CancelToken构造函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">CancelToken</span>(<span class="params">executor</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//声明一个变量</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> resolvePromise;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//为实例对象添加属性</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//将resolve赋值给resolvePromise</span></span></span><br><span class="line"><span class="language-javascript">                resolvePromise = resolve</span></span><br><span class="line"><span class="language-javascript">            })</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 调用executor函数:</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">executor</span>(<span class="keyword">function</span> (<span class="params"></span>){</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//执行resolvePromise函数</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">resolvePromise</span>()</span></span><br><span class="line"><span class="language-javascript">            })</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">'button'</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> cancel = <span class="literal">null</span> ;</span></span><br><span class="line"><span class="language-javascript">        btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//检测上一次的请求是否完成;</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(cancel !== <span class="literal">null</span>){</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//取消上一次的请求</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">cancel</span>()</span></span><br><span class="line"><span class="language-javascript">            }</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 创建一个cancelToken的值</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> cancelToken = <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">c</span>){</span></span><br><span class="line"><span class="language-javascript">                cancel = c</span></span><br><span class="line"><span class="language-javascript">            })</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">axios</span>({</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">method</span>: <span class="string">"GET"</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">url</span>: <span class="string">'http://localhost:3000/posts'</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">cancelToken</span>: cancelToken</span></span><br><span class="line"><span class="language-javascript">            }).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span></span><br><span class="line"><span class="language-javascript">                cancel = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">            })</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">cancel</span>()</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>为了我们很高的观察， 我们在启动服务的时候加一个延时：</p>
<img src="/posts/45367/45367/image-20221007081116904.png" class="" title="image-20221007081116904">

<p>结果</p>
<img src="/posts/45367/45367/image-20221007080954468.png" class="" title="image-20221007080954468">

</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>模拟实现axios取消请求</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟实现axios拦截器功能</title>
    <url>/posts/25438.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="模拟实现axios拦截器功能"><a href="#模拟实现axios拦截器功能" class="headerlink" title="模拟实现axios拦截器功能"></a>模拟实现axios拦截器功能</h1><span id="more"></span>

<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;script src="https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.js"&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 构造函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">Axios</span> (config){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">config</span> = config</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">interceptors</span> = {</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">request</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>(),</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">response</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>(),</span></span><br><span class="line"><span class="language-javascript">            }</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//发送请求</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 创建一个promise对象</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(config)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 创建一个数组</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> chains = [dispatchRequest, <span class="literal">undefined</span>]</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//处理拦截器</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//请求拦截器, 将请求拦截器的回调压入到chains的前面 request.handlers = []</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="property">handlers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">                chains.<span class="title function_">unshift</span>(item.<span class="property">fulfilled</span>, item.<span class="property">rejected</span>)</span></span><br><span class="line"><span class="language-javascript">            })</span></span><br><span class="line"><span class="language-javascript">              <span class="comment">//响应拦截器</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="property">handlers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">                chains.<span class="title function_">push</span>(item.<span class="property">fulfilled</span>, item.<span class="property">rejected</span>)</span></span><br><span class="line"><span class="language-javascript">            })</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(chains)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 遍历</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">while</span>(chains.<span class="property">length</span> &gt; <span class="number">0</span>){</span></span><br><span class="line"><span class="language-javascript">                promise = promise.<span class="title function_">then</span>(chains.<span class="title function_">shift</span>(), chains.<span class="title function_">shift</span>())</span></span><br><span class="line"><span class="language-javascript">            }</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> promise</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 发送请求</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">dispatchRequest</span> (config){</span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//返回一个promise队形</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">resolve</span>({</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">status</span>: <span class="number">200</span>, </span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">statusText</span>: <span class="string">'OK'</span></span></span><br><span class="line"><span class="language-javascript">                })</span></span><br><span class="line"><span class="language-javascript">            })</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建实例：</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>({})</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建axios函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> axios = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(context)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 将context属性config和interceptors添加到axios对象身上</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Object</span>.<span class="title function_">keys</span>(context).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">            axios[key] = context[key]</span></span><br><span class="line"><span class="language-javascript">        })</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">dir</span>(axios)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 拦截器管理器构造函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">InterceptorManager</span>(<span class="params"></span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">handlers</span> = [];</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">InterceptorManager</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">use</span> = <span class="keyword">function</span> (<span class="params">fulfilled, rejected</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>({</span></span><br><span class="line"><span class="language-javascript">                fulfilled, </span></span><br><span class="line"><span class="language-javascript">                rejected</span></span><br><span class="line"><span class="language-javascript">            })</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> <span class="title function_">one</span> (config){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'请求拦截器1 成功'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> config;</span></span><br><span class="line"><span class="language-javascript">        },<span class="keyword">function</span> <span class="title function_">one</span>(<span class="params">error</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'请求拦截器1 失败'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span></span><br><span class="line"><span class="language-javascript">        })</span></span><br><span class="line"><span class="language-javascript">        axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> <span class="title function_">two</span>(<span class="params">config</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'请求拦截器2 成功'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> config;</span></span><br><span class="line"><span class="language-javascript">        },<span class="keyword">function</span> <span class="title function_">two</span>(<span class="params">error</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'请求拦截器2 失败'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span></span><br><span class="line"><span class="language-javascript">        })</span></span><br><span class="line"><span class="language-javascript">        axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'响应拦截器1 成功'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> response;</span></span><br><span class="line"><span class="language-javascript">        },<span class="keyword">function</span> (<span class="params">error</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'响应拦截器1 失败'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span></span><br><span class="line"><span class="language-javascript">        })</span></span><br><span class="line"><span class="language-javascript">        axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'响应拦截器2 成功'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> response;</span></span><br><span class="line"><span class="language-javascript">        },<span class="keyword">function</span> (<span class="params">error</span>){</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'响应拦截器2 失败'</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span></span><br><span class="line"><span class="language-javascript">        })</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 发送请求</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">axios</span>({</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">method</span>: <span class="string">"GET"</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>:<span class="string">"http://localhost:3000/posts"</span></span></span><br><span class="line"><span class="language-javascript">        }).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span></span><br><span class="line"><span class="language-javascript">        }).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> {</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span></span><br><span class="line"><span class="language-javascript">        })</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>以上是用自己的代码模拟实现了一个拦截器的原理， 我们来看看结果：</p>
<img src="/posts/25438/25438/image-20221007071200911.png" class="" title="image-20221007071200911"></body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>用css实现一些好看的效果</title>
    <url>/posts/fdc117a4.html</url>
    <content><![CDATA[<html><head></head><body><h2 id="用css实现一个按钮的效果"><a href="#用css实现一个按钮的效果" class="headerlink" title="用css实现一个按钮的效果"></a>用css实现一个按钮的效果</h2><p>css是很神奇的一种东西， 你给它一个模板， 告诉它怎么来， 它就给你一个非常漂亮的效果：</p>
<img src="/posts/fdc117a4/fdc117a4/switch.gif" class="" title="switch">

<p>比如实现这种开关的效果：</p>
<span id="more"></span>

<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"switch"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"round"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"onoff"</span> <span class="attr">id</span>=<span class="string">"onoff"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"back"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"onoff"</span> <span class="attr">class</span>=<span class="string">"but"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"on"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"off"</span>&gt;</span>I<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>这是html的结构：（本身没有任何生气， 但是使用了css之后， 它的强大的效果就出来了）</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span> {</span><br><span class="line">  <span class="attribute">display</span>: none</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.on</span>,<span class="selector-class">.off</span> {</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">text-shadow</span>: inset <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> black;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.on</span> {</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.1s</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: sans-serif</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.off</span> {</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#636161</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.1s</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.85</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.but</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">400px</span> <span class="number">400px</span> <span class="number">400px</span> <span class="number">400px</span> / <span class="number">400px</span> <span class="number">400px</span> <span class="number">300px</span> <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">border-bottom-width</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: inset <span class="number">8px</span> <span class="number">6px</span> <span class="number">5px</span> -<span class="number">7px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    ,inset -<span class="number">8px</span> <span class="number">6px</span> <span class="number">5px</span> -<span class="number">7px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    ,inset <span class="number">0</span> -<span class="number">3px</span> <span class="number">2px</span> -<span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>,.<span class="number">5</span>)</span><br><span class="line">    ,<span class="number">0</span> <span class="number">3px</span> <span class="number">3px</span> -<span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    ,inset <span class="number">0</span> -<span class="number">230px</span> <span class="number">60px</span> -<span class="number">200px</span> <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">2</span>)</span><br><span class="line">    ,inset <span class="number">0</span> <span class="number">220px</span> <span class="number">40px</span> -<span class="number">200px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">3</span>);</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">17px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.2s</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.back</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">-webkit-linear-gradient</span>(<span class="number">0deg</span>, transparent <span class="number">30%</span>, transparent <span class="number">65%</span>)</span><br><span class="line">    ,<span class="built_in">-webkit-linear-gradient</span>(<span class="number">0deg</span>, <span class="built_in">rgba</span>(<span class="number">245</span>, <span class="number">245</span>, <span class="number">245</span>, <span class="number">0</span>) <span class="number">30%</span>, <span class="built_in">rgba</span>(<span class="number">150</span>,<span class="number">150</span>,<span class="number">150</span>,.<span class="number">1</span>) <span class="number">50%</span>, <span class="built_in">rgba</span>(<span class="number">150</span>,<span class="number">150</span>,<span class="number">150</span>,<span class="number">0</span>) <span class="number">70%</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">115px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">85px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">4px</span> <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.2s</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.back</span> <span class="selector-class">.on</span>,<span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.back</span> <span class="selector-class">.off</span> {</span><br><span class="line">  <span class="attribute">text-shadow</span>: inset <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> black;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.back</span> <span class="selector-class">.on</span> {</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">141</span>, <span class="number">141</span>, <span class="number">141</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.85</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.back</span> <span class="selector-class">.off</span> {</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.back</span> <span class="selector-class">.but</span> {</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#232323</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">-webkit-radial-gradient</span>(<span class="number">55%</span> <span class="number">18%</span>,circle closest-corner,<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">3</span>) ,<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">410px</span> <span class="number">410px</span> <span class="number">410px</span> <span class="number">410px</span> / <span class="number">310px</span> <span class="number">310px</span> <span class="number">410px</span> <span class="number">410px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: inset <span class="number">8px</span> -<span class="number">4px</span> <span class="number">5px</span> -<span class="number">7px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    ,inset -<span class="number">8px</span> -<span class="number">4px</span> <span class="number">5px</span> -<span class="number">7px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    , <span class="number">0</span> -<span class="number">3px</span> <span class="number">8px</span> -<span class="number">4px</span> <span class="built_in">rgba</span>(<span class="number">250</span>,<span class="number">250</span>,<span class="number">250</span>,.<span class="number">4</span>)</span><br><span class="line">    ,inset <span class="number">0</span> <span class="number">3px</span> <span class="number">4px</span> -<span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">    ,inset <span class="number">0</span> <span class="number">280px</span> <span class="number">40px</span> -<span class="number">200px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>)</span><br><span class="line">    ,inset <span class="number">0</span> -<span class="number">200px</span> <span class="number">40px</span> -<span class="number">200px</span> <span class="built_in">rgba</span>(<span class="number">180</span>,<span class="number">180</span>,<span class="number">180</span>,.<span class="number">2</span>);</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.back</span> {</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">-webkit-linear-gradient</span>(<span class="number">90deg</span>, black <span class="number">30%</span>, transparent <span class="number">65%</span>)</span><br><span class="line">    ,<span class="built_in">-webkit-linear-gradient</span>(<span class="number">180deg</span>, <span class="built_in">rgba</span>(<span class="number">250</span>,<span class="number">250</span>,<span class="number">250</span>,<span class="number">0</span>) <span class="number">0%</span>, <span class="built_in">rgba</span>(<span class="number">250</span>,<span class="number">250</span>,<span class="number">250</span>,.<span class="number">4</span>) <span class="number">50%</span>, <span class="built_in">rgba</span>(<span class="number">150</span>,<span class="number">150</span>,<span class="number">150</span>,<span class="number">0</span>) <span class="number">100%</span>);</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">28px</span> <span class="number">28px</span> <span class="number">28px</span> -<span class="number">28px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">1</span>)</span><br><span class="line">    ,-<span class="number">28px</span> <span class="number">28px</span> <span class="number">28px</span> -<span class="number">22px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">1</span>)</span><br><span class="line">    ,<span class="number">0</span> <span class="number">30px</span> <span class="number">30px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>)</span><br><span class="line">    ,inset <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">6</span>);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">4px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.l</span>,<span class="selector-class">.r</span> {</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.round</span>,<span class="selector-id">#onoff</span>,<span class="selector-class">.back</span>,<span class="selector-class">.but</span>,<span class="selector-class">.on</span>,<span class="selector-class">.off</span> {</span><br><span class="line">  user-select: none;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="用css实现一个心型按钮的形状："><a href="#用css实现一个心型按钮的形状：" class="headerlink" title="用css实现一个心型按钮的形状："></a>用css实现一个心型按钮的形状：</h2><img src="/posts/fdc117a4/fdc117a4/love.gif" class="" title="love">

<p>这种效果也是可以通过html和css来实现的， 我们先来看看html部分的代码：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"love"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"switch"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"love-heart"</span> <span class="attr">for</span>=<span class="string">"switch"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"round"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>来看看css部分的代码：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.love-heart</span><span class="selector-pseudo">:before</span>,<span class="selector-id">#switch</span> {</span><br><span class="line"> <span class="attribute">display</span>: none;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.love-heart</span>, <span class="selector-class">.love-heart</span><span class="selector-pseudo">::after</span> {</span><br><span class="line"> <span class="attribute">border-color</span>: <span class="built_in">hsl</span>(<span class="number">231deg</span> <span class="number">28%</span> <span class="number">86%</span>);</span><br><span class="line"> <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line"> <span class="attribute">border-top-left-radius</span>: <span class="number">100px</span>;</span><br><span class="line"> <span class="attribute">border-top-right-radius</span>: <span class="number">100px</span>;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line"> <span class="attribute">border-bottom</span>: <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.round</span> {</span><br><span class="line"> <span class="attribute">position</span>: absolute;</span><br><span class="line"> <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">8px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">hsl</span>(<span class="number">0deg</span> <span class="number">0%</span> <span class="number">100%</span>);</span><br><span class="line"> <span class="attribute">box-shadow</span>: <span class="built_in">rgb</span>(<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> / <span class="number">24%</span>) <span class="number">0px</span> <span class="number">0px</span> <span class="number">4px</span> <span class="number">0px</span>;</span><br><span class="line"> <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line"> <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line"> <span class="attribute">bottom</span>: -<span class="number">1px</span>;</span><br><span class="line"> <span class="attribute">transition</span>: all .<span class="number">5s</span> ease;</span><br><span class="line"> <span class="attribute">animation</span>: check-animation2 .<span class="number">5s</span> forwards;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">label</span> <span class="selector-class">.round</span> {</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0px</span>, <span class="number">0px</span>);</span><br><span class="line"> <span class="attribute">animation</span>: check-animation .<span class="number">5s</span> forwards;</span><br><span class="line"> <span class="attribute">background-color</span>: <span class="built_in">hsl</span>(<span class="number">0deg</span> <span class="number">0%</span> <span class="number">100%</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> check-animation {</span><br><span class="line"> <span class="number">0%</span> {</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0px</span>, <span class="number">0px</span>);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="number">50%</span> {</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0px</span>, <span class="number">7px</span>);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="number">100%</span> {</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">7px</span>, <span class="number">7px</span>);</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> check-animation2 {</span><br><span class="line"> <span class="number">0%</span> {</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">7px</span>, <span class="number">7px</span>);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="number">50%</span> {</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0px</span>, <span class="number">7px</span>);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="number">100%</span> {</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0px</span>, <span class="number">0px</span>);</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.love-heart</span> {</span><br><span class="line"> <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line"> <span class="attribute">position</span>: relative;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">45deg</span>) <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">33px</span>) <span class="built_in">scale</span>(<span class="number">4</span>);</span><br><span class="line"> <span class="attribute">display</span>: block;</span><br><span class="line"> <span class="attribute">border-color</span>: <span class="built_in">hsl</span>(<span class="number">231deg</span> <span class="number">28%</span> <span class="number">86%</span>);</span><br><span class="line"> <span class="attribute">cursor</span>: pointer;</span><br><span class="line"> <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.love-heart</span>, <span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.love-heart</span><span class="selector-pseudo">::after</span>, <span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.love-heart</span> <span class="selector-class">.bottom</span> {</span><br><span class="line"> <span class="attribute">border-color</span>: <span class="built_in">hsl</span>(<span class="number">347deg</span> <span class="number">81%</span> <span class="number">61%</span>);</span><br><span class="line"> <span class="attribute">box-shadow</span>: inset <span class="number">6px</span> -<span class="number">5px</span> <span class="number">0px</span> <span class="number">2px</span> <span class="built_in">hsl</span>(<span class="number">347deg</span> <span class="number">99%</span> <span class="number">72%</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.love-heart</span><span class="selector-pseudo">::after</span>, <span class="selector-class">.love-heart</span> <span class="selector-class">.bottom</span> {</span><br><span class="line"> <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line"> <span class="attribute">display</span>: block;</span><br><span class="line"> <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line"> <span class="attribute">position</span>: absolute;</span><br><span class="line"> <span class="attribute">border-color</span>: <span class="built_in">hsl</span>(<span class="number">231deg</span> <span class="number">28%</span> <span class="number">86%</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.love-heart</span><span class="selector-pseudo">::after</span> {</span><br><span class="line"> <span class="attribute">right</span>: -<span class="number">9px</span>;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">90deg</span>);</span><br><span class="line"> <span class="attribute">top</span>: <span class="number">7px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.love-heart</span> <span class="selector-class">.bottom</span> {</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">11px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">11px</span>;</span><br><span class="line"> <span class="attribute">border-left</span>: <span class="number">1px</span> solid;</span><br><span class="line"> <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid;</span><br><span class="line"> <span class="attribute">border-color</span>: <span class="built_in">hsl</span>(<span class="number">231deg</span> <span class="number">28%</span> <span class="number">86%</span>);</span><br><span class="line"> <span class="attribute">left</span>: -<span class="number">1px</span>;</span><br><span class="line"> <span class="attribute">top</span>: <span class="number">5px</span>;</span><br><span class="line"> <span class="attribute">border-radius</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">5px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>非常的美妙？ 不是吗？</p>
<h2 id="用css实现一个input输入框的效果："><a href="#用css实现一个input输入框的效果：" class="headerlink" title="用css实现一个input输入框的效果："></a>用css实现一个input输入框的效果：</h2><img src="/posts/fdc117a4/fdc117a4/input.gif" class="" title="input">

<p>先看看html的结构：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"value"</span> <span class="attr">required</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"transition-delay:0ms"</span>&gt;</span>U<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"transition-delay:50ms"</span>&gt;</span>s<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"transition-delay:100ms"</span>&gt;</span>e<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"transition-delay:150ms"</span>&gt;</span>r<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"transition-delay:200ms"</span>&gt;</span>n<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"transition-delay:250ms"</span>&gt;</span>a<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"transition-delay:300ms"</span>&gt;</span>m<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"transition-delay:350ms"</span>&gt;</span>e<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>在这个结构的基础上， 我们加上css样式： </p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.form-control</span> {</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span> <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-control</span> <span class="selector-tag">input</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">2px</span> <span class="number">#fff</span> solid;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-control</span> <span class="selector-tag">input</span><span class="selector-pseudo">:focus</span>,</span><br><span class="line"><span class="selector-class">.form-control</span> <span class="selector-tag">input</span><span class="selector-pseudo">:valid</span> {</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-bottom-color</span>: lightblue;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-control</span> <span class="selector-tag">label</span> {</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">pointer-events</span>: none;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-control</span> <span class="selector-tag">label</span> <span class="selector-tag">span</span> {</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.3s</span> <span class="built_in">cubic-bezier</span>(<span class="number">0.68</span>, -<span class="number">0.55</span>, <span class="number">0.265</span>, <span class="number">1.55</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-control</span> <span class="selector-tag">input</span><span class="selector-pseudo">:focus</span>+<span class="selector-tag">label</span> <span class="selector-tag">span</span>,</span><br><span class="line"><span class="selector-class">.form-control</span> <span class="selector-tag">input</span><span class="selector-pseudo">:valid</span>+<span class="selector-tag">label</span> <span class="selector-tag">span</span> {</span><br><span class="line">  <span class="attribute">color</span>: lightblue;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">30px</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="用css实现一个卡片的效果："><a href="#用css实现一个卡片的效果：" class="headerlink" title="用css实现一个卡片的效果："></a>用css实现一个卡片的效果：</h2><img src="/posts/fdc117a4/fdc117a4/card.gif" class="" title="card">

<p>上代码：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flip"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"front"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Front<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Front Description<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"back"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Back<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Back Description<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>css部分：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.flip</span> {</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="built_in">rgba</span>(<span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">254px</span>;</span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">3s</span> ease;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flip</span><span class="selector-pseudo">:hover</span> {</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">180deg</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* Content */</span></span><br><span class="line"><span class="selector-class">.flip</span> <span class="selector-class">.content</span> {</span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flip</span> <span class="selector-class">.back</span>, <span class="selector-class">.flip</span> <span class="selector-class">.front</span> {</span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">backface-visibility</span>: hidden;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flip</span> <span class="selector-class">.back</span> {</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">180deg</span>);</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flip</span> <span class="selector-tag">h2</span>,</span><br><span class="line"><span class="selector-class">.flip</span> <span class="selector-tag">p</span> {</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">90px</span>);</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> black;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flip</span> <span class="selector-tag">h2</span> {</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: <span class="number">1px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flip</span> <span class="selector-tag">p</span> {</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.6em</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flip</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.flip</span><span class="selector-pseudo">::after</span> {</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(purple, red);</span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">180deg</span>)<span class="built_in">translateZ</span>(<span class="number">1px</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flip</span><span class="selector-pseudo">::before</span> {</span><br><span class="line">  <span class="attribute">transform</span>: none;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(violet, orange);</span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="用css实现一个加载动画："><a href="#用css实现一个加载动画：" class="headerlink" title="用css实现一个加载动画："></a>用css实现一个加载动画：</h2><img src="/posts/fdc117a4/fdc117a4/loading.gif" class="" title="loading">

<p>html部分：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">aria-label</span>=<span class="string">"Orange and tan hamster running in a metal wheel"</span> <span class="attr">role</span>=<span class="string">"img"</span> <span class="attr">class</span>=<span class="string">"wheel-and-hamster"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wheel"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hamster"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hamster__body"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hamster__head"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hamster__ear"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hamster__eye"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hamster__nose"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hamster__limb hamster__limb--fr"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hamster__limb hamster__limb--fl"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hamster__limb hamster__limb--br"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hamster__limb hamster__limb--bl"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hamster__tail"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"spoke"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>接下来我们来看看css部分：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.wheel-and-hamster</span> {</span><br><span class="line">  <span class="attr">--dur</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">12em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">12em</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wheel</span>,</span><br><span class="line"><span class="selector-class">.hamster</span>,</span><br><span class="line"><span class="selector-class">.hamster</span> <span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-class">.spoke</span> {</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wheel</span>,</span><br><span class="line"><span class="selector-class">.spoke</span> {</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wheel</span> {</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(<span class="number">100%</span> <span class="number">100%</span> at center,<span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">60%</span>,<span class="number">0</span>) <span class="number">47.8%</span>,<span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">60%</span>) <span class="number">48%</span>);</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hamster</span> {</span><br><span class="line">  <span class="attribute">animation</span>: hamster <span class="built_in">var</span>(--dur) ease-in-out infinite;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">3.5em</span>);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">7em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">3.75em</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">4deg</span>) <span class="built_in">translate</span>(-<span class="number">0.8em</span>,<span class="number">1.85em</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hamster__head</span> {</span><br><span class="line">  <span class="attribute">animation</span>: hamsterHead <span class="built_in">var</span>(--dur) ease-in-out infinite;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">hsl</span>(<span class="number">30</span>,<span class="number">90%</span>,<span class="number">55%</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">70%</span> <span class="number">30%</span> <span class="number">0</span> <span class="number">100%</span> / <span class="number">40%</span> <span class="number">25%</span> <span class="number">25%</span> <span class="number">60%</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> -<span class="number">0.25em</span> <span class="number">0</span> <span class="built_in">hsl</span>(<span class="number">30</span>,<span class="number">90%</span>,<span class="number">80%</span>) inset,</span><br><span class="line">		<span class="number">0.75em</span> -<span class="number">1.55em</span> <span class="number">0</span> <span class="built_in">hsl</span>(<span class="number">30</span>,<span class="number">90%</span>,<span class="number">90%</span>) inset;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2.75em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2.5em</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">100%</span> <span class="number">50%</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hamster__ear</span> {</span><br><span class="line">  <span class="attribute">animation</span>: hamsterEar <span class="built_in">var</span>(--dur) ease-in-out infinite;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">90%</span>,<span class="number">85%</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: -<span class="number">0.25em</span> <span class="number">0</span> <span class="built_in">hsl</span>(<span class="number">30</span>,<span class="number">90%</span>,<span class="number">55%</span>) inset;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">0.25em</span>;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">0.25em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.75em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.75em</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">75%</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hamster__eye</span> {</span><br><span class="line">  <span class="attribute">animation</span>: hamsterEye <span class="built_in">var</span>(--dur) linear infinite;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">0%</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0.375em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">1.25em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.5em</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hamster__nose</span> {</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">90%</span>,<span class="number">75%</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">35%</span> <span class="number">65%</span> <span class="number">85%</span> <span class="number">15%</span> / <span class="number">70%</span> <span class="number">50%</span> <span class="number">50%</span> <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0.75em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.25em</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hamster__body</span> {</span><br><span class="line">  <span class="attribute">animation</span>: hamsterBody <span class="built_in">var</span>(--dur) ease-in-out infinite;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">hsl</span>(<span class="number">30</span>,<span class="number">90%</span>,<span class="number">90%</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span> <span class="number">30%</span> <span class="number">50%</span> <span class="number">30%</span> / <span class="number">15%</span> <span class="number">60%</span> <span class="number">40%</span> <span class="number">40%</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0.1em</span> <span class="number">0.75em</span> <span class="number">0</span> <span class="built_in">hsl</span>(<span class="number">30</span>,<span class="number">90%</span>,<span class="number">55%</span>) inset,</span><br><span class="line">		<span class="number">0.15em</span> -<span class="number">0.5em</span> <span class="number">0</span> <span class="built_in">hsl</span>(<span class="number">30</span>,<span class="number">90%</span>,<span class="number">80%</span>) inset;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0.25em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">4.5em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">3em</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">17%</span> <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hamster__limb--fr</span>,</span><br><span class="line"><span class="selector-class">.hamster__limb--fl</span> {</span><br><span class="line">  <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">0</span> <span class="number">0</span>,<span class="number">100%</span> <span class="number">0</span>,<span class="number">70%</span> <span class="number">80%</span>,<span class="number">60%</span> <span class="number">100%</span>,<span class="number">0%</span> <span class="number">100%</span>,<span class="number">40%</span> <span class="number">80%</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1.5em</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hamster__limb--fr</span> {</span><br><span class="line">  <span class="attribute">animation</span>: hamsterFRLimb <span class="built_in">var</span>(--dur) linear infinite;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="built_in">hsl</span>(<span class="number">30</span>,<span class="number">90%</span>,<span class="number">80%</span>) <span class="number">80%</span>,<span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">90%</span>,<span class="number">75%</span>) <span class="number">80%</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">15deg</span>) <span class="built_in">translateZ</span>(-<span class="number">1px</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hamster__limb--fl</span> {</span><br><span class="line">  <span class="attribute">animation</span>: hamsterFLLimb <span class="built_in">var</span>(--dur) linear infinite;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="built_in">hsl</span>(<span class="number">30</span>,<span class="number">90%</span>,<span class="number">90%</span>) <span class="number">80%</span>,<span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">90%</span>,<span class="number">85%</span>) <span class="number">80%</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">15deg</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hamster__limb--br</span>,</span><br><span class="line"><span class="selector-class">.hamster__limb--bl</span> {</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.75em</span> <span class="number">0.75em</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">0</span> <span class="number">0</span>,<span class="number">100%</span> <span class="number">0</span>,<span class="number">100%</span> <span class="number">30%</span>,<span class="number">70%</span> <span class="number">90%</span>,<span class="number">70%</span> <span class="number">100%</span>,<span class="number">30%</span> <span class="number">100%</span>,<span class="number">40%</span> <span class="number">90%</span>,<span class="number">0%</span> <span class="number">30%</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">2.8em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.5em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2.5em</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">30%</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hamster__limb--br</span> {</span><br><span class="line">  <span class="attribute">animation</span>: hamsterBRLimb <span class="built_in">var</span>(--dur) linear infinite;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="built_in">hsl</span>(<span class="number">30</span>,<span class="number">90%</span>,<span class="number">80%</span>) <span class="number">90%</span>,<span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">90%</span>,<span class="number">75%</span>) <span class="number">90%</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">25deg</span>) <span class="built_in">translateZ</span>(-<span class="number">1px</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hamster__limb--bl</span> {</span><br><span class="line">  <span class="attribute">animation</span>: hamsterBLLimb <span class="built_in">var</span>(--dur) linear infinite;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="built_in">hsl</span>(<span class="number">30</span>,<span class="number">90%</span>,<span class="number">90%</span>) <span class="number">90%</span>,<span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">90%</span>,<span class="number">85%</span>) <span class="number">90%</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">25deg</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hamster__tail</span> {</span><br><span class="line">  <span class="attribute">animation</span>: hamsterTail <span class="built_in">var</span>(--dur) linear infinite;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">90%</span>,<span class="number">85%</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.25em</span> <span class="number">50%</span> <span class="number">50%</span> <span class="number">0.25em</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> -<span class="number">0.2em</span> <span class="number">0</span> <span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">90%</span>,<span class="number">75%</span>) inset;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">1.5em</span>;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>) <span class="built_in">translateZ</span>(-<span class="number">1px</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0.25em</span> <span class="number">0.25em</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.spoke</span> {</span><br><span class="line">  <span class="attribute">animation</span>: spoke <span class="built_in">var</span>(--dur) linear infinite;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(<span class="number">100%</span> <span class="number">100%</span> at center,<span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">60%</span>) <span class="number">4.8%</span>,<span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">60%</span>,<span class="number">0</span>) <span class="number">5%</span>),</span><br><span class="line">		<span class="built_in">linear-gradient</span>(<span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">55%</span>,<span class="number">0</span>) <span class="number">46.9%</span>,<span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">65%</span>) <span class="number">47%</span> <span class="number">52.9%</span>,<span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">65%</span>,<span class="number">0</span>) <span class="number">53%</span>) <span class="number">50%</span> <span class="number">50%</span> / <span class="number">99%</span> <span class="number">99%</span> no-repeat;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Animations */</span></span><br><span class="line"><span class="keyword">@keyframes</span> hamster {</span><br><span class="line">  <span class="selector-tag">from</span>, <span class="selector-tag">to</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">4deg</span>) <span class="built_in">translate</span>(-<span class="number">0.8em</span>,<span class="number">1.85em</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="number">50%</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>) <span class="built_in">translate</span>(-<span class="number">0.8em</span>,<span class="number">1.85em</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hamsterHead {</span><br><span class="line">  <span class="selector-tag">from</span>, <span class="number">25%</span>, <span class="number">50%</span>, <span class="number">75%</span>, <span class="selector-tag">to</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="number">12.5%</span>, <span class="number">37.5%</span>, <span class="number">62.5%</span>, <span class="number">87.5%</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">8deg</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hamsterEye {</span><br><span class="line">  <span class="selector-tag">from</span>, <span class="number">90%</span>, <span class="selector-tag">to</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="number">95%</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hamsterEar {</span><br><span class="line">  <span class="selector-tag">from</span>, <span class="number">25%</span>, <span class="number">50%</span>, <span class="number">75%</span>, <span class="selector-tag">to</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="number">12.5%</span>, <span class="number">37.5%</span>, <span class="number">62.5%</span>, <span class="number">87.5%</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">12deg</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hamsterBody {</span><br><span class="line">  <span class="selector-tag">from</span>, <span class="number">25%</span>, <span class="number">50%</span>, <span class="number">75%</span>, <span class="selector-tag">to</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="number">12.5%</span>, <span class="number">37.5%</span>, <span class="number">62.5%</span>, <span class="number">87.5%</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">2deg</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hamsterFRLimb {</span><br><span class="line">  <span class="selector-tag">from</span>, <span class="number">25%</span>, <span class="number">50%</span>, <span class="number">75%</span>, <span class="selector-tag">to</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">50deg</span>) <span class="built_in">translateZ</span>(-<span class="number">1px</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="number">12.5%</span>, <span class="number">37.5%</span>, <span class="number">62.5%</span>, <span class="number">87.5%</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">30deg</span>) <span class="built_in">translateZ</span>(-<span class="number">1px</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hamsterFLLimb {</span><br><span class="line">  <span class="selector-tag">from</span>, <span class="number">25%</span>, <span class="number">50%</span>, <span class="number">75%</span>, <span class="selector-tag">to</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">30deg</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="number">12.5%</span>, <span class="number">37.5%</span>, <span class="number">62.5%</span>, <span class="number">87.5%</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">50deg</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hamsterBRLimb {</span><br><span class="line">  <span class="selector-tag">from</span>, <span class="number">25%</span>, <span class="number">50%</span>, <span class="number">75%</span>, <span class="selector-tag">to</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">60deg</span>) <span class="built_in">translateZ</span>(-<span class="number">1px</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="number">12.5%</span>, <span class="number">37.5%</span>, <span class="number">62.5%</span>, <span class="number">87.5%</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">20deg</span>) <span class="built_in">translateZ</span>(-<span class="number">1px</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hamsterBLLimb {</span><br><span class="line">  <span class="selector-tag">from</span>, <span class="number">25%</span>, <span class="number">50%</span>, <span class="number">75%</span>, <span class="selector-tag">to</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">20deg</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="number">12.5%</span>, <span class="number">37.5%</span>, <span class="number">62.5%</span>, <span class="number">87.5%</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">60deg</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> hamsterTail {</span><br><span class="line">  <span class="selector-tag">from</span>, <span class="number">25%</span>, <span class="number">50%</span>, <span class="number">75%</span>, <span class="selector-tag">to</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>) <span class="built_in">translateZ</span>(-<span class="number">1px</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="number">12.5%</span>, <span class="number">37.5%</span>, <span class="number">62.5%</span>, <span class="number">87.5%</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">10deg</span>) <span class="built_in">translateZ</span>(-<span class="number">1px</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> spoke {</span><br><span class="line">  <span class="selector-tag">from</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">to</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">1turn</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>用css实现一些好看的效果</tag>
      </tags>
  </entry>
  <entry>
    <title>用css打开《清明上河图》</title>
    <url>/posts/5465.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="用css打开《清明上河图》"><a href="#用css打开《清明上河图》" class="headerlink" title="用css打开《清明上河图》"></a>用css打开《清明上河图》</h1><p>先看效果图：</p>
<img src="/posts/5465/5465/image-20221009171254436.png" class="" title="image-20221009171254436">

<span id="more"></span>

<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><h3 id="骨架："><a href="#骨架：" class="headerlink" title="骨架："></a>骨架：</h3><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"leftReelWrapper"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"leftTopHandleBorder"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"leftTopHandle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"leftTopReel"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"leftBottomHandle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"leftBottomHandleBorder"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">src</span>=<span class="string">'./qingming_content.png'</span> <span class="attr">width</span>=<span class="string">"469px"</span> <span class="attr">height</span>=<span class="string">"261px"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rightReelWrapper"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rightTopHandleBorder"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rightTopHandle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rightReel"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rightBottomHandle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rightBottomHandleBorder"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="画轴："><a href="#画轴：" class="headerlink" title="画轴："></a>画轴：</h3><p>添加css代码：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line"><span class="selector-tag">body</span> {</span><br><span class="line">		<span class="attribute">background</span>: <span class="number">#888</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="selector-class">.container</span> {</span><br><span class="line">		<span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">	 	<span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">	 	<span class="attribute">position</span>: relative;</span><br><span class="line">	 	<span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="selector-class">.leftReelWrapper</span> {</span><br><span class="line">		<span class="attribute">position</span>: absolute;</span><br><span class="line">		<span class="attribute">left</span>: <span class="number">50px</span>;</span><br><span class="line">		<span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">		<span class="attribute">margin-top</span>: -<span class="number">180px</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="selector-class">.leftTopReel</span>{</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">		<span class="attribute">margin-left</span>: <span class="number">3px</span>;</span><br><span class="line">		<span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#884433</span>, <span class="number">#FBBC62</span>, <span class="number">#CC5F3D</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="selector-class">.leftTopHandle</span>, <span class="selector-class">.leftBottomHandle</span>{</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">24px</span>;</span><br><span class="line">		<span class="attribute">margin-left</span>: <span class="number">3px</span>;</span><br><span class="line">		<span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#411C1D</span>, <span class="number">#832C29</span>, <span class="number">#411C1D</span>);</span><br><span class="line">	}</span><br><span class="line">      <span class="comment">/*轴上柄的末端小边*/</span></span><br><span class="line">	<span class="selector-class">.leftTopHandleBorder</span>, <span class="selector-class">.leftBottomHandleBorder</span> {</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">26px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">6px</span>;</span><br><span class="line">		<span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">		<span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#411C1D</span>, <span class="number">#832C29</span>, <span class="number">#411C1D</span>);</span><br><span class="line">	}</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<img src="/posts/5465/5465/image-20221009171455394.png" class="" title="image-20221009171455394">

<p>接着画另外一根：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">	<span class="selector-tag">body</span> {</span><br><span class="line">		<span class="attribute">background</span>: <span class="number">#888</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="selector-class">.container</span> {</span><br><span class="line">		<span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">	 	<span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">	 	<span class="attribute">position</span>: relative;</span><br><span class="line">	 	<span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="selector-class">.leftReelWrapper</span> {</span><br><span class="line">		<span class="attribute">position</span>: absolute;</span><br><span class="line">		<span class="attribute">left</span>: <span class="number">50px</span>;</span><br><span class="line">		<span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">		<span class="attribute">margin-top</span>: -<span class="number">180px</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*右轴定位*/</span></span><br><span class="line">	<span class="selector-class">.rightReelWrapper</span> {</span><br><span class="line">		<span class="attribute">position</span>: absolute;</span><br><span class="line">		<span class="attribute">left</span>: <span class="number">76px</span>;</span><br><span class="line">		<span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">		<span class="attribute">margin-top</span>: -<span class="number">180px</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*添加类名 .rightReel*/</span></span><br><span class="line">	<span class="selector-class">.leftTopReel</span>, <span class="selector-class">.rightReel</span> {</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">		<span class="attribute">margin-left</span>: <span class="number">3px</span>;</span><br><span class="line">		<span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#884433</span>, <span class="number">#FBBC62</span>, <span class="number">#CC5F3D</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*添加类名 .rightTopHandle .rightBottomHandle*/</span></span><br><span class="line">	<span class="selector-class">.leftTopHandle</span>, <span class="selector-class">.leftBottomHandle</span>, <span class="selector-class">.rightTopHandle</span>, <span class="selector-class">.rightBottomHandle</span> {</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">24px</span>;</span><br><span class="line">		<span class="attribute">margin-left</span>: <span class="number">3px</span>;</span><br><span class="line">		<span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#411C1D</span>, <span class="number">#832C29</span>, <span class="number">#411C1D</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*轴上柄的末端小边*/</span></span><br><span class="line">	<span class="comment">/*添加类名 .rightTopHandleBorder, .rightBottomHandleBorder*/</span></span><br><span class="line">	<span class="selector-class">.leftTopHandleBorder</span>, <span class="selector-class">.leftBottomHandleBorder</span>, <span class="selector-class">.rightTopHandleBorder</span>, <span class="selector-class">.rightBottomHandleBorder</span> {</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">26px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">6px</span>;</span><br><span class="line">		<span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">		<span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#411C1D</span>, <span class="number">#832C29</span>, <span class="number">#411C1D</span>);</span><br><span class="line">	}</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>两根画好之后：</p>
<img src="/posts/5465/5465/image-20221009171601463.png" class="" title="image-20221009171601463">

<h3 id="展开："><a href="#展开：" class="headerlink" title="展开："></a>展开：</h3><p>展开分两部分，一个是右轴的水平移动，一个是画布内容展开。</p>
<h4 id="右轴移动："><a href="#右轴移动：" class="headerlink" title="右轴移动："></a>右轴移动：</h4><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> moveReel {</span><br><span class="line">	<span class="selector-tag">to</span> {</span><br><span class="line">		<span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">500px</span>);</span><br><span class="line">	}	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*右轴定位*/</span></span><br><span class="line"><span class="selector-class">.rightReelWrapper</span> {</span><br><span class="line">        ...</span><br><span class="line">        // 加上这行</span><br><span class="line">        <span class="attribute">animation</span>: moveReel <span class="number">5s</span> linear <span class="number">3s</span> forwards;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后添加下面的css代码：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> expandPainting {</span><br><span class="line">	<span class="selector-tag">to</span> {</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">468px</span>;</span><br><span class="line">	    <span class="attribute">border</span>: <span class="number">20px</span> solid <span class="number">#E05717</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> {</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="comment">/*这里使用border作为内容画布的边框，两轴静止的时候填充到中间细缝，没有设 background, 也方便直接在content里放图片，达到一种透视效果*/</span></span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">20px</span> solid <span class="number">#E05717</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">20px</span> solid <span class="number">#E05717</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">20px</span> solid <span class="number">#E05717</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">261px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">72px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">56%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">180px</span>;</span><br><span class="line">    <span class="comment">/*这里添加动画*/</span></span><br><span class="line">    <span class="attribute">animation</span>: expandPainting <span class="number">5s</span> linear <span class="number">3s</span> forwards;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="放图："><a href="#放图：" class="headerlink" title="放图："></a>放图：</h3><p>记得加</p>
<p>overflow： hidden</p>
<img src="/posts/5465/5465/image-20221009171832686.png" class="" title="image-20221009171832686">



<p>文章参考链接：(<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes)(https://juejin.cn/post/7145798378247421960)">https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes)(https://juejin.cn/post/7145798378247421960)</a></p>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>用css画一个蜡烛</title>
    <url>/posts/27555.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="用css画一个蜡烛"><a href="#用css画一个蜡烛" class="headerlink" title="用css画一个蜡烛"></a>用css画一个蜡烛</h1><p>你有女朋友吗？</p>
<p>程序员有一个鄙视链， 如下图所示：</p>
<img src="/posts/27555/27555/image-20221121074112035.png" class="" title="image-20221121074112035">

<p>所以，要想站在鄙视链的顶端， 就要想办法向上爬， 那么如果是想要突破这种情况的话， 就需要一些骚操作</p>
<p>你是否被人骂自己不够romantic？</p>
<span id="more"></span>

<p>如果你生日的那天为女友画这样一个蜡烛， 那么大事可成。废话不多说， 直接上效果：</p>
<img src="/posts/27555/27555/demo.gif" class="" title="demo">

<p>那么下面我们就一起来操作一下吧</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">div.g-candle</span><br><span class="line">    div.g-body</span><br><span class="line">    div.g-fire-box</span><br><span class="line">        div.g-fire</span><br><span class="line">            -for(var i=0; i&lt;200; i++)</span><br><span class="line">                div.g-ball   </span><br></pre></td></tr></tbody></table></figure>

<p>简单的分析一下结构</p>
<img src="/posts/27555/27555/image-20221121075132454.png" class="" title="image-20221121075132454">

<p>其实结构看起来还好， 但是最麻烦的还是css， 但是， 为了女神， 有什么麻烦的呢？</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="绘制蜡烛"><a href="#绘制蜡烛" class="headerlink" title="绘制蜡烛"></a>绘制蜡烛</h3><p>我们先要画出这样一个效果：</p>
<img src="/posts/27555/27555/image-20221121075639936.png" class="" title="image-20221121075639936">

<p>这部分用到的代码就是：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-candle</span> {</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-body</span> {</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">280px</span> auto;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">230deg</span>, <span class="number">#ca9800</span>, <span class="number">#573903</span>, black <span class="number">70%</span>);</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个是主体的g-boby部分，但是想实现顶部的那个盖， 和上面的灯芯， 我们不妨用一下伪类来制造这样一个效果：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.g-body</span><span class="selector-pseudo">::before</span> {</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(<span class="number">#a46800</span>, <span class="number">#5c3104</span> <span class="number">45%</span>, <span class="number">#905602</span> <span class="number">100%</span>);</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.g-body</span><span class="selector-pseudo">::after</span> {</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">22px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span> <span class="number">50%</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">180deg</span>, <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3</span>) <span class="number">0%</span>, <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.8</span>) <span class="number">60%</span>, <span class="number">#fff</span>);</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.7</span>;</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">1px</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>效果：</p>
<img src="/posts/27555/27555/image-20221121080000801.png" class="" title="image-20221121080000801">

<h3 id="绘制火焰"><a href="#绘制火焰" class="headerlink" title="绘制火焰"></a>绘制火焰</h3><p>火焰部分应该是最难的了， 我们用到了动画的知识， 具体思路就是让200个div以特定的形状以动画的形式往上动来模拟实现一个火焰燃烧的效果</p>
<p>我这里只列举10个：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.g-fire</span> {</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">45%</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">120px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">120px</span> solid transparent;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, <span class="number">0</span>) <span class="built_in">scaleX</span>(<span class="number">0.45</span>);</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#761b00</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span> {</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fa8763</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">mix-blend-mode</span>: screen;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">40px</span> - <span class="number">55px</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) {</span><br><span class="line">  -webkit-<span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">2.137s</span> infinite;</span><br><span class="line">          <span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">2.137s</span> infinite;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">21px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">21px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">11px</span> - <span class="number">55px</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) {</span><br><span class="line">  -webkit-<span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">2.244s</span> infinite;</span><br><span class="line">          <span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">2.244s</span> infinite;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">13px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">13px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">4px</span> - <span class="number">55px</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) {</span><br><span class="line">  -webkit-<span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">2.745s</span> infinite;</span><br><span class="line">          <span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">2.745s</span> infinite;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">47px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">47px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">44px</span> - <span class="number">55px</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) {</span><br><span class="line">  -webkit-<span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">2.927s</span> infinite;</span><br><span class="line">          <span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">2.927s</span> infinite;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>) {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">23px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">23px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">36px</span> - <span class="number">55px</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>) {</span><br><span class="line">  -webkit-<span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">1.158s</span> infinite;</span><br><span class="line">          <span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">1.158s</span> infinite;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">6</span>) {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">23px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">23px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">16px</span> - <span class="number">55px</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">6</span>) {</span><br><span class="line">  -webkit-<span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">0.791s</span> infinite;</span><br><span class="line">          <span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">0.791s</span> infinite;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">7</span>) {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">47px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">47px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">25px</span> - <span class="number">55px</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">7</span>) {</span><br><span class="line">  -webkit-<span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">1.914s</span> infinite;</span><br><span class="line">          <span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">1.914s</span> infinite;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">8</span>) {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">22px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">22px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">67px</span> - <span class="number">55px</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">8</span>) {</span><br><span class="line">  -webkit-<span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">0.169s</span> infinite;</span><br><span class="line">          <span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">0.169s</span> infinite;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">9</span>) {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">26px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">26px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">54px</span> - <span class="number">55px</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">9</span>) {</span><br><span class="line">  -webkit-<span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">0.778s</span> infinite;</span><br><span class="line">          <span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">0.778s</span> infinite;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">10</span>) {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">7px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">7px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">54px</span> - <span class="number">55px</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-ball</span><span class="selector-pseudo">:nth-child</span>(<span class="number">10</span>) {</span><br><span class="line">  -webkit-<span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">1.803s</span> infinite;</span><br><span class="line">          <span class="attribute">animation</span>: movetop <span class="number">1s</span> linear -<span class="number">1.803s</span> infinite;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>加上movetop的动画：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> movetop {</span><br><span class="line">  <span class="number">0%</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="number">20%</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="number">87.7%</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>, -<span class="number">170px</span>);</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="number">100%</span> {</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>, -<span class="number">170px</span>);</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>来看看10个的效果：</p>
<img src="/posts/27555/27555/demo2.gif" class="" title="demo2">

<p>看看一百个动画的效果：</p>
<img src="/posts/27555/27555/demo3.gif" class="" title="demo3">

<p>最后添加到200个就是刚开始的那种效果</p>
<p>怎么样， 是不是很酷？</p>
<p>如果你还有什么好的想法和意见， 欢迎评论哈哈哈</p>
</body></html>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css实现蜡烛</tag>
      </tags>
  </entry>
  <entry>
    <title>用vue3.0设计组件</title>
    <url>/posts/24089.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="用vue3设计组件"><a href="#用vue3设计组件" class="headerlink" title="用vue3设计组件"></a>用vue3设计组件</h1><h2 id="面试官：用Vue3-0-写过组件吗？如果想实现一个-Modal你会怎么设计？"><a href="#面试官：用Vue3-0-写过组件吗？如果想实现一个-Modal你会怎么设计？" class="headerlink" title="面试官：用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？"></a>面试官：用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？</h2><img src="/posts/24089/24089/image-20221120074112213.png" class="" title="image-20221120074112213">

<h3 id="一、组件设计"><a href="#一、组件设计" class="headerlink" title="一、组件设计"></a>一、组件设计</h3><p>组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式</p>
<span id="more"></span>

<p>现在有一个场景，点击新增与编辑都弹框出来进行填写，功能上大同小异，可能只是标题内容或者是显示的主体内容稍微不同</p>
<p>这时候就没必要写两个组件，只需要根据传入的参数不同，组件显示不同内容即可</p>
<p>这样，下次开发相同界面程序时就可以写更少的代码，意义着更高的开发效率，更少的 <code>Bug</code>和更少的程序体积</p>
<h3 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h3><p>实现一个<code>Modal</code>组件，首先确定需要完成的内容：</p>
<ul>
<li>遮罩层</li>
<li>标题内容</li>
<li>主体内容</li>
<li>确定和取消按钮</li>
</ul>
<p>主体内容需要灵活，所以可以是字符串，也可以是一段 <code>html</code> 代码</p>
<p>特点是它们在当前<code>vue</code>实例之外独立存在，通常挂载于<code>body</code>之上</p>
<p>除了通过引入<code>import</code>的形式，我们还可通过<code>API</code>的形式进行组件的调用</p>
<p>还可以包括配置全局样式、国际化、与<code>typeScript</code>结合</p>
<h3 id="三、实现流程"><a href="#三、实现流程" class="headerlink" title="三、实现流程"></a>三、实现流程</h3><p>首先看看大致流程：</p>
<ul>
<li>目录结构</li>
<li>组件内容</li>
<li>实现 API 形式</li>
<li>事件处理</li>
<li>其他完善</li>
</ul>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p><code>Modal</code>组件相关的目录结构</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">├── plugins</span><br><span class="line">│   └── modal</span><br><span class="line">│       ├── Content.tsx // 维护 Modal 的内容，用于 h 函数和 jsx 语法</span><br><span class="line">│       ├── Modal.vue // 基础组件</span><br><span class="line">│       ├── config.ts // 全局默认配置</span><br><span class="line">│       ├── index.ts // 入口</span><br><span class="line">│       ├── locale // 国际化相关</span><br><span class="line">│       │   ├── index.ts</span><br><span class="line">│       │   └── lang</span><br><span class="line">│       │       ├── en-US.ts</span><br><span class="line">│       │       ├── zh-CN.ts</span><br><span class="line">│       │       └── zh-TW.ts</span><br><span class="line">│       └── modal.type.ts // ts类型声明相关</span><br></pre></td></tr></tbody></table></figure>

<p>因为 Modal 会被 <code>app.use(Modal)</code> 调用作为一个插件，所以都放在<code>plugins</code>目录下</p>
<h4 id="组件内容"><a href="#组件内容" class="headerlink" title="组件内容"></a>组件内容</h4><p>首先实现<code>modal.vue</code>的主体显示内容大致如下</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Teleport</span> <span class="attr">to</span>=<span class="string">"body"</span> <span class="attr">:disabled</span>=<span class="string">"!isTeleport"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"modelValue"</span> <span class="attr">class</span>=<span class="string">"modal"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">             <span class="attr">class</span>=<span class="string">"mask"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">:style</span>=<span class="string">"style"</span></span></span><br><span class="line"><span class="tag">             @<span class="attr">click</span>=<span class="string">"maskClose &amp;&amp; !loading &amp;&amp; handleCancel()"</span></span></span><br><span class="line"><span class="tag">             &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal__main"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal__title line line--b"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>{{ title || t("r.title") }}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">v-if</span>=<span class="string">"close"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">:title</span>=<span class="string">"t('r.close')"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">class</span>=<span class="string">"close"</span></span></span><br><span class="line"><span class="tag">                      @<span class="attr">click</span>=<span class="string">"!loading &amp;&amp; handleCancel()"</span></span></span><br><span class="line"><span class="tag">                      &gt;</span>✕&lt;/span</span><br><span class="line">                    &gt;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal__content"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Content</span> <span class="attr">v-if</span>=<span class="string">"typeof content === 'function'"</span> <span class="attr">:render</span>=<span class="string">"content"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">                    {{ content }}</span><br><span class="line">                <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal__btns line line--t"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">:disabled</span>=<span class="string">"loading"</span> @<span class="attr">click</span>=<span class="string">"handleConfirm"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"loading"</span> <span class="attr">v-if</span>=<span class="string">"loading"</span>&gt;</span> ❍ <span class="tag">&lt;/<span class="name">span</span>&gt;</span>{{ t("r.confirm") }}</span><br><span class="line">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"!loading &amp;&amp; handleCancel()"</span>&gt;</span></span><br><span class="line">                    {{ t("r.cancel") }}</span><br><span class="line">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Teleport</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>最外层上通过Vue3 <code>Teleport</code> 内置组件进行包裹，其相当于传送门，将里面的内容传送至<code>body</code>之上</p>
<p>并且从<code>DOM</code>结构上来看，把<code>modal</code>该有的内容（遮罩层、标题、内容、底部按钮）都实现了</p>
<p>关于主体内容</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal__content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Content</span> <span class="attr">v-if</span>=<span class="string">"typeof content==='function'"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">:render</span>=<span class="string">"content"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">        {{content}}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到根据传入<code>content</code>的类型不同，对应显示不同得到内容</p>
<p>最常见的则是通过调用字符串和默认插槽的形式</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">// 默认插槽</span><br><span class="line"><span class="tag">&lt;<span class="name">Modal</span> <span class="attr">v-model</span>=<span class="string">"show"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">title</span>=<span class="string">"演示 slot"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world~<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Modal</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 字符串</span><br><span class="line"><span class="tag">&lt;<span class="name">Modal</span> <span class="attr">v-model</span>=<span class="string">"show"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">title</span>=<span class="string">"演示 content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">content</span>=<span class="string">"hello world~"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>通过 API 形式调用<code>Modal</code>组件的时候，<code>content</code>可以使用下面两种</p>
<ul>
<li>h 函数</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">$modal.<span class="title function_">show</span>({</span><br><span class="line">  <span class="attr">title</span>: <span class="string">'演示 h 函数'</span>,</span><br><span class="line">  <span class="title function_">content</span>(<span class="params">h</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(</span><br><span class="line">      <span class="string">'div'</span>,</span><br><span class="line">      {</span><br><span class="line">        <span class="attr">style</span>: <span class="string">'color:red;'</span>,</span><br><span class="line">        <span class="attr">onClick</span>: <span class="function">(<span class="params">$event: Event</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'clicked'</span>, $event.<span class="property">target</span>)</span><br><span class="line">      },</span><br><span class="line">      <span class="string">'hello world ~'</span></span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>JSX</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">$modal.<span class="title function_">show</span>({</span><br><span class="line">  <span class="attr">title</span>: <span class="string">'演示 jsx 语法'</span>,</span><br><span class="line">  <span class="title function_">content</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">{($event:</span> <span class="attr">Event</span>) =&gt;</span> console.log('clicked', $event.target)}</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        hello world ~</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h4 id="实现-API-形式"><a href="#实现-API-形式" class="headerlink" title="实现 API 形式"></a>实现 API 形式</h4><p>那么组件如何实现<code>API</code>形式调用<code>Modal</code>组件呢？</p>
<p>在<code>Vue2</code>中，我们可以借助<code>Vue</code>实例以及<code>Vue.extend</code>的方式获得组件实例，然后挂载到<code>body</code>上</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Modal</span> <span class="keyword">from</span> <span class="string">'./Modal.vue'</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ComponentClass</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(<span class="title class_">Modal</span>);</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">ComponentClass</span>({ <span class="attr">el</span>: <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">"div"</span>) });</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(instance.<span class="property">$el</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>虽然<code>Vue3</code>移除了<code>Vue.extend</code>方法，但可以通过<code>createVNode</code>实现</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Modal</span> <span class="keyword">from</span> <span class="string">'./Modal.vue'</span>;</span><br><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">createVNode</span>(<span class="title class_">Modal</span>);</span><br><span class="line"><span class="title function_">render</span>(vnode, container);</span><br><span class="line"><span class="keyword">const</span> instance = vnode.<span class="property">component</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(container);</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>Vue2</code>中，可以通过<code>this</code>的形式调用全局 API</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">    <span class="title function_">install</span>(<span class="params">vue</span>) {</span><br><span class="line">       vue.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$create</span> = create</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而在 Vue3 的 <code>setup</code> 中已经没有 <code>this</code>概念了，需要调用<code>app.config.globalProperties</code>挂载到全局</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">    <span class="title function_">install</span>(<span class="params">app</span>) {</span><br><span class="line">        app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$create</span> = create</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><p>下面再看看看<code>Modal</code>组件内部是如何处理「确定」「取消」事件的，既然是<code>Vue3</code>，当然采用<code>Compositon API</code> 形式</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Modal.vue</span></span><br><span class="line"><span class="title function_">setup</span>(<span class="params">props, ctx</span>) {</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="title function_">getCurrentInstance</span>(); <span class="comment">// 获得当前组件实例</span></span><br><span class="line">  <span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    instance.<span class="property">_hub</span> = {</span><br><span class="line">      <span class="string">'on-cancel'</span>: <span class="function">() =&gt;</span> {},</span><br><span class="line">      <span class="string">'on-confirm'</span>: <span class="function">() =&gt;</span> {}</span><br><span class="line">    };</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleConfirm</span> = (<span class="params"></span>) =&gt; {</span><br><span class="line">    ctx.<span class="title function_">emit</span>(<span class="string">'on-confirm'</span>);</span><br><span class="line">    instance.<span class="property">_hub</span>[<span class="string">'on-confirm'</span>]();</span><br><span class="line">  };</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleCancel</span> = (<span class="params"></span>) =&gt; {</span><br><span class="line">    ctx.<span class="title function_">emit</span>(<span class="string">'on-cancel'</span>);</span><br><span class="line">    ctx.<span class="title function_">emit</span>(<span class="string">'update:modelValue'</span>, <span class="literal">false</span>);</span><br><span class="line">    instance.<span class="property">_hub</span>[<span class="string">'on-cancel'</span>]();</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    handleConfirm,</span><br><span class="line">    handleCancel</span><br><span class="line">  };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上面代码中，可以看得到除了使用传统<code>emit</code>的形式使父组件监听，还可通过<code>_hub</code>属性中添加 <code>on-cancel</code>，<code>on-confirm</code>方法实现在<code>API</code>中进行监听</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$modal</span> = {</span><br><span class="line">   <span class="title function_">show</span>(<span class="params">{}</span>) {</span><br><span class="line">     <span class="comment">/* 监听 确定、取消 事件 */</span></span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下面再来目睹下<code>_hub</code>是如何实现</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line">app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$modal</span> = {</span><br><span class="line">    <span class="title function_">show</span>(<span class="params">{</span></span><br><span class="line"><span class="params">        /* 其他选项 */</span></span><br><span class="line"><span class="params">        onConfirm,</span></span><br><span class="line"><span class="params">        onCancel</span></span><br><span class="line"><span class="params">    }</span>) {</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> { props, _hub } = instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">_closeModal</span> = (<span class="params"></span>) =&gt; {</span><br><span class="line">            props.<span class="property">modelValue</span> = <span class="literal">false</span>;</span><br><span class="line">            container.<span class="property">parentNode</span>!.<span class="title function_">removeChild</span>(container);</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">// 往 _hub 新增事件的具体实现</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">assign</span>(_hub, {</span><br><span class="line">            <span class="keyword">async</span> <span class="string">'on-confirm'</span>() {</span><br><span class="line">            <span class="keyword">if</span> (onConfirm) {</span><br><span class="line">                <span class="keyword">const</span> fn = <span class="title function_">onConfirm</span>();</span><br><span class="line">                <span class="comment">// 当方法返回为 Promise</span></span><br><span class="line">                <span class="keyword">if</span> (fn &amp;&amp; fn.<span class="property">then</span>) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        props.<span class="property">loading</span> = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">await</span> fn;</span><br><span class="line">                        props.<span class="property">loading</span> = <span class="literal">false</span>;</span><br><span class="line">                        <span class="title function_">_closeModal</span>();</span><br><span class="line">                    } <span class="keyword">catch</span> (err) {</span><br><span class="line">                        <span class="comment">// 发生错误时，不关闭弹框</span></span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">                        props.<span class="property">loading</span> = <span class="literal">false</span>;</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="title function_">_closeModal</span>();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="title function_">_closeModal</span>();</span><br><span class="line">            }</span><br><span class="line">        },</span><br><span class="line">            <span class="string">'on-cancel'</span>() {</span><br><span class="line">                onCancel &amp;&amp; <span class="title function_">onCancel</span>();</span><br><span class="line">                <span class="title function_">_closeModal</span>();</span><br><span class="line">            }</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="其他完善"><a href="#其他完善" class="headerlink" title="其他完善"></a>其他完善</h4><p>关于组件实现国际化、与<code>typsScript</code>结合，大家可以根据自身情况在此基础上进行更改</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://segmentfault.com/a/1190000038928664">https://segmentfault.com/a/1190000038928664</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>用vue设计组件</tag>
      </tags>
  </entry>
  <entry>
    <title>用vue实现一个简单的天气预报</title>
    <url>/posts/c2ba5eb1.html</url>
    <content><![CDATA[<html><head></head><body><p>用vue实现一个简单的天气预报项目：</p>
<p>App.vue:</p>
<span id="more"></span>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">router-view</span> /&gt;</span>     路由出口</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 底部tabbar --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- &lt;HelloWorld /&gt; --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">"App"</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">};</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>main.js</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">"./App.vue"</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">"./router"</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">"./store"</span>;</span><br><span class="line"><span class="keyword">import</span> getApi <span class="keyword">from</span> <span class="string">"./api"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"@/assets/css/normalize.css"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementUI</span> <span class="keyword">from</span> <span class="string">"element-ui"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"element-ui/lib/theme-chalk/index.css"</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将api请求注入原型对象中（全局化）</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$api</span> = getApi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 项目中用到了elementUI</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">ElementUI</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>({</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">}).$mount(<span class="string">"#app"</span>);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>其实对于这个项目， 我们最困难的就是服务之类的了， 这项项目的页面很简洁， 也就几个主要组件， 接下来我们看看请求部分，我们需要使用到axios， 先安装axios</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">"axios": "^0.24.0",</span><br></pre></td></tr></tbody></table></figure>

<p>那么接下来的代码主要用到的就是axios的知识：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;   <span class="comment">//引入axios</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">"@/router"</span>;      <span class="comment">//引入路由</span></span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">Message</span>, <span class="title class_">Loading</span> } <span class="keyword">from</span> <span class="string">"element-ui"</span>;  <span class="comment">//引入element-ui</span></span><br><span class="line"><span class="comment">//设置接口i</span></span><br><span class="line"><span class="keyword">const</span> api_base_url = <span class="string">"https://bird.ioliu.cn"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建axios实例</span></span><br><span class="line"><span class="keyword">let</span> instance = axios.<span class="title function_">create</span>({</span><br><span class="line">  <span class="attr">time</span>: <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">  <span class="attr">baseURL</span>: api_base_url,</span><br><span class="line">});</span><br><span class="line"><span class="keyword">let</span> loadingInstance; <span class="comment">//加载中。。。</span></span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">config</span>) =&gt;</span> {</span><br><span class="line">    loadingInstance = <span class="title class_">Loading</span>.<span class="title function_">service</span>({</span><br><span class="line">      <span class="attr">text</span>: <span class="string">"拼命加载中~"</span>,</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  },</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">    loadingInstance.<span class="title function_">close</span>();</span><br><span class="line">    <span class="title class_">Message</span>.<span class="title function_">error</span>({ <span class="attr">message</span>: <span class="string">"请求超时!"</span> });</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  }</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器即异常处理</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">response</span>) =&gt;</span> {</span><br><span class="line">    loadingInstance.<span class="title function_">close</span>();</span><br><span class="line">    <span class="keyword">let</span> data = response.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">let</span> status = response.<span class="property">status</span>;</span><br><span class="line">    <span class="keyword">if</span> (status === <span class="number">200</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(data);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="title class_">Message</span>.<span class="title function_">error</span>({ <span class="attr">message</span>: <span class="string">"服务器好像出了些问题~"</span> });</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(response);</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> {}</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>设置获取天气数据的函数：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getCityWeather</span> = (<span class="params">city</span>) =&gt; api.<span class="title function_">get</span>(<span class="string">`/weather?city=<span class="subst">${city}</span>`</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>home.vue(页面主要代码)</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"home"</span> <span class="attr">:style</span>=<span class="string">"{ backgroundImage: 'url(' + coverImgUrl + ')' }"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"weather-box"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-cascader</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">size</span>=<span class="string">"medium"</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">separator</span>=<span class="string">"&gt;"</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">:options</span>=<span class="string">"options"</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">placeholder</span>=<span class="string">"请选择/搜索"</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">v-model</span>=<span class="string">"selectedOptions"</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">:props</span>=<span class="string">"{ expandTrigger: 'hover' }"</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">filterable</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        @<span class="attr">change</span>=<span class="string">"selectCity"</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"now-cond"</span> <span class="attr">v-if</span>=<span class="string">"Object.keys(weathData).length"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"address"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-place"</span> /&gt;</span>{{ weathData.basic.city }}</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"upTime"</span>&gt;</span>{{ weathData.basic.update.loc }}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"condTxt"</span>&gt;</span>{{ weathData.now.cond.txt }}<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"wind"</span>&gt;</span>{{ weathData.now.wind.dir }}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"tmp"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          {{ weathData.daily_forecast[0].tmp.min }}℃~{{</span></span><br><span class="line"><span class="language-xml">            weathData.daily_forecast[0].tmp.max</span></span><br><span class="line"><span class="language-xml">          }}℃</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>未来3日天气预报<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">el-table</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">:data</span>=<span class="string">"weathData.daily_forecast"</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">border</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">style</span>=<span class="string">"width: 100%"</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">stripe</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"日期"</span> <span class="attr">width</span>=<span class="string">"180"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-time"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"margin-left: 10px"</span>&gt;</span>{{ scope.row.date }}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">"cond.txt_d"</span> <span class="attr">label</span>=<span class="string">"天气"</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">"tmp.min"</span> <span class="attr">label</span>=<span class="string">"最低温度(℃)"</span> <span class="attr">width</span>=<span class="string">"120"</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">"tmp.max"</span> <span class="attr">label</span>=<span class="string">"最高温度(℃)"</span> <span class="attr">width</span>=<span class="string">"120"</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">"wind.dir"</span> <span class="attr">label</span>=<span class="string">"风向"</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tip"</span> <span class="attr">v-else</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>选择城市开始查询吧<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//城市选择</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> { regionData, <span class="title class_">CodeToText</span> } <span class="keyword">from</span> <span class="string">"element-china-area-data"</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">"Home"</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">options</span>: regionData,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">selectedOptions</span>: [],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">addressAll</span>: [],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">address</span>: <span class="string">""</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">weathData</span>: {},</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">coverImgUrl</span>: <span class="built_in">require</span>(<span class="string">"@/assets/img/bg.jpg"</span>),</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    };</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  },</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//选择地区</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">selectCity</span>(<span class="params"></span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">addressAll</span> = [];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">selectedOptions</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">city</span>) =&gt;</span> {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">addressAll</span>.<span class="title function_">push</span>(<span class="title class_">CodeToText</span>[city]);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      });</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="title function_">inquireWeather</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    },</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 点击天气查询</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">async</span> <span class="title function_">inquireWeather</span>(<span class="params"></span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">addressAll</span>[<span class="number">2</span>] == <span class="string">"市辖区"</span> || <span class="variable language_">this</span>.<span class="property">addressAll</span>.<span class="property">length</span> == <span class="number">2</span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">address</span> = <span class="variable language_">this</span>.<span class="property">addressAll</span>[<span class="number">1</span>]; <span class="comment">//如果选市辖区就定位到二级地址</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      } <span class="keyword">else</span> {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">address</span> = <span class="variable language_">this</span>.<span class="property">addressAll</span>[<span class="number">2</span>]; <span class="comment">//区域码所对应的属性值即中文地址</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      }</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 开始请求接口</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> res1 = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">$api</span>.<span class="title function_">getCityWeather</span>(<span class="variable language_">this</span>.<span class="property">address</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (res1.<span class="property">status</span> === <span class="string">"ok"</span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//请求数据成功</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.$notify({</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">title</span>: <span class="string">"查询成功"</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">type</span>: <span class="string">"success"</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        });</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">weathData</span> = res1;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">weathData</span>.<span class="property">daily_forecast</span>.<span class="title function_">shift</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">weathData</span>.<span class="property">daily_forecast</span>.<span class="title function_">splice</span>(<span class="number">3</span>, <span class="number">3</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//无法找到该地</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      } <span class="keyword">else</span> <span class="keyword">if</span> (res1.<span class="property">status</span> === <span class="string">"unknown location"</span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 1.只是无法获取到三级地址信息</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 重新请求上一级地址</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">address</span> = <span class="variable language_">this</span>.<span class="property">addressAll</span>[<span class="number">1</span>];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> res2 = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">$api</span>.<span class="title function_">getCityWeather</span>(<span class="variable language_">this</span>.<span class="property">address</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (res2.<span class="property">status</span> === <span class="string">"ok"</span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">this</span>.$notify({</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">title</span>: <span class="string">"查询成功"</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">type</span>: <span class="string">"success"</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          });</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">this</span>.<span class="property">weathData</span> = res2;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">this</span>.<span class="property">weathData</span>.<span class="property">daily_forecast</span>.<span class="title function_">shift</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">this</span>.<span class="property">weathData</span>.<span class="property">daily_forecast</span>.<span class="title function_">splice</span>(<span class="number">3</span>, <span class="number">3</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        } <span class="keyword">else</span> {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// 重新请求上一级地址</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">this</span>.<span class="property">address</span> = <span class="variable language_">this</span>.<span class="property">addressAll</span>[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">const</span> res3 = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">$api</span>.<span class="title function_">getCityWeather</span>(<span class="variable language_">this</span>.<span class="property">address</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">if</span> (res3.<span class="property">status</span> === <span class="string">"ok"</span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">this</span>.$notify({</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="attr">title</span>: <span class="string">"查询成功"</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="attr">type</span>: <span class="string">"success"</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            });</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">this</span>.<span class="property">weathData</span> = res3;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">this</span>.<span class="property">weathData</span>.<span class="property">daily_forecast</span>.<span class="title function_">shift</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">this</span>.<span class="property">weathData</span>.<span class="property">daily_forecast</span>.<span class="title function_">splice</span>(<span class="number">3</span>, <span class="number">3</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          } <span class="keyword">else</span> {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// 2.彻底无法找到该地</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">this</span>.$message({</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="attr">message</span>: <span class="string">"抱歉，无法获取该地相关信息"</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="attr">type</span>: <span class="string">"error"</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            });</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          }</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        }</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      }</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 背景图片切换</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="title function_">bgChange</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    },</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 背景图片切换</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">bgChange</span>(<span class="params"></span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> weather = <span class="variable language_">this</span>.<span class="property">weathData</span>.<span class="property">now</span>.<span class="property">cond</span>.<span class="property">txt</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">coverImgUrl</span> = <span class="built_in">require</span>(<span class="string">`@/assets/img/<span class="subst">${weather}</span>.jpg`</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    },</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  },</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">};</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.home</span> {</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="keyword">@mixin</span> xy($<span class="attribute">top</span>: auto, $<span class="attribute">right</span>: auto, $<span class="attribute">bottom</span>: auto, $<span class="attribute">left</span>: auto) {</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">top</span>: $top;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">right</span>: $right;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">bottom</span>: $bottom;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">left</span>: $left;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  }</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="keyword">@mixin</span> wh($wid, $hei) {</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">width</span>: $wid;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">height</span>: $hei;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  }</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="keyword">@mixin</span> font($size, $<span class="attribute">fw</span>: bold, $<span class="attribute">color</span>: #fff) {</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">font-size</span>: $size;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">font-weight</span>: $fw;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">color</span>: $color;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  }</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">position</span>: relative;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  // <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"~"</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">background-repeat</span>: no-repeat;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">background-position</span>: center center;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">background-size</span>: cover;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="selector-class">.weather-box</span> {</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">position</span>: absolute;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">text-align</span>: center;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">z-index</span>: <span class="number">999</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="keyword">@include</span> xy(<span class="number">5%</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="number">50%</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-class">.now-cond</span> {</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-tag">h1</span> {</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="keyword">@include</span> font(<span class="number">20px</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      }</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-class">.address</span>,</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-class">.upTime</span> {</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="keyword">@include</span> font(<span class="number">20px</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">text-shadow</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">#000</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      }</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-class">.condTxt</span> {</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="keyword">@include</span> font(<span class="number">80px</span>, bolder);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">text-shadow</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">#ccc</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      }</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-class">.wind</span>,</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-class">.tmp</span> {</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="keyword">@include</span> font(<span class="number">20px</span>, bolder, #<span class="number">000</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">text-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">5px</span> <span class="built_in">rgb</span>(<span class="number">144</span>, <span class="number">149</span>, <span class="number">216</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      }</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    }</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-class">.tip</span> {</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-tag">h1</span> {</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="keyword">@include</span> font(<span class="number">50px</span>, bolder);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">text-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">5px</span> <span class="built_in">rgb</span>(<span class="number">144</span>, <span class="number">149</span>, <span class="number">216</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      }</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    }</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  }</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">}</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>主要的代码都在上面，之前测试是可以的， 但是现在由于接口更新的问题， 现在可能访问不了：</p>
<p>效果就像是下面这样：</p>
<img src="/posts/c2ba5eb1/c2ba5eb1/image-20230227163857686.png" class="" title="image-20230227163857686">

<p>大致的代码就是这样子的，也是一个简单的练手的一个小项目</p>
</body></html>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>天气预报</tag>
      </tags>
  </entry>
  <entry>
    <title>羊了个羊通关及关卡数据分析</title>
    <url>/posts/60227.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="羊了个羊破解"><a href="#羊了个羊破解" class="headerlink" title="羊了个羊破解"></a>羊了个羊破解</h1><h2 id="9月20号更新后"><a href="#9月20号更新后" class="headerlink" title="9月20号更新后"></a>9月20号更新后</h2><p>9.20以后，关卡的卡片数据地址变了， 依旧是利用 fiddler 的修改响应的功能，也就是FiddlerScript功能中的onBeforeResponse函数。此函数可以对响应数据进行修改，思路是将第二关的卡片的类型全部改为一样的或者改为无图案的空卡</p>
<span id="more"></span>

<p>我们直接上代码：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oSession.<span class="title function_">uriContains</span>(<span class="string">"https://cat-match-static.easygame2021.com/maps/"</span>)){ <span class="comment">//匹配关卡数据</span></span><br><span class="line">    <span class="keyword">if</span> (oSession.<span class="property">responseCode</span> == <span class="number">200</span>) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> responseJsonString=oSession.<span class="title class_">GetResponseBodyAsString</span>();                   <span class="comment">//获取response中的JSON数据，以字符串的形式接收</span></span><br><span class="line">        <span class="keyword">var</span> responseJSON=<span class="title class_">Fiddler</span>.<span class="property">WebFormats</span>.<span class="property">JSON</span>.<span class="title class_">JsonDecode</span>(responseJsonString);    <span class="comment">//转化为JSON数据</span></span><br><span class="line">        <span class="keyword">var</span> levelKey = responseJSON.<span class="property">JSONObject</span>[<span class="string">"levelKey"</span>];  <span class="comment">//获取“levelKey”中的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//80001是第一关，很简单，不需要修改。</span></span><br><span class="line">        <span class="comment">//如果不是第一关，则进行卡片数据的修改</span></span><br><span class="line">        <span class="keyword">if</span>(levelKey!=<span class="string">"80001"</span>){</span><br><span class="line">            <span class="comment">//将卡片类型数据改为错误的属性名，这样会导致所有卡片为空白卡</span></span><br><span class="line">            <span class="keyword">var</span> blankData = responseJsonString.<span class="title function_">replace</span>(<span class="string">"blockTypeData"</span>, <span class="string">"xxxblockTypeData"</span>); </span><br><span class="line">            oSession.<span class="title function_">utilSetResponseBody</span>(blankData);   <span class="comment">//替换ResponseBody中的JSON数据</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>代码放到图中位置。点击 Save Script 生效，然后重新打开羊了个羊小程序进行闯关就行。<br>此时第二关所有卡片变为了空白卡，急速点击完卡片就闯关成功了，闯关成绩会正确提交至服务器</p>
<h2 id="通关方法："><a href="#通关方法：" class="headerlink" title="通关方法："></a>通关方法：</h2><p>我只说利用 fiddler 的修改响应的功能，也就是FiddlerScript功能中的onBeforeResponse函数。<br>此函数可以对响应数据进行修改，思路很明确，目的就是要把羊了个羊关卡改为超低难度。</p>
<p>直接上代码：</p>
<p>if (oSession.uriContains(“<a href="https://cat-match.easygame2021.com/sheep/v1/game/map_info?map_id=&quot;))%7B">https://cat-match.easygame2021.com/sheep/v1/game/map_info?map_id=")){</a> //匹配关卡地址</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oSession.<span class="title function_">uriContains</span>(<span class="string">"https://cat-match.easygame2021.com/sheep/v1/game/map_info?map_id="</span>)){ <span class="comment">//匹配关卡地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oSession.<span class="property">responseCode</span> == <span class="number">200</span>) {</span><br><span class="line">        <span class="keyword">var</span> responseJsonString=oSession.<span class="title class_">GetResponseBodyAsString</span>();                   <span class="comment">//获取response中的JSON数据，以字符串的形式接收</span></span><br><span class="line">        <span class="keyword">var</span> responseJSON=<span class="title class_">Fiddler</span>.<span class="property">WebFormats</span>.<span class="property">JSON</span>.<span class="title class_">JsonDecode</span>(responseJsonString);    <span class="comment">//转化为JSON数据</span></span><br><span class="line">        <span class="keyword">var</span> data = responseJSON.<span class="property">JSONObject</span>[<span class="string">"data"</span>];  <span class="comment">//获取“data”中的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(data.<span class="title class_">Contains</span>(<span class="string">"map_data"</span>)){        <span class="comment">//如果data中的数据中，包含“map_data”字段</span></span><br><span class="line"></span><br><span class="line">        data[<span class="string">"map_data"</span>]=<span class="string">"{\"widthNum\":8,\"heightNum\":10,\"levelKey\":80001,\"blockTypeData\":{\"1\":1},\"levelData\":{\"1\":[{\"id\":\"1-16-16\",\"type\":0,\"rolNum\":16,\"rowNum\":16,\"layerNum\":1,\"moldType\":1,\"blockNode\":null},{\"id\":\"1-28-16\",\"type\":0,\"rolNum\":28,\"rowNum\":16,\"layerNum\":1,\"moldType\":1,\"blockNode\":null},{\"id\":\"1-40-16\",\"type\":0,\"rolNum\":40,\"rowNum\":16,\"layerNum\":1,\"moldType\":1,\"blockNode\":null}]}}"</span>;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> myResponseJSON= <span class="title class_">Fiddler</span>.<span class="property">WebFormats</span>.<span class="property">JSON</span>.<span class="title class_">JsonEncode</span>(responseJSON.<span class="property">JSONObject</span>);  <span class="comment">//转换回字符串</span></span><br><span class="line"></span><br><span class="line">        oSession.<span class="title function_">utilSetResponseBody</span>(myResponseJSON);   <span class="comment">//替换ResponseBody中的JSON数据</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码放到图中位置。点击 Save Script 生效，然后重新打开羊了个羊小程序进行闯关就行。</p>
<p>所有关卡都只有三个草丛卡片。</p>
<h2 id="关卡数据分析"><a href="#关卡数据分析" class="headerlink" title="关卡数据分析"></a>关卡数据分析</h2><p>关卡代码：</p>
<p>以下数据为仅三张草丛卡片，并不是原本数据，原本数据量较多较为啰嗦</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"err_code"</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"err_msg"</span><span class="punctuation">:</span> <span class="string">""</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"data"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"62ccde7d3dd1931da84a84e2"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"created_at"</span><span class="punctuation">:</span> <span class="string">"2022-07-12T02:37:49.515Z"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"updated_at"</span><span class="punctuation">:</span> <span class="string">"2022-09-14T15:53:23.508Z"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"map_option"</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"map_data"</span><span class="punctuation">:</span> <span class="string">"{\"widthNum\":8,\"heightNum\":10,\"levelKey\":80001,\"blockTypeData\":{\"1\":1},\"levelData\":{\"1\":[{\"id\":\"1-16-16\",\"type\":0,\"rolNum\":16,\"rowNum\":16,\"layerNum\":1,\"moldType\":1,\"blockNode\":null},{\"id\":\"1-28-16\",\"type\":0,\"rolNum\":28,\"rowNum\":16,\"layerNum\":1,\"moldType\":1,\"blockNode\":null},{\"id\":\"1-40-16\",\"type\":0,\"rolNum\":40,\"rowNum\":16,\"layerNum\":1,\"moldType\":1,\"blockNode\":null}]}}"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"map_id"</span><span class="punctuation">:</span> <span class="number">80001</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>其中关于卡片的代码为 map_data 的内容，将其去除转义后：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"widthNum"</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"heightNum"</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"levelKey"</span><span class="punctuation">:</span> <span class="number">80001</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"blockTypeData"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">                <span class="attr">"1"</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">        <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"levelData"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">                <span class="attr">"1"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">{</span></span><br><span class="line">                        <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"1-16-16"</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"rolNum"</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"rowNum"</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"layerNum"</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"moldType"</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"blockNode"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">                <span class="punctuation">}</span><span class="punctuation">,</span> <span class="punctuation">{</span></span><br><span class="line">                        <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"1-28-16"</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"rolNum"</span><span class="punctuation">:</span> <span class="number">28</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"rowNum"</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"layerNum"</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"moldType"</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"blockNode"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">                <span class="punctuation">}</span><span class="punctuation">,</span> <span class="punctuation">{</span></span><br><span class="line">                        <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"1-40-16"</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"rolNum"</span><span class="punctuation">:</span> <span class="number">40</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"rowNum"</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"layerNum"</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"moldType"</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"blockNode"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">                <span class="punctuation">}</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="blockTypeData-卡片类型及组数量（一组三张）"><a href="#blockTypeData-卡片类型及组数量（一组三张）" class="headerlink" title="blockTypeData 卡片类型及组数量（一组三张）"></a>blockTypeData 卡片类型及组数量（一组三张）</h4><p>{“1”: 1} ，其中”1”代表草丛卡片，1代表1组（三张卡）。</p>
<h5 id="levelData-层卡片数据。每层元素的数据量总和，要与blockTypeData的卡片数量一致。"><a href="#levelData-层卡片数据。每层元素的数据量总和，要与blockTypeData的卡片数量一致。" class="headerlink" title="levelData 层卡片数据。每层元素的数据量总和，要与blockTypeData的卡片数量一致。"></a>levelData 层卡片数据。每层元素的数据量总和，要与blockTypeData的卡片数量一致。</h5><h6 id="1-id-卡片坐标；"><a href="#1-id-卡片坐标；" class="headerlink" title="1.id 卡片坐标；"></a>1.id 卡片坐标；</h6><h6 id="2-layerNum-第几层；"><a href="#2-layerNum-第几层；" class="headerlink" title="2. layerNum 第几层；"></a>2. layerNum 第几层；</h6><h6 id="3-rolNum-列，与id中的保持一致"><a href="#3-rolNum-列，与id中的保持一致" class="headerlink" title="3.rolNum 列，与id中的保持一致"></a>3.rolNum 列，与id中的保持一致</h6><h6 id="4-rowNum-行，与id中的保持一致"><a href="#4-rowNum-行，与id中的保持一致" class="headerlink" title="4.rowNum 行，与id中的保持一致"></a>4.rowNum 行，与id中的保持一致</h6><p>其他参数不再分析了，有疑问的回复。</p>
</body></html>]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>破解游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>用网页实现一个简易的时钟</title>
    <url>/posts/acb2dccb.html</url>
    <content><![CDATA[<html><head></head><body><p>很久没有更新文章了， 网上看到一个时钟的项目， 让我产生了非常强烈的兴趣， 下面是这种效果的实现方式， 朋友们也可以将它复制到自己的网站或者项目中</p>
<p>平时如果你没法专注的时候， 可以将这个效果做成一个网页， 个人感觉前面有一个时钟会让你意识到时间的流逝从而尽量的提高自己的工作效率</p>
<span id="more"></span>

<p>先看看下面的效果：</p>
<img src="/posts/acb2dccb/acb2dccb/loading.gif" class="" title="loading">

<p>其实这样的效果实现起来并不是太难， 我们需要做的就是先分析它的结构， 我们来看看代码：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock"</span> <span class="attr">aria-label</span>=<span class="string">"00:00:00 AM"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__block clock__block--delay2"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span> <span class="attr">data-time-group</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__digit-group"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__digits"</span> <span class="attr">data-time</span>=<span class="string">"a"</span>&gt;</span>00<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__digits"</span> <span class="attr">data-time</span>=<span class="string">"b"</span>&gt;</span>00<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__colon"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__block clock__block--delay1"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span> <span class="attr">data-time-group</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__digit-group"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__digits"</span> <span class="attr">data-time</span>=<span class="string">"a"</span>&gt;</span>00<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__digits"</span> <span class="attr">data-time</span>=<span class="string">"b"</span>&gt;</span>00<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__colon"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__block"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span> <span class="attr">data-time-group</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__digit-group"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__digits"</span> <span class="attr">data-time</span>=<span class="string">"a"</span>&gt;</span>00<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__digits"</span> <span class="attr">data-time</span>=<span class="string">"b"</span>&gt;</span>00<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__block clock__block--delay2 clock__block--small"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span> <span class="attr">data-time-group</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__digit-group"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__digits"</span> <span class="attr">data-time</span>=<span class="string">"a"</span>&gt;</span>PM<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clock__digits"</span> <span class="attr">data-time</span>=<span class="string">"b"</span>&gt;</span>AM<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>下面是css代码：</p>
<p>先用通配符选择器初始化网页，我们需要将box-sizing 的值设置为boder-box，就是边框盒</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* {</span><br><span class="line">	border: 0;</span><br><span class="line">	box-sizing: border-box;</span><br><span class="line">	margin: 0;</span><br><span class="line">	padding: 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>来看看body的代码部分：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="built_in">var</span>(--bg);</span><br><span class="line">	<span class="attribute">color</span>: <span class="built_in">var</span>(--fg);</span><br><span class="line">	<span class="attribute">font</span>: <span class="number">1em</span>/<span class="number">1.5</span> <span class="string">"DM Sans"</span>, sans-serif;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">	<span class="attribute">display</span>: grid;</span><br><span class="line">	place-items: center;</span><br><span class="line">	<span class="attribute">transition</span>:</span><br><span class="line">		background-color <span class="built_in">var</span>(--trans-dur),</span><br><span class="line">		color <span class="built_in">var</span>(--trans-dur);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们来看看全部的代码;</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line">* {</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-pseudo">:root</span> {</span><br><span class="line">	<span class="attr">--hue</span>: <span class="number">223</span>;</span><br><span class="line">	<span class="attr">--bg</span>: <span class="built_in">hsl</span>(<span class="built_in">var</span>(--hue),<span class="number">90%</span>,<span class="number">90%</span>);</span><br><span class="line">	<span class="attr">--fg</span>: <span class="built_in">hsl</span>(<span class="built_in">var</span>(--hue),<span class="number">10%</span>,<span class="number">10%</span>);</span><br><span class="line">	<span class="attr">--primary</span>: <span class="built_in">hsl</span>(<span class="built_in">var</span>(--hue),<span class="number">90%</span>,<span class="number">55%</span>);</span><br><span class="line">	<span class="attr">--trans-dur</span>: <span class="number">0.3s</span>;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">16px</span> + (<span class="number">20</span> - <span class="number">16</span>) * (<span class="number">100vw</span> - <span class="number">320px</span>) / (<span class="number">1280</span> - <span class="number">320</span>));</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">body</span> {</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="built_in">var</span>(--bg);</span><br><span class="line">	<span class="attribute">color</span>: <span class="built_in">var</span>(--fg);</span><br><span class="line">	<span class="attribute">font</span>: <span class="number">1em</span>/<span class="number">1.5</span> <span class="string">"DM Sans"</span>, sans-serif;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">	<span class="attribute">display</span>: grid;</span><br><span class="line">	place-items: center;</span><br><span class="line">	<span class="attribute">transition</span>:</span><br><span class="line">		background-color <span class="built_in">var</span>(--trans-dur),</span><br><span class="line">		color <span class="built_in">var</span>(--trans-dur);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clock</span> {</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">flex-direction</span>: column;</span><br><span class="line">	<span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">	<span class="attribute">align-items</span>: center;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.clock__block</span> {</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="built_in">hsl</span>(<span class="built_in">var</span>(--hue),<span class="number">10%</span>,<span class="number">90%</span>);</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">0.5rem</span>;</span><br><span class="line">	<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1rem</span> <span class="number">2rem</span> <span class="built_in">hsla</span>(<span class="built_in">var</span>(--hue),<span class="number">90%</span>,<span class="number">50%</span>,<span class="number">0.3</span>);</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">2</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0.75rem</span>;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;</span><br><span class="line">	<span class="attribute">text-align</span>: center;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">6rem</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">6rem</span>;</span><br><span class="line">	<span class="attribute">transition</span>:</span><br><span class="line">		background-color <span class="built_in">var</span>(--trans-dur),</span><br><span class="line">		box-shadow <span class="built_in">var</span>(--trans-dur);</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.clock__block--small</span> {</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">0.25rem</span>;</span><br><span class="line">	<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.5rem</span> <span class="number">2rem</span> <span class="built_in">hsla</span>(<span class="built_in">var</span>(--hue),<span class="number">90%</span>,<span class="number">50%</span>,<span class="number">0.3</span>);</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">3</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">3rem</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">3rem</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.clock__colon</span> {</span><br><span class="line">	<span class="attribute">display</span>: none;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">	<span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">	<span class="attribute">position</span>: relative;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.clock__colon</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-class">.clock__colon</span><span class="selector-pseudo">:after</span> {</span><br><span class="line">	<span class="attribute">background-color</span>: currentColor;</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">	<span class="attribute">display</span>: block;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">top</span>: -<span class="number">0.05em</span>;</span><br><span class="line">	<span class="attribute">left</span>: -<span class="number">0.05em</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">0.1em</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">0.1em</span>;</span><br><span class="line">	<span class="attribute">transition</span>: background-color <span class="built_in">var</span>(--trans-dur);</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.clock__colon</span><span class="selector-pseudo">:before</span> {</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">200%</span>);</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.clock__colon</span><span class="selector-pseudo">:after</span> {</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">200%</span>);	</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.clock__digit-group</span> {</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">flex-direction</span>: column-reverse;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.clock__digits</span> {</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.clock__block--bounce</span> {</span><br><span class="line">	<span class="attribute">animation</span>: bounce <span class="number">0.75s</span>; </span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.clock__block--bounce</span> <span class="selector-class">.clock__digit-group</span> {</span><br><span class="line">	<span class="attribute">animation</span>: roll <span class="number">0.75s</span> ease-in-out forwards; </span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.clock__block--delay1</span>,</span><br><span class="line"><span class="selector-class">.clock__block--delay1</span> <span class="selector-class">.clock__digit-group</span> {</span><br><span class="line">	<span class="attribute">animation-delay</span>: <span class="number">0.1s</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.clock__block--delay2</span>,</span><br><span class="line"><span class="selector-class">.clock__block--delay2</span> <span class="selector-class">.clock__digit-group</span> {</span><br><span class="line">	<span class="attribute">animation-delay</span>: <span class="number">0.2s</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Dark theme */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: dark) {</span><br><span class="line">	<span class="selector-pseudo">:root</span> {</span><br><span class="line">		<span class="attr">--bg</span>: <span class="built_in">hsl</span>(<span class="built_in">var</span>(--hue),<span class="number">10%</span>,<span class="number">10%</span>);</span><br><span class="line">		<span class="attr">--fg</span>: <span class="built_in">hsl</span>(<span class="built_in">var</span>(--hue),<span class="number">10%</span>,<span class="number">90%</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="selector-class">.clock__block</span> {</span><br><span class="line">		<span class="attribute">background-color</span>: <span class="built_in">hsl</span>(<span class="built_in">var</span>(--hue),<span class="number">90%</span>,<span class="number">40%</span>);</span><br><span class="line">		<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1rem</span> <span class="number">2rem</span> <span class="built_in">hsla</span>(<span class="built_in">var</span>(--hue),<span class="number">90%</span>,<span class="number">60%</span>,<span class="number">0.4</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="selector-class">.clock__block--small</span> {</span><br><span class="line">		<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.5rem</span> <span class="number">2rem</span> <span class="built_in">hsla</span>(<span class="built_in">var</span>(--hue),<span class="number">90%</span>,<span class="number">60%</span>,<span class="number">0.4</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Beyond mobile */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) {</span><br><span class="line">	<span class="selector-class">.clock</span> {</span><br><span class="line">		<span class="attribute">flex-direction</span>: row;</span><br><span class="line">	}</span><br><span class="line">	<span class="selector-class">.clock__colon</span> {</span><br><span class="line">		<span class="attribute">display</span>: inherit;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Animations */</span></span><br><span class="line"><span class="keyword">@keyframes</span> bounce {</span><br><span class="line">	<span class="selector-tag">from</span>,</span><br><span class="line">	<span class="selector-tag">to</span> {</span><br><span class="line">		<span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">		<span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="number">50%</span> {</span><br><span class="line">		<span class="attribute">animation-timing-function</span>: ease-out;</span><br><span class="line">		<span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">15%</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">@keyframes</span> roll {</span><br><span class="line">	<span class="selector-tag">from</span> {</span><br><span class="line">		<span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="selector-tag">to</span> {</span><br><span class="line">		<span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个时候的效果图：</p>
<img src="/posts/acb2dccb/acb2dccb/image-20230223214114129.png" class="" title="image-20230223214114129">

<p>接下来就是JavaScript代码了， 这部分相对前面的部分， 我认为还是比较困难的</p>
<p>代码：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">"DOMContentLoaded"</span>,<span class="function">() =&gt;</span> {</span><br><span class="line">	<span class="keyword">const</span> clock = <span class="keyword">new</span> <span class="title class_">BouncyBlockClock</span>(<span class="string">".clock"</span>);</span><br><span class="line">});</span><br><span class="line"><span class="comment">//在全局添加监听事件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BouncyBlockClock</span> {</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">qs</span>) {</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(qs);</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">time</span> = { <span class="attr">a</span>: [], <span class="attr">b</span>: [] };</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">rollClass</span> = <span class="string">"clock__block--bounce"</span>;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">digitsTimeout</span> = <span class="literal">null</span>;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">rollTimeout</span> = <span class="literal">null</span>;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">mod</span> = <span class="number">0</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">		<span class="variable language_">this</span>.<span class="title function_">loop</span>();</span><br><span class="line">	}</span><br><span class="line">	<span class="title function_">animateDigits</span>(<span class="params"></span>) {</span><br><span class="line">		<span class="keyword">const</span> groups = <span class="variable language_">this</span>.<span class="property">el</span>.<span class="title function_">querySelectorAll</span>(<span class="string">"[data-time-group]"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="title class_">Array</span>.<span class="title function_">from</span>(groups).<span class="title function_">forEach</span>(<span class="function">(<span class="params">group,i</span>) =&gt;</span> {</span><br><span class="line">			<span class="keyword">const</span> { a, b } = <span class="variable language_">this</span>.<span class="property">time</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (a[i] !== b[i]) group.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="variable language_">this</span>.<span class="property">rollClass</span>);</span><br><span class="line">		});</span><br><span class="line"></span><br><span class="line">		<span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">rollTimeout</span>);</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">rollTimeout</span> = <span class="built_in">setTimeout</span>(<span class="variable language_">this</span>.<span class="property">removeAnimations</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>),<span class="number">900</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="title function_">displayTime</span>(<span class="params"></span>) {</span><br><span class="line">		<span class="comment">// screen reader time</span></span><br><span class="line">		<span class="keyword">const</span> timeDigits = [...<span class="variable language_">this</span>.<span class="property">time</span>.<span class="property">b</span>];</span><br><span class="line">		<span class="keyword">const</span> ap = timeDigits.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">el</span>.<span class="property">ariaLabel</span> = <span class="string">`<span class="subst">${timeDigits.join(<span class="string">":"</span>)}</span> <span class="subst">${ap}</span>`</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// displayed time</span></span><br><span class="line">		<span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">time</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">letter</span> =&gt;</span> {</span><br><span class="line">			<span class="keyword">const</span> letterEls = <span class="variable language_">this</span>.<span class="property">el</span>.<span class="title function_">querySelectorAll</span>(<span class="string">`[data-time="<span class="subst">${letter}</span>"]`</span>);</span><br><span class="line"></span><br><span class="line">			<span class="title class_">Array</span>.<span class="title function_">from</span>(letterEls).<span class="title function_">forEach</span>(<span class="function">(<span class="params">el,i</span>) =&gt;</span> {</span><br><span class="line">				el.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">time</span>[letter][i];</span><br><span class="line">			});</span><br><span class="line">		});</span><br><span class="line">	}</span><br><span class="line">	<span class="title function_">loop</span>(<span class="params"></span>) {</span><br><span class="line">		<span class="variable language_">this</span>.<span class="title function_">updateTime</span>();</span><br><span class="line">		<span class="variable language_">this</span>.<span class="title function_">displayTime</span>();</span><br><span class="line">		<span class="variable language_">this</span>.<span class="title function_">animateDigits</span>();</span><br><span class="line">		<span class="variable language_">this</span>.<span class="title function_">tick</span>();</span><br><span class="line">	}</span><br><span class="line">	<span class="title function_">removeAnimations</span>(<span class="params"></span>) {</span><br><span class="line">		<span class="keyword">const</span> groups = <span class="variable language_">this</span>.<span class="property">el</span>.<span class="title function_">querySelectorAll</span>(<span class="string">"[data-time-group]"</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="title class_">Array</span>.<span class="title function_">from</span>(groups).<span class="title function_">forEach</span>(<span class="function"><span class="params">group</span> =&gt;</span> {</span><br><span class="line">			group.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">rollClass</span>);</span><br><span class="line">		});</span><br><span class="line">	}</span><br><span class="line">	<span class="title function_">tick</span>(<span class="params"></span>) {</span><br><span class="line">		<span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">digitsTimeout</span>);</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">digitsTimeout</span> = <span class="built_in">setTimeout</span>(<span class="variable language_">this</span>.<span class="property">loop</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>),<span class="number">1e3</span>);	</span><br><span class="line">	}</span><br><span class="line">	<span class="title function_">updateTime</span>(<span class="params"></span>) {</span><br><span class="line">		<span class="keyword">const</span> rawDate = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Math</span>.<span class="title function_">ceil</span>(rawDate.<span class="title function_">getTime</span>() / <span class="number">1e3</span>) * <span class="number">1e3</span> + <span class="variable language_">this</span>.<span class="property">mod</span>);</span><br><span class="line">		<span class="keyword">let</span> h = date.<span class="title function_">getHours</span>();</span><br><span class="line">		<span class="keyword">const</span> m = date.<span class="title function_">getMinutes</span>();</span><br><span class="line">		<span class="keyword">const</span> s = date.<span class="title function_">getSeconds</span>();</span><br><span class="line">		<span class="keyword">const</span> ap = h &lt; <span class="number">12</span> ? <span class="string">"AM"</span> : <span class="string">"PM"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (h === <span class="number">0</span>) h = <span class="number">12</span>;</span><br><span class="line">		<span class="keyword">if</span> (h &gt; <span class="number">12</span>) h -= <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">time</span>.<span class="property">a</span> = [...<span class="variable language_">this</span>.<span class="property">time</span>.<span class="property">b</span>];</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">time</span>.<span class="property">b</span> = [</span><br><span class="line">			(h &lt; <span class="number">10</span> ? <span class="string">`0<span class="subst">${h}</span>`</span> : <span class="string">`<span class="subst">${h}</span>`</span>),</span><br><span class="line">			(m &lt; <span class="number">10</span> ? <span class="string">`0<span class="subst">${m}</span>`</span> : <span class="string">`<span class="subst">${m}</span>`</span>),</span><br><span class="line">			(s &lt; <span class="number">10</span> ? <span class="string">`0<span class="subst">${s}</span>`</span> : <span class="string">`<span class="subst">${s}</span>`</span>),</span><br><span class="line">			ap</span><br><span class="line">		];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">time</span>.<span class="property">a</span>.<span class="property">length</span>) <span class="variable language_">this</span>.<span class="property">time</span>.<span class="property">a</span> = [...<span class="variable language_">this</span>.<span class="property">time</span>.<span class="property">b</span>];</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个就是上面的整个过程的代码， 感兴趣的同学可以研究一下</p>
<p>喜欢的朋友们可以给我点个赞哟</p>
</body></html>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>时钟</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义指令</title>
    <url>/posts/58461.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><h2 id="面试官：你有写过自定义指令吗？自定义指令的应用场景有哪些？"><a href="#面试官：你有写过自定义指令吗？自定义指令的应用场景有哪些？" class="headerlink" title="面试官：你有写过自定义指令吗？自定义指令的应用场景有哪些？"></a>面试官：你有写过自定义指令吗？自定义指令的应用场景有哪些？</h2><img src="/posts/58461/58461/image-20221029210438085.png" class="" title="image-20221029210438085">

<h3 id="一、什么是指令"><a href="#一、什么是指令" class="headerlink" title="一、什么是指令"></a>一、什么是指令</h3><p>开始之前我们先学习一下指令系统这个词</p>
<span id="more"></span>

<p><strong>指令系统</strong>是计算机硬件的语言系统，也叫机器语言，它是系统程序员看到的计算机的主要属性。因此指令系统表征了计算机的基本功能决定了机器所要求的能力</p>
<p>在<code>vue</code>中提供了一套为数据驱动视图更为方便的操作，这些操作被称为指令系统</p>
<p>我们看到的<code>v-</code>开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能</p>
<p>除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，<code>Vue</code> 也允许注册自定义指令</p>
<p>指令使用的几种方式：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//会实例化一个指令，但这个指令没有参数 </span></span><br><span class="line"><span class="string">`v-xxx`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -- 将值传到指令中</span></span><br><span class="line"><span class="string">`v-xxx="value"`</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// -- 将字符串传入到指令中，如`v-html="'&lt;p&gt;内容&lt;/p&gt;'"`</span></span><br><span class="line"><span class="string">`v-xxx="'string'"`</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// -- 传参数（`arg`），如`v-bind:class="className"`</span></span><br><span class="line"><span class="string">`v-xxx:arg="value"`</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// -- 使用修饰符（`modifier`）</span></span><br><span class="line"><span class="string">`v-xxx:arg.modifier="value"`</span> </span><br></pre></td></tr></tbody></table></figure>

<h3 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h3><p>注册一个自定义指令有全局注册与局部注册</p>
<p>全局注册主要是通过<code>Vue.directive</code>方法进行注册</p>
<p><code>Vue.directive</code>第一个参数是指令的名字（不需要写上<code>v-</code>前缀），第二个参数可以是对象数据，也可以是一个指令函数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">'focus'</span>, {</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) {</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.<span class="title function_">focus</span>()  <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>局部注册通过在组件<code>options</code>选项中设置<code>directive</code>属性</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">directives</span>: {</span><br><span class="line">  <span class="attr">focus</span>: {</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) {</span><br><span class="line">      el.<span class="title function_">focus</span>() <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> property，如下：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;input v-focus /&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>自定义指令也像组件那样存在钩子函数：</p>
<ul>
<li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</li>
<li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)</li>
<li><code>update</code>：所在组件的 <code>VNode</code> 更新时调用，但是可能发生在其子 <code>VNode</code> 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新</li>
<li><code>componentUpdated</code>：指令所在组件的 <code>VNode</code> 及其子 <code>VNode</code> 全部更新后调用</li>
<li><code>unbind</code>：只调用一次，指令与元素解绑时调用</li>
</ul>
<p>所有的钩子函数的参数都有以下：</p>
<ul>
<li><p><code>el</code>：指令所绑定的元素，可以用来直接操作 <code>DOM</code></p>
</li>
<li><p>```<br>binding</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">：一个对象，包含以下</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>property</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  - `name`：指令名，不包括 `v-` 前缀。</span><br><span class="line">  - `value`：指令的绑定值，例如：`v-my-directive="1 + 1"` 中，绑定值为 `2`。</span><br><span class="line">  - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。</span><br><span class="line">  - `expression`：字符串形式的指令表达式。例如 `v-my-directive="1 + 1"` 中，表达式为 `"1 + 1"`。</span><br><span class="line">  - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `"foo"`。</span><br><span class="line">  - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`</span><br><span class="line"></span><br><span class="line">- `vnode`：`Vue` 编译生成的虚拟节点</span><br><span class="line"></span><br><span class="line">- `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用</span><br><span class="line"></span><br><span class="line">&gt; 除了 `el` 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 `dataset` 来进行</span><br><span class="line"></span><br><span class="line">举个例子：</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&lt;div v-demo="{ color: 'white', text: 'hello!' }"&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.directive('demo', function (el, binding) {</span><br><span class="line">    console.log(binding.value.color) // "white"</span><br><span class="line">    console.log(binding.value.text)  // "hello!"</span><br><span class="line">    })</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h3><p>使用自定义指令可以满足我们日常一些场景，这里给出几个自定义指令的案例：</p>
<ul>
<li>表单防止重复提交</li>
<li>图片懒加载</li>
<li>一键 Copy的功能</li>
</ul>
<h4 id="表单防止重复提交"><a href="#表单防止重复提交" class="headerlink" title="表单防止重复提交"></a>表单防止重复提交</h4><p>表单防止重复提交这种情况设置一个<code>v-throttle</code>自定义指令来实现</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 1.设置v-throttle自定义指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">'throttle'</span>, {</span><br><span class="line">  <span class="attr">bind</span>: <span class="function">(<span class="params">el, binding</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">let</span> throttleTime = binding.<span class="property">value</span>; <span class="comment">// 节流时间</span></span><br><span class="line">    <span class="keyword">if</span> (!throttleTime) { <span class="comment">// 用户若不设置节流时间，则默认2s</span></span><br><span class="line">      throttleTime = <span class="number">2000</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">let</span> cbFun;</span><br><span class="line">    el.<span class="title function_">addEventListener</span>(<span class="string">'click'</span>, <span class="function"><span class="params">event</span> =&gt;</span> {</span><br><span class="line">      <span class="keyword">if</span> (!cbFun) { <span class="comment">// 第一次执行</span></span><br><span class="line">        cbFun = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">          cbFun = <span class="literal">null</span>;</span><br><span class="line">        }, throttleTime);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        event &amp;&amp; event.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">      }</span><br><span class="line">    }, <span class="literal">true</span>);</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="comment">// 2.为button标签设置v-throttle自定义指令</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"sayHello"</span> <span class="attr">v-throttle</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h4><p>设置一个<code>v-lazy</code>自定义指令完成图片懒加载</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">LazyLoad</span> = {</span><br><span class="line">    <span class="comment">// install方法</span></span><br><span class="line">    <span class="title function_">install</span>(<span class="params">Vue,options</span>){</span><br><span class="line">    	  <span class="comment">// 代替图片的loading图</span></span><br><span class="line">        <span class="keyword">let</span> defaultSrc = options.<span class="property">default</span>;</span><br><span class="line">        <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">'lazy'</span>,{</span><br><span class="line">            <span class="title function_">bind</span>(<span class="params">el,binding</span>){</span><br><span class="line">                <span class="title class_">LazyLoad</span>.<span class="title function_">init</span>(el,binding.<span class="property">value</span>,defaultSrc);</span><br><span class="line">            },</span><br><span class="line">            <span class="title function_">inserted</span>(<span class="params">el</span>){</span><br><span class="line">                <span class="comment">// 兼容处理</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">'IntersectionObserver'</span> <span class="keyword">in</span> <span class="variable language_">window</span>){</span><br><span class="line">                    <span class="title class_">LazyLoad</span>.<span class="title function_">observe</span>(el);</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="title class_">LazyLoad</span>.<span class="title function_">listenerScroll</span>(el);</span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">            },</span><br><span class="line">        })</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="title function_">init</span>(<span class="params">el,val,def</span>){</span><br><span class="line">        <span class="comment">// data-src 储存真实src</span></span><br><span class="line">        el.<span class="title function_">setAttribute</span>(<span class="string">'data-src'</span>,val);</span><br><span class="line">        <span class="comment">// 设置src为loading图</span></span><br><span class="line">        el.<span class="title function_">setAttribute</span>(<span class="string">'src'</span>,def);</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 利用IntersectionObserver监听el</span></span><br><span class="line">    <span class="title function_">observe</span>(<span class="params">el</span>){</span><br><span class="line">        <span class="keyword">let</span> io = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function"><span class="params">entries</span> =&gt;</span> {</span><br><span class="line">            <span class="keyword">let</span> realSrc = el.<span class="property">dataset</span>.<span class="property">src</span>;</span><br><span class="line">            <span class="keyword">if</span>(entries[<span class="number">0</span>].<span class="property">isIntersecting</span>){</span><br><span class="line">                <span class="keyword">if</span>(realSrc){</span><br><span class="line">                    el.<span class="property">src</span> = realSrc;</span><br><span class="line">                    el.<span class="title function_">removeAttribute</span>(<span class="string">'data-src'</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        io.<span class="title function_">observe</span>(el);</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 监听scroll事件</span></span><br><span class="line">    <span class="title function_">listenerScroll</span>(<span class="params">el</span>){</span><br><span class="line">        <span class="keyword">let</span> handler = <span class="title class_">LazyLoad</span>.<span class="title function_">throttle</span>(<span class="title class_">LazyLoad</span>.<span class="property">load</span>,<span class="number">300</span>);</span><br><span class="line">        <span class="title class_">LazyLoad</span>.<span class="title function_">load</span>(el);</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">'scroll'</span>,<span class="function">() =&gt;</span> {</span><br><span class="line">            <span class="title function_">handler</span>(el);</span><br><span class="line">        });</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 加载真实图片</span></span><br><span class="line">    <span class="title function_">load</span>(<span class="params">el</span>){</span><br><span class="line">        <span class="keyword">let</span> windowHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line">        <span class="keyword">let</span> elTop = el.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span>;</span><br><span class="line">        <span class="keyword">let</span> elBtm = el.<span class="title function_">getBoundingClientRect</span>().<span class="property">bottom</span>;</span><br><span class="line">        <span class="keyword">let</span> realSrc = el.<span class="property">dataset</span>.<span class="property">src</span>;</span><br><span class="line">        <span class="keyword">if</span>(elTop - windowHeight&lt;<span class="number">0</span>&amp;&amp;elBtm &gt; <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span>(realSrc){</span><br><span class="line">                el.<span class="property">src</span> = realSrc;</span><br><span class="line">                el.<span class="title function_">removeAttribute</span>(<span class="string">'data-src'</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 节流</span></span><br><span class="line">    <span class="title function_">throttle</span>(<span class="params">fn,delay</span>){</span><br><span class="line">        <span class="keyword">let</span> timer; </span><br><span class="line">        <span class="keyword">let</span> prevTime;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>){</span><br><span class="line">            <span class="keyword">let</span> currTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">            <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">            <span class="keyword">if</span>(!prevTime) prevTime = currTime;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(currTime - prevTime &gt; delay){</span><br><span class="line">                prevTime = currTime;</span><br><span class="line">                fn.<span class="title function_">apply</span>(context,args);</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">                prevTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">                fn.<span class="title function_">apply</span>(context,args);</span><br><span class="line">            },delay);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">LazyLoad</span>;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="一键-Copy的功能"><a href="#一键-Copy的功能" class="headerlink" title="一键 Copy的功能"></a>一键 Copy的功能</h4><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { <span class="title class_">Message</span> } <span class="keyword">from</span> <span class="string">'ant-design-vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vCopy = { <span class="comment">//</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    bind 钩子函数，第一次绑定时调用，可以在这里做初始化设置</span></span><br><span class="line"><span class="comment">    el: 作用的 dom 对象</span></span><br><span class="line"><span class="comment">    value: 传给指令的值，也就是我们要 copy 的值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="title function_">bind</span>(<span class="params">el, { value }</span>) {</span><br><span class="line">    el.<span class="property">$value</span> = value; <span class="comment">// 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到</span></span><br><span class="line">    el.<span class="property">handler</span> = <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">if</span> (!el.<span class="property">$value</span>) {</span><br><span class="line">      <span class="comment">// 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意</span></span><br><span class="line">        <span class="title class_">Message</span>.<span class="title function_">warning</span>(<span class="string">'无复制内容'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 动态创建 textarea 标签</span></span><br><span class="line">      <span class="keyword">const</span> textarea = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">'textarea'</span>);</span><br><span class="line">      <span class="comment">// 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域</span></span><br><span class="line">      textarea.<span class="property">readOnly</span> = <span class="string">'readonly'</span>;</span><br><span class="line">      textarea.<span class="property">style</span>.<span class="property">position</span> = <span class="string">'absolute'</span>;</span><br><span class="line">      textarea.<span class="property">style</span>.<span class="property">left</span> = <span class="string">'-9999px'</span>;</span><br><span class="line">      <span class="comment">// 将要 copy 的值赋给 textarea 标签的 value 属性</span></span><br><span class="line">      textarea.<span class="property">value</span> = el.<span class="property">$value</span>;</span><br><span class="line">      <span class="comment">// 将 textarea 插入到 body 中</span></span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(textarea);</span><br><span class="line">      <span class="comment">// 选中值并复制</span></span><br><span class="line">      textarea.<span class="title function_">select</span>();</span><br><span class="line">      <span class="comment">// textarea.setSelectionRange(0, textarea.value.length);</span></span><br><span class="line">      <span class="keyword">const</span> result = <span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">'Copy'</span>);</span><br><span class="line">      <span class="keyword">if</span> (result) {</span><br><span class="line">        <span class="title class_">Message</span>.<span class="title function_">success</span>(<span class="string">'复制成功'</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(textarea);</span><br><span class="line">    };</span><br><span class="line">    <span class="comment">// 绑定点击事件，就是所谓的一键 copy 啦</span></span><br><span class="line">    el.<span class="title function_">addEventListener</span>(<span class="string">'click'</span>, el.<span class="property">handler</span>);</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 当传进来的值更新的时候触发</span></span><br><span class="line">  <span class="title function_">componentUpdated</span>(<span class="params">el, { value }</span>) {</span><br><span class="line">    el.<span class="property">$value</span> = value;</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 指令与元素解绑的时候，移除事件绑定</span></span><br><span class="line">  <span class="title function_">unbind</span>(<span class="params">el</span>) {</span><br><span class="line">    el.<span class="title function_">removeEventListener</span>(<span class="string">'click'</span>, el.<span class="property">handler</span>);</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> vCopy;</span><br></pre></td></tr></tbody></table></figure>


<p>关于自定义指令还有很多应用场景，如：拖拽指令、页面水印、权限校验等等应用场景</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li>
<li><a href="https://juejin.cn/post/6844904197448531975#heading-5">https://juejin.cn/post/6844904197448531975#heading-5</a></li>
<li><a href="https://www.cnblogs.com/chenwenhao/p/11924161.html#_label2">https://www.cnblogs.com/chenwenhao/p/11924161.html#_label2</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>自定义指令</tag>
      </tags>
  </entry>
  <entry>
    <title>说说var, let , const的区别</title>
    <url>/posts/59328.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="说说var-let-const的区别"><a href="#说说var-let-const的区别" class="headerlink" title="说说var, let , const的区别"></a>说说var, let , const的区别</h1><h2 id="面试官：说说var、let、const之间的区别"><a href="#面试官：说说var、let、const之间的区别" class="headerlink" title="面试官：说说var、let、const之间的区别"></a>面试官：说说var、let、const之间的区别</h2><img src="/posts/59328/59328/image-20221121065028704.png" class="" title="image-20221121065028704">

<h3 id="一、var"><a href="#一、var" class="headerlink" title="一、var"></a>一、var</h3><p>在ES5中，顶层对象的属性和全局变量是等价的，用<code>var</code>声明的变量既是全局变量，也是顶层变量</p>
<p>注意：顶层对象，在浏览器环境指的是<code>window</code>对象，在 <code>Node</code> 指的是<code>global</code>对象</p>
<span id="more"></span>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>) <span class="comment">// 10</span></span><br></pre></td></tr></tbody></table></figure>

<p>使用<code>var</code>声明的变量存在变量提升的情况</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br></pre></td></tr></tbody></table></figure>

<p>在编译阶段，编译器会将其变成以下执行</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">a = <span class="number">20</span></span><br></pre></td></tr></tbody></table></figure>

<p>使用<code>var</code>，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span> </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 30</span></span><br></pre></td></tr></tbody></table></figure>

<p>在函数中使用使用<code>var</code>声明变量时候，该变量是局部的</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>){</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">30</span></span><br><span class="line">}</span><br><span class="line"><span class="title function_">change</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 20 </span></span><br></pre></td></tr></tbody></table></figure>

<p>而如果在函数内不使用<code>var</code>，该变量是全局的</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>){</span><br><span class="line">   a = <span class="number">30</span></span><br><span class="line">}</span><br><span class="line"><span class="title function_">change</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 30 </span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="二、let"><a href="#二、let" class="headerlink" title="二、let"></a>二、let</h3><p><code>let</code>是<code>ES6</code>新增的命令，用来声明变量</p>
<p>用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line">}</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// ReferenceError: a is not defined.</span></span><br></pre></td></tr></tbody></table></figure>

<p>不存在变量提升</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<p>这表示在声明它之前，变量<code>a</code>是不存在的，这时如果用到它，就会抛出一个错误</p>
<p>只要块级作用域内存在<code>let</code>命令，这个区域就不再受外部影响</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) {</span><br><span class="line">    a = <span class="string">'abc'</span> <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">let</span> a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用<code>let</code>声明变量前，该变量都不可用，也就是大家常说的“暂时性死区”</p>
<p>最后，<code>let</code>不允许在相同作用域中重复声明</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">30</span></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意的是相同作用域，下面这种情况是不会报错的</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">30</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因此，我们不能在函数内部重新声明参数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">arg</span>) {</span><br><span class="line">  <span class="keyword">let</span> arg;</span><br><span class="line">}</span><br><span class="line"><span class="title function_">func</span>()</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier 'arg' has already been declared</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="三、const"><a href="#三、const" class="headerlink" title="三、const"></a>三、const</h3><p><code>const</code>声明一个只读的常量，一旦声明，常量的值就不能改变</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></tbody></table></figure>

<p>这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a;</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果之前用<code>var</code>或<code>let</code>声明过变量，再用<code>const</code>声明同样会报错</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">30</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span></span><br><span class="line"><span class="comment">// 都会报错</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>const</code>实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动</p>
<p>对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量</p>
<p>对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的，并不能确保改变量的结构不变</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = {};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.<span class="property">prop</span> = <span class="number">123</span>;</span><br><span class="line">foo.<span class="property">prop</span> <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = {}; <span class="comment">// TypeError: "foo" is read-only</span></span><br></pre></td></tr></tbody></table></figure>

<p>其它情况，<code>const</code>与<code>let</code>一致</p>
<h3 id="四、区别"><a href="#四、区别" class="headerlink" title="四、区别"></a>四、区别</h3><p><code>var</code>、<code>let</code>、<code>const</code>三者区别可以围绕下面五点展开：</p>
<ul>
<li>变量提升</li>
<li>暂时性死区</li>
<li>块级作用域</li>
<li>重复声明</li>
<li>修改声明的变量</li>
<li>使用</li>
</ul>
<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var`声明的变量存在变量提升，即变量可以在声明之前调用，值为`undefined</span><br></pre></td></tr></tbody></table></figure>

<p><code>let</code>和<code>const</code>不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// Cannot access 'b' before initialization</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c)  <span class="comment">// Cannot access 'c' before initialization</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p><code>var</code>不存在暂时性死区</p>
<p><code>let</code>和<code>const</code>存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// Cannot access 'b' before initialization</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c)  <span class="comment">// Cannot access 'c' before initialization</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p><code>var</code>不存在块级作用域</p>
<p><code>let</code>和<code>const</code>存在块级作用域</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line">}</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line">}</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">const</span> c = <span class="number">20</span></span><br><span class="line">}</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c)  <span class="comment">// Uncaught ReferenceError: c is not defined</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h4><p><code>var</code>允许重复声明变量</p>
<p><code>let</code>和<code>const</code>在同一作用域不允许重复声明变量</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span> <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span> <span class="comment">// Identifier 'b' has already been declared</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">20</span> <span class="comment">// Identifier 'c' has already been declared</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="修改声明的变量"><a href="#修改声明的变量" class="headerlink" title="修改声明的变量"></a>修改声明的变量</h4><p><code>var</code>和<code>let</code>可以</p>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">a = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//let</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">10</span></span><br><span class="line">c = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">// Uncaught TypeError: Assignment to constant variable</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>能用<code>const</code>的情况尽量使用<code>const</code>，其他情况下大多数使用<code>let</code>，避免使用<code>var</code></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>var let const</tag>
      </tags>
  </entry>
  <entry>
    <title>说说vue中的diff算法</title>
    <url>/posts/11481.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="说说vue中的diff算法"><a href="#说说vue中的diff算法" class="headerlink" title="说说vue中的diff算法"></a>说说vue中的diff算法</h1><h2 id="面试官：你了解vue的diff算法吗？说说看"><a href="#面试官：你了解vue的diff算法吗？说说看" class="headerlink" title="面试官：你了解vue的diff算法吗？说说看"></a>面试官：你了解vue的diff算法吗？说说看</h2><img src="/posts/11481/11481/image-20221102070413262.png" class="" title="image-20221102070413262">

<h3 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h3><p><code>diff</code> 算法是一种通过同层的树节点进行比较的高效算法</p>
<p>其有两个特点：</p>
<span id="more"></span>

<ul>
<li>比较只会在同层级进行, 不会跨层级比较</li>
<li>在diff比较的过程中，循环从两边向中间比较</li>
</ul>
<p><code>diff</code> 算法在很多场景下都有应用，在 <code>vue</code> 中，作用于虚拟 <code>dom</code> 渲染成真实 <code>dom</code> 的新旧 <code>VNode</code> 节点比较</p>
<h3 id="二、比较方式"><a href="#二、比较方式" class="headerlink" title="二、比较方式"></a>二、比较方式</h3><p><code>diff</code>整体策略为：深度优先，同层比较</p>
<ol>
<li>比较只会在同层级进行, 不会跨层级比较</li>
</ol>
<img src="/posts/11481/11481/image-20221102070430931.png" class="" title="image-20221102070430931">

<ol start="2">
<li>比较的过程中，循环从两边向中间收拢</li>
</ol>
<img src="/posts/11481/11481/image-20221102070456398.png" class="" title="image-20221102070456398">

<p>下面举个<code>vue</code>通过<code>diff</code>算法更新的例子：</p>
<p>新旧<code>VNode</code>节点如下图所示：</p>
<img src="/posts/11481/11481/image-20221102070512895.png" class="" title="image-20221102070512895">

<p>第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为<code>diff</code>后的第一个真实节点，同时旧节点<code>endIndex</code>移动到C，新节点的 <code>startIndex</code> 移动到了 C</p>
<img src="/posts/11481/11481/image-20221102070534981.png" class="" title="image-20221102070534981">

<p>第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，<code>diff</code> 后创建了 C 的真实节点插入到第一次创建的 D 节点后面。同时旧节点的 <code>endIndex</code> 移动到了 B，新节点的 <code>startIndex</code> 移动到了 E</p>
<img src="/posts/11481/11481/image-20221102070553310.png" class="" title="image-20221102070553310">

<p>第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 <code>startIndex</code> 移动到了 A。旧节点的 <code>startIndex</code> 和 <code>endIndex</code> 都保持不动</p>
<img src="/posts/11481/11481/image-20221102070612116.png" class="" title="image-20221102070612116">

<p>第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 <code>diff</code> 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 <code>startIndex</code> 移动到了 B，新节点的<code>startIndex</code> 移动到了 B</p>
<img src="/posts/11481/11481/image-20221102070631461.png" class="" title="image-20221102070631461">

<p>第五次循环中，情形同第四次循环一样，因此 <code>diff</code> 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 <code>startIndex</code>移动到了 C，新节点的 startIndex 移动到了 F</p>
<img src="/posts/11481/11481/image-20221102070649216.png" class="" title="image-20221102070649216">

<p>新节点的 <code>startIndex</code> 已经大于 <code>endIndex</code> 了，需要创建 <code>newStartIdx</code> 和 <code>newEndIdx</code> 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面</p>
<img src="/posts/11481/11481/image-20221102070706588.png" class="" title="image-20221102070706588">

<h3 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a>三、原理分析</h3><p>当数据发生改变时，<code>set</code>方法会调用<code>Dep.notify</code>通知所有订阅者<code>Watcher</code>，订阅者就会调用<code>patch</code>给真实的<code>DOM</code>打补丁，更新相应的视图</p>
<p>源码位置：src/core/vdom/patch.js</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span>(<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode)) { <span class="comment">// 没有新节点，直接执行destory钩子函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode)) <span class="title function_">invokeDestroyHook</span>(oldVnode)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldVnode)) {</span><br><span class="line">        isInitialPatch = <span class="literal">true</span></span><br><span class="line">        <span class="title function_">createElm</span>(vnode, insertedVnodeQueue) <span class="comment">// 没有旧节点，直接用新节点生成dom元素</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">const</span> isRealElement = <span class="title function_">isDef</span>(oldVnode.<span class="property">nodeType</span>)</span><br><span class="line">        <span class="keyword">if</span> (!isRealElement &amp;&amp; <span class="title function_">sameVnode</span>(oldVnode, vnode)) {</span><br><span class="line">            <span class="comment">// 判断旧节点和新节点自身一样，一致执行patchVnode</span></span><br><span class="line">            <span class="title function_">patchVnode</span>(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 否则直接销毁及旧节点，根据新节点生成dom元素</span></span><br><span class="line">            <span class="keyword">if</span> (isRealElement) {</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (oldVnode.<span class="property">nodeType</span> === <span class="number">1</span> &amp;&amp; oldVnode.<span class="title function_">hasAttribute</span>(<span class="variable constant_">SSR_ATTR</span>)) {</span><br><span class="line">                    oldVnode.<span class="title function_">removeAttribute</span>(<span class="variable constant_">SSR_ATTR</span>)</span><br><span class="line">                    hydrating = <span class="literal">true</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isTrue</span>(hydrating)) {</span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_">hydrate</span>(oldVnode, vnode, insertedVnodeQueue)) {</span><br><span class="line">                        <span class="title function_">invokeInsertHook</span>(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVnode</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                oldVnode = <span class="title function_">emptyNodeAt</span>(oldVnode)</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> vnode.<span class="property">elm</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>patch</code>函数前两个参数位为<code>oldVnode</code> 和 <code>Vnode</code> ，分别代表新的节点和之前的旧节点，主要做了四个判断：</p>
<ul>
<li>没有新节点，直接触发旧节点的<code>destory</code>钩子</li>
<li>没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 <code>createElm</code></li>
<li>旧节点和新节点自身一样，通过 <code>sameVnode</code> 判断节点是否一样，一样时，直接调用 <code>patchVnode</code>去处理这两个节点</li>
<li>旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点</li>
</ul>
<p>下面主要讲的是<code>patchVnode</code>部分</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchVnode</span> (oldVnode, vnode, insertedVnodeQueue, removeOnly) {</span><br><span class="line">    <span class="comment">// 如果新旧节点一致，什么都不做</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) {</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化</span></span><br><span class="line">    <span class="keyword">const</span> elm = vnode.<span class="property">elm</span> = oldVnode.<span class="property">elm</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步占位符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isTrue</span>(oldVnode.<span class="property">isAsyncPlaceholder</span>)) {</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">asyncFactory</span>.<span class="property">resolved</span>)) {</span><br><span class="line">        <span class="title function_">hydrate</span>(oldVnode.<span class="property">elm</span>, vnode, insertedVnodeQueue)</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        vnode.<span class="property">isAsyncPlaceholder</span> = <span class="literal">true</span></span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果新旧都是静态节点，并且具有相同的key</span></span><br><span class="line">    <span class="comment">// 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上</span></span><br><span class="line">    <span class="comment">// 也不用再有其他操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isTrue</span>(vnode.<span class="property">isStatic</span>) &amp;&amp;</span><br><span class="line">      <span class="title function_">isTrue</span>(oldVnode.<span class="property">isStatic</span>) &amp;&amp;</span><br><span class="line">      vnode.<span class="property">key</span> === oldVnode.<span class="property">key</span> &amp;&amp;</span><br><span class="line">      (<span class="title function_">isTrue</span>(vnode.<span class="property">isCloned</span>) || <span class="title function_">isTrue</span>(vnode.<span class="property">isOnce</span>))</span><br><span class="line">    ) {</span><br><span class="line">      vnode.<span class="property">componentInstance</span> = oldVnode.<span class="property">componentInstance</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">const</span> data = vnode.<span class="property">data</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>(i = data.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">prepatch</span>)) {</span><br><span class="line">      <span class="title function_">i</span>(oldVnode, vnode)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> oldCh = oldVnode.<span class="property">children</span></span><br><span class="line">    <span class="keyword">const</span> ch = vnode.<span class="property">children</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isPatchable</span>(vnode)) {</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.<span class="property">update</span>.<span class="property">length</span>; ++i) cbs.<span class="property">update</span>[i](oldVnode, vnode)</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(i = data.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">update</span>)) <span class="title function_">i</span>(oldVnode, vnode)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果vnode不是文本节点或者注释节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode.<span class="property">text</span>)) {</span><br><span class="line">      <span class="comment">// 并且都有子节点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh) &amp;&amp; <span class="title function_">isDef</span>(ch)) {</span><br><span class="line">        <span class="comment">// 并且子节点不完全一致，则调用updateChildren</span></span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) <span class="title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果只有新的vnode有子节点</span></span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(ch)) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">''</span>)</span><br><span class="line">        <span class="comment">// elm已经引用了老的dom节点，在老的dom节点上添加子节点</span></span><br><span class="line">        <span class="title function_">addVnodes</span>(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.<span class="property">length</span> - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果新vnode没有子节点，而vnode有子节点，直接删除老的oldCh</span></span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh)) {</span><br><span class="line">        <span class="title function_">removeVnodes</span>(elm, oldCh, <span class="number">0</span>, oldCh.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果老节点是文本节点</span></span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) {</span><br><span class="line">        nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">''</span>)</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果新vnode和老vnode是文本节点或注释节点</span></span><br><span class="line">      <span class="comment">// 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.<span class="property">text</span> !== vnode.<span class="property">text</span>) {</span><br><span class="line">      nodeOps.<span class="title function_">setTextContent</span>(elm, vnode.<span class="property">text</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data)) {</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(i = data.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">postpatch</span>)) <span class="title function_">i</span>(oldVnode, vnode)</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p><code>patchVnode</code>主要做了几个判断：</p>
<ul>
<li>新节点是否是文本节点，如果是，则直接更新<code>dom</code>的文本内容为新节点的文本内容</li>
<li>新节点和旧节点如果都有子节点，则处理比较更新子节点</li>
<li>只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新<code>DOM</code>，并且添加进父节点</li>
<li>只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把<code>DOM</code> 删除</li>
</ul>
<p>子节点不完全一致，则调用<code>updateChildren</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span> <span class="comment">// 旧头索引</span></span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span> <span class="comment">// 新头索引</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.<span class="property">length</span> - <span class="number">1</span> <span class="comment">// 旧尾索引</span></span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.<span class="property">length</span> - <span class="number">1</span> <span class="comment">// 新尾索引</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>] <span class="comment">// oldVnode的第一个child</span></span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx] <span class="comment">// oldVnode的最后一个child</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>] <span class="comment">// newVnode的第一个child</span></span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx] <span class="comment">// newVnode的最后一个child</span></span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">    <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">    <span class="comment">// during leaving transitions</span></span><br><span class="line">    <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束</span></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span><br><span class="line">      <span class="comment">// 如果oldVnode的第一个child不存在</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldStartVnode)) {</span><br><span class="line">        <span class="comment">// oldStart索引右移</span></span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果oldVnode的最后一个child不存在</span></span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldEndVnode)) {</span><br><span class="line">        <span class="comment">// oldEnd索引左移</span></span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// oldStartVnode和newStartVnode是同一个节点</span></span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode)) {</span><br><span class="line">        <span class="comment">// patch oldStartVnode和newStartVnode， 索引左移，继续循环</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// oldEndVnode和newEndVnode是同一个节点</span></span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode)) {</span><br><span class="line">        <span class="comment">// patch oldEndVnode和newEndVnode，索引右移，继续循环</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// oldStartVnode和newEndVnode是同一个节点</span></span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode)) { <span class="comment">// Vnode moved right</span></span><br><span class="line">        <span class="comment">// patch oldStartVnode和newEndVnode</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">        <span class="comment">// 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后</span></span><br><span class="line">        canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="property">elm</span>, nodeOps.<span class="title function_">nextSibling</span>(oldEndVnode.<span class="property">elm</span>))</span><br><span class="line">        <span class="comment">// oldStart索引右移，newEnd索引左移</span></span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果oldEndVnode和newStartVnode是同一个节点</span></span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode)) { <span class="comment">// Vnode moved left</span></span><br><span class="line">        <span class="comment">// patch oldEndVnode和newStartVnode</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">        <span class="comment">// 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前</span></span><br><span class="line">        canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">        <span class="comment">// oldEnd索引左移，newStart索引右移</span></span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果都不匹配</span></span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldKeyToIdx)) oldKeyToIdx = <span class="title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode</span></span><br><span class="line">        idxInOld = <span class="title function_">isDef</span>(newStartVnode.<span class="property">key</span>)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.<span class="property">key</span>]</span><br><span class="line">          : <span class="title function_">findIdxInOld</span>(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果未找到，说明newStartVnode是一个新的节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isUndef</span>(idxInOld)) { <span class="comment">// New element</span></span><br><span class="line">          <span class="comment">// 创建一个新Vnode</span></span><br><span class="line">          <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          vnodeToMove = oldCh[idxInOld]</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp; !vnodeToMove) {</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">              <span class="string">'It seems there are duplicate keys that is causing an update error. '</span> +</span><br><span class="line">              <span class="string">'Make sure each v-for item has a unique key.'</span></span><br><span class="line">            )</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 比较两个具有相同的key的新节点是否是同一个节点</span></span><br><span class="line">          <span class="comment">//不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(vnodeToMove, newStartVnode)) {</span><br><span class="line">            <span class="comment">// patch vnodeToMove和newStartVnode</span></span><br><span class="line">            <span class="title function_">patchVnode</span>(vnodeToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">            <span class="comment">// 清除</span></span><br><span class="line">            oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">            <span class="comment">// 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm</span></span><br><span class="line">            <span class="comment">// 移动到oldStartVnode.elm之前</span></span><br><span class="line">            canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, vnodeToMove.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果key相同，但是节点不相同，则创建一个新的节点</span></span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">            <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右移</span></span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p><code>while</code>循环主要处理了以下五种情景：</p>
<ul>
<li>当新老 <code>VNode</code> 节点的 <code>start</code> 相同时，直接 <code>patchVnode</code> ，同时新老 <code>VNode</code> 节点的开始索引都加 1</li>
<li>当新老 <code>VNode</code> 节点的 <code>end</code>相同时，同样直接 <code>patchVnode</code> ，同时新老 <code>VNode</code> 节点的结束索引都减 1</li>
<li>当老 <code>VNode</code> 节点的 <code>start</code> 和新 <code>VNode</code> 节点的 <code>end</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldEndVnode</code> 的后面，同时老 <code>VNode</code> 节点开始索引加 1，新 <code>VNode</code> 节点的结束索引减 1</li>
<li>当老 <code>VNode</code> 节点的 <code>end</code> 和新 <code>VNode</code> 节点的 <code>start</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldStartVnode</code> 的前面，同时老 <code>VNode</code> 节点结束索引减 1，新 <code>VNode</code> 节点的开始索引加 1</li>
<li>如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：<ul>
<li>从旧的 <code>VNode</code> 为 <code>key</code> 值，对应 <code>index</code> 序列为 <code>value</code> 值的哈希表中找到与 <code>newStartVnode</code> 一致 <code>key</code> 的旧的 <code>VNode</code> 节点，再进行<code>patchVnode</code>，同时将这个真实 <code>dom</code>移动到 <code>oldStartVnode</code> 对应的真实 <code>dom</code> 的前面</li>
<li>调用 <code>createElm</code> 创建一个新的 <code>dom</code> 节点放到当前 <code>newStartIdx</code> 的位置</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>当数据发生改变时，订阅者<code>watcher</code>就会调用<code>patch</code>给真实的<code>DOM</code>打补丁</p>
</li>
<li><p>通过<code>isSameVnode</code>进行判断，相同则调用<code>patchVnode</code>方法</p>
</li>
<li><p>```<br>patchVnode</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">  做了以下操作：</span><br><span class="line"></span><br><span class="line">  - 找到对应的真实`dom`，称为`el`</span><br><span class="line">  - 如果都有都有文本节点且不相等，将`el`文本节点设置为`Vnode`的文本节点</span><br><span class="line">  - 如果`oldVnode`有子节点而`VNode`没有，则删除`el`子节点</span><br><span class="line">  - 如果`oldVnode`没有子节点而`VNode`有，则将`VNode`的子节点真实化后添加到`el`</span><br><span class="line">  - 如果两者都有子节点，则执行`updateChildren`函数比较子节点</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  updateChildren</span><br></pre></td></tr></tbody></table></figure>

<p>主要做了以下操作：</p>
<ul>
<li>设置新旧<code>VNode</code>的头尾指针</li>
<li>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用<code>patchVnode</code>进行<code>patch</code>重复流程、调用<code>createElem</code>创建一个新节点，从哈希表寻找 <code>key</code>一致的<code>VNode</code> 节点再分情况操作</li>
</ul>
</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://juejin.cn/post/6881907432541552648#heading-1">https://juejin.cn/post/6881907432541552648#heading-1</a></li>
<li><a href="https://www.infoq.cn/article/udlcpkh4iqb0cr5wgy7f">https://www.infoq.cn/article/udlcpkh4iqb0cr5wgy7f</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue中的diff算法</tag>
      </tags>
  </entry>
  <entry>
    <title>说说vue中的key原理</title>
    <url>/posts/22527.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="说说vue中的key原理"><a href="#说说vue中的key原理" class="headerlink" title="说说vue中的key原理"></a>说说vue中的key原理</h1><h2 id="面试官：你知道vue中key的原理吗？说说你对它的理解"><a href="#面试官：你知道vue中key的原理吗？说说你对它的理解" class="headerlink" title="面试官：你知道vue中key的原理吗？说说你对它的理解"></a>面试官：你知道vue中key的原理吗？说说你对它的理解</h2><img src="/posts/22527/22527/image-20221026065449653.png" class="" title="image-20221026065449653">

<h3 id="一、Key是什么"><a href="#一、Key是什么" class="headerlink" title="一、Key是什么"></a>一、Key是什么</h3><p>开始之前，我们先还原两个实际工作场景</p>
<ol>
<li><p>当我们在使用<code>v-for</code>时，需要给单元加上<code>key</code></p>
<span id="more"></span></li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>用<code>+new Date()</code>生成的时间戳作为<code>key</code>，手动强制触发重新渲染</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Comp</span> :key=<span class="string">"+new Date()"</span> /&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>那么这背后的逻辑是什么，<code>key</code>的作用又是什么？</p>
<p>一句话来讲</p>
<blockquote>
<p>key是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点</p>
</blockquote>
<h4 id="场景背后的逻辑"><a href="#场景背后的逻辑" class="headerlink" title="场景背后的逻辑"></a>场景背后的逻辑</h4><p>当我们在使用<code>v-for</code>时，需要给单元加上<code>key</code></p>
<ul>
<li>如果不用key，Vue会采用就地复地原则：最小化element的移动，并且会尝试尽最大程度在同适当的地方对相同类型的element，做patch或者reuse。</li>
<li>如果使用了key，Vue会根据keys的顺序记录element，曾经拥有了key的element如果不再出现的话，会被直接remove或者destoryed</li>
</ul>
<p>用<code>+new Date()</code>生成的时间戳作为<code>key</code>，手动强制触发重新渲染</p>
<ul>
<li>当拥有新值的rerender作为key时，拥有了新key的Comp出现了，那么旧key Comp会被移除，新key Comp触发渲染</li>
</ul>
<h3 id="二、设置key与不设置key区别"><a href="#二、设置key与不设置key区别" class="headerlink" title="二、设置key与不设置key区别"></a>二、设置key与不设置key区别</h3><p>举个例子：</p>
<p>创建一个实例，2秒后往<code>items</code>数组插入数据</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item"</span>&gt;</span>{{item}}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 创建实例</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>({</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">'#demo'</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: { <span class="attr">items</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>] },</span></span><br><span class="line"><span class="language-javascript">      mounted () {</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> { </span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'f'</span>)  <span class="comment">// </span></span></span><br><span class="line"><span class="language-javascript">       }, <span class="number">2000</span>);</span></span><br><span class="line"><span class="language-javascript">     },</span></span><br><span class="line"><span class="language-javascript">   });</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>在不使用<code>key</code>的情况，<code>vue</code>会进行这样的操作：</p>
<p><img src="/posts/22527/image-20221026065709047.png" alt="image-20221026065709047"></p>
<p>分析下整体流程：</p>
<ul>
<li>比较A，A，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li>
<li>比较B，B，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li>
<li>比较C，F，相同类型的节点，进行<code>patch</code>，数据不同，发生<code>dom</code>操作</li>
<li>比较D，C，相同类型的节点，进行<code>patch</code>，数据不同，发生<code>dom</code>操作</li>
<li>比较E，D，相同类型的节点，进行<code>patch</code>，数据不同，发生<code>dom</code>操作</li>
<li>循环结束，将E插入到<code>DOM</code>中</li>
</ul>
<p>一共发生了3次更新，1次插入操作</p>
<p>在使用<code>key</code>的情况：<code>vue</code>会进行这样的操作：</p>
<ul>
<li>比较A，A，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li>
<li>比较B，B，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li>
<li>比较C，F，不相同类型的节点<ul>
<li>比较E、E，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li>
</ul>
</li>
<li>比较D、D，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li>
<li>比较C、C，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li>
<li>循环结束，将F插入到C之前</li>
</ul>
<p>一共发生了0次更新，1次插入操作</p>
<p>通过上面两个小例子，可见设置<code>key</code>能够大大减少对页面的<code>DOM</code>操作，提高了<code>diff</code>效率</p>
<h4 id="设置key值一定能提高diff效率吗？"><a href="#设置key值一定能提高diff效率吗？" class="headerlink" title="设置key值一定能提高diff效率吗？"></a>设置key值一定能提高diff效率吗？</h4><p>其实不然，文档中也明确表示</p>
<blockquote>
<p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素</p>
</blockquote>
<p>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</p>
<p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code>，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升</p>
<h3 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a>三、原理分析</h3><p>源码位置：core/vdom/patch.js</p>
<p>这里判断是否为同一个<code>key</code>，首先判断的是<code>key</code>值是否相等如果没有设置<code>key</code>，那么<code>key</code>为<code>undefined</code>，这时候<code>undefined</code>是恒等于<code>undefined</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sameVnode</span> (a, b) {</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        a.<span class="property">key</span> === b.<span class="property">key</span> &amp;&amp; (</span><br><span class="line">            (</span><br><span class="line">                a.<span class="property">tag</span> === b.<span class="property">tag</span> &amp;&amp;</span><br><span class="line">                a.<span class="property">isComment</span> === b.<span class="property">isComment</span> &amp;&amp;</span><br><span class="line">                <span class="title function_">isDef</span>(a.<span class="property">data</span>) === <span class="title function_">isDef</span>(b.<span class="property">data</span>) &amp;&amp;</span><br><span class="line">                <span class="title function_">sameInputType</span>(a, b)</span><br><span class="line">            ) || (</span><br><span class="line">                <span class="title function_">isTrue</span>(a.<span class="property">isAsyncPlaceholder</span>) &amp;&amp;</span><br><span class="line">                a.<span class="property">asyncFactory</span> === b.<span class="property">asyncFactory</span> &amp;&amp;</span><br><span class="line">                <span class="title function_">isUndef</span>(b.<span class="property">asyncFactory</span>.<span class="property">error</span>)</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">updateChildren`方法中会对新旧`vnode`进行`diff`，然后将比对出的结果用来更新真实的`DOM</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldStartVnode)) {</span><br><span class="line">            ...</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldEndVnode)) {</span><br><span class="line">            ...</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode)) {</span><br><span class="line">            ...</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode)) {</span><br><span class="line">            ...</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode)) { <span class="comment">// Vnode moved right</span></span><br><span class="line">            ...</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode)) { <span class="comment">// Vnode moved left</span></span><br><span class="line">            ...</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldKeyToIdx)) oldKeyToIdx = <span class="title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">            idxInOld = <span class="title function_">isDef</span>(newStartVnode.<span class="property">key</span>)</span><br><span class="line">                ? oldKeyToIdx[newStartVnode.<span class="property">key</span>]</span><br><span class="line">                : <span class="title function_">findIdxInOld</span>(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isUndef</span>(idxInOld)) { <span class="comment">// New element</span></span><br><span class="line">                <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                vnodeToMove = oldCh[idxInOld]</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(vnodeToMove, newStartVnode)) {</span><br><span class="line">                    <span class="title function_">patchVnode</span>(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">                    oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">                    canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, vnodeToMove.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">                    <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://juejin.cn/post/6844903826693029895">https://juejin.cn/post/6844903826693029895</a></li>
<li><a href="https://juejin.cn/post/6844903985397104648">https://juejin.cn/post/6844903985397104648</a></li>
<li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue中的key原理</tag>
      </tags>
  </entry>
  <entry>
    <title>说说你对nexttick的理解</title>
    <url>/posts/54065.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="说说你对nexttick的理解"><a href="#说说你对nexttick的理解" class="headerlink" title="说说你对nexttick的理解"></a>说说你对nexttick的理解</h1><h2 id="面试官：Vue中的-nextTick有什么作用？"><a href="#面试官：Vue中的-nextTick有什么作用？" class="headerlink" title="面试官：Vue中的$nextTick有什么作用？"></a>面试官：Vue中的$nextTick有什么作用？</h2><img src="/posts/54065/54065/image-20221022092359197.png" class="" title="image-20221022092359197">

<h3 id="一、NextTick是什么"><a href="#一、NextTick是什么" class="headerlink" title="一、NextTick是什么"></a>一、NextTick是什么</h3><p>官方对其的定义</p>
<blockquote>
<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</p>
</blockquote>
<p>什么意思呢？</p>
<span id="more"></span>

<p>我们可以理解成，<code>Vue</code> 在更新 <code>DOM</code> 时是异步执行的。当数据发生变化，<code>Vue</code>将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新</p>
<p>举例一下</p>
<p><code>Html</code>结构</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span> {{ message }} <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>构建一个<code>vue</code>实例</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>({</span><br><span class="line">  <span class="attr">el</span>: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="attr">data</span>: {</span><br><span class="line">    <span class="attr">message</span>: <span class="string">'原始值'</span></span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>修改<code>message</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">'修改后的值1'</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">'修改后的值2'</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">'修改后的值3'</span></span><br></pre></td></tr></tbody></table></figure>

<p>这时候想获取页面最新的<code>DOM</code>节点，却发现获取到的是旧值</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">// 原始值</span></span><br></pre></td></tr></tbody></table></figure>

<p>这是因为<code>message</code>数据在发现变化的时候，<code>vue</code>并不会立刻去更新<code>Dom</code>，而是将修改数据的操作放在了一个异步操作队列中</p>
<p>如果我们一直修改相同数据，异步操作队列还会进行去重</p>
<p>等待同一事件循环中的所有数据变化完成之后，会将队列中的事件拿来进行处理，进行<code>DOM</code>的更新</p>
<h4 id="为什么要有nexttick"><a href="#为什么要有nexttick" class="headerlink" title="为什么要有nexttick"></a>为什么要有nexttick</h4><p>举个例子</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{{num}}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++){</span><br><span class="line">    num = i</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果没有 <code>nextTick</code> 更新机制，那么 <code>num</code> 每次更新值都会触发视图更新(上面这段代码也就是会更新10万次视图)，有了<code>nextTick</code>机制，只需要更新一次，所以<code>nextTick</code>本质是一种优化策略</p>
<h3 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h3><p>如果想要在修改数据后立刻得到更新后的<code>DOM</code>结构，可以使用<code>Vue.nextTick()</code></p>
<p>第一个参数为：回调函数（可以获取最近的<code>DOM</code>结构）</p>
<p>第二个参数为：执行函数上下文</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">vm.<span class="property">message</span> = <span class="string">'修改后的值'</span></span><br><span class="line"><span class="comment">// DOM 还没有更新</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">// 原始的值</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">// 修改后的值</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>组件内使用 <code>vm.$nextTick()</code> 实例方法只需要通过<code>this.$nextTick()</code>，并且回调函数中的 <code>this</code> 将自动绑定到当前的 <code>Vue</code> 实例上</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">'修改后的值'</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">// =&gt; '原始的值'</span></span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">// =&gt; '修改后的值'</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p><code>$nextTick()</code> 会返回一个 <code>Promise</code> 对象，可以是用<code>async/await</code>完成相同作用的事情</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">'修改后的值'</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">// =&gt; '原始的值'</span></span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.$nextTick()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">// =&gt; '修改后的值'</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="三、实现原理"><a href="#三、实现原理" class="headerlink" title="三、实现原理"></a>三、实现原理</h3><p>源码位置：<code>/src/core/util/next-tick.js</code></p>
<p><code>callbacks</code>也就是异步操作队列</p>
<p><code>callbacks</code>新增回调函数后又执行了<code>timerFunc</code>函数，<code>pending</code>是用来标识同一个时间只能执行一次</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) {</span><br><span class="line">  <span class="keyword">let</span> _resolve;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cb 回调函数会经统一处理压入 callbacks 数组</span></span><br><span class="line">  callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="keyword">if</span> (cb) {</span><br><span class="line">      <span class="comment">// 给 cb 回调函数执行加上了 try-catch 错误处理</span></span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        cb.<span class="title function_">call</span>(ctx);</span><br><span class="line">      } <span class="keyword">catch</span> (e) {</span><br><span class="line">        <span class="title function_">handleError</span>(e, ctx, <span class="string">'nextTick'</span>);</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) {</span><br><span class="line">      <span class="title function_">_resolve</span>(ctx);</span><br><span class="line">    }</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行异步延迟函数 timerFunc</span></span><br><span class="line">  <span class="keyword">if</span> (!pending) {</span><br><span class="line">    pending = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">timerFunc</span>();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 nextTick 没有传入函数参数的时候，返回一个 Promise 化的调用</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">'undefined'</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> {</span><br><span class="line">      _resolve = resolve;</span><br><span class="line">    });</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>timerFunc</code>函数定义，这里是根据当前环境支持什么方法则确定调用哪个，分别有：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Promise.then`、`MutationObserver`、`setImmediate`、`setTimeout</span><br></pre></td></tr></tbody></table></figure>

<p>通过上面任意一种方法，进行降级操作</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> isUsingMicroTask = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) {</span><br><span class="line">  <span class="comment">//判断1：是否原生支持Promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> {</span><br><span class="line">    p.<span class="title function_">then</span>(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  }</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">  <span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) ||</span><br><span class="line">  <span class="title class_">MutationObserver</span>.<span class="title function_">toString</span>() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">)) {</span><br><span class="line">  <span class="comment">//判断2：是否原生支持MutationObserver</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter))</span><br><span class="line">  observer.<span class="title function_">observe</span>(textNode, {</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  })</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> {</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter)</span><br><span class="line">  }</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; <span class="title function_">isNative</span>(setImmediate)) {</span><br><span class="line">  <span class="comment">//判断3：是否原生支持setImmediate</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="title function_">setImmediate</span>(flushCallbacks)</span><br><span class="line">  }</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">//判断4：上面都不行，直接用setTimeout</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>无论是微任务还是宏任务，都会放到<code>flushCallbacks</code>使用</p>
<p>这里将<code>callbacks</code>里面的函数复制一份，同时<code>callbacks</code>置空</p>
<p>依次执行<code>callbacks</code>里面的函数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span> () {</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">  callbacks.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) {</span><br><span class="line">    copies[i]()</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>小结：</strong></p>
<ol>
<li>把回调函数放入callbacks等待执行</li>
<li>将执行函数放到微任务或者宏任务中</li>
<li>事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://juejin.cn/post/6844904147804749832">https://juejin.cn/post/6844904147804749832</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>说说你对nexttick的理解</tag>
      </tags>
  </entry>
  <entry>
    <title>说说你对promise的理解</title>
    <url>/posts/14186.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="说说你对promise的理解"><a href="#说说你对promise的理解" class="headerlink" title="说说你对promise的理解"></a>说说你对promise的理解</h1><h2 id="面试官：你是怎么理解ES6中-Promise的？使用场景？"><a href="#面试官：你是怎么理解ES6中-Promise的？使用场景？" class="headerlink" title="面试官：你是怎么理解ES6中 Promise的？使用场景？"></a>面试官：你是怎么理解ES6中 Promise的？使用场景？</h2><img src="/posts/14186/14186/image-20221123070639996.png" class="" title="image-20221123070639996">

<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><code>Promise</code>，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大</p>
<p>在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码</p>
<span id="more"></span>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>(<span class="keyword">function</span>(<span class="params">result</span>) {</span><br><span class="line">  <span class="title function_">doSomethingElse</span>(result, <span class="keyword">function</span>(<span class="params">newResult</span>) {</span><br><span class="line">    <span class="title function_">doThirdThing</span>(newResult, <span class="keyword">function</span>(<span class="params">finalResult</span>) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'得到最终结果: '</span> + finalResult);</span><br><span class="line">    }, failureCallback);</span><br><span class="line">  }, failureCallback);</span><br><span class="line">}, failureCallback);</span><br></pre></td></tr></tbody></table></figure>

<p>阅读上面代码，是不是很难受，上述形成了经典的回调地狱</p>
<p>现在通过<code>Promise</code>的改写上面的代码</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">doSomethingElse</span>(result);</span><br><span class="line">})</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">newResult</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">doThirdThing</span>(newResult);</span><br><span class="line">})</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">finalResult</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'得到最终结果: '</span> + finalResult);</span><br><span class="line">})</span><br><span class="line">.<span class="title function_">catch</span>(failureCallback);</span><br></pre></td></tr></tbody></table></figure>

<p>瞬间感受到<code>promise</code>解决异步操作的优点：</p>
<ul>
<li>链式操作减低了编码难度</li>
<li>代码可读性明显增强</li>
</ul>
<p>下面我们正式来认识<code>promise</code>：</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><code>promise</code>对象仅有三种状态</p>
<ul>
<li><code>pending</code>（进行中）</li>
<li><code>fulfilled</code>（已成功）</li>
<li><code>rejected</code>（已失败）</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</li>
<li>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变，任何时候都可以得到这个结果</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>认真阅读下图，我们能够轻松了解<code>promise</code>整个流程</p>
<p><img src="/posts/14186/image-20221123070732980.png" alt="image-20221123070732980"></p>
<h2 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h2><p><code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) {});</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”</li>
<li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”</li>
</ul>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><code>Promise</code>构建出来的实例存在以下方法：</p>
<ul>
<li>then()</li>
<li>catch()</li>
<li>finally()</li>
</ul>
<h4 id="then"><a href="#then" class="headerlink" title="then()"></a>then()</h4><p><code>then</code>是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</p>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例，也就是<code>promise</code>能链式书写的原因</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">"/posts.json"</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) {</span><br><span class="line">  <span class="keyword">return</span> json.<span class="property">post</span>;</span><br><span class="line">}).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p><code>catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">'/posts.json'</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) {</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p><code>Promise</code>对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">'/post/1.json'</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">}).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">comments</span>) {</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">}).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) {</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>一般来说，使用<code>catch</code>方法代替<code>then()</code>第二个参数</p>
<p><code>Promise</code>对象抛出的错误不会传递到外层代码，即不会有任何反应</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) {</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);</span><br><span class="line">  });</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程</p>
<p><code>catch()</code>方法之中，还能再抛出错误，通过后面<code>catch</code>方法捕获到</p>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h4><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> {···})</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> {···})</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> {···});</span><br></pre></td></tr></tbody></table></figure>

<h3 id="构造函数方法"><a href="#构造函数方法" class="headerlink" title="构造函数方法"></a>构造函数方法</h3><p><code>Promise</code>构造函数存在以下方法：</p>
<ul>
<li>all()</li>
<li>race()</li>
<li>allSettled()</li>
<li>resolve()</li>
<li>reject()</li>
<li>try()</li>
</ul>
<h3 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h3><p><code>Promise.all()</code>方法用于将多个 <code>Promise</code>实例，包装成一个新的 <code>Promise</code>实例</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></tbody></table></figure>

<p>接受一个数组（迭代对象）作为参数，数组成员都应为<code>Promise</code>实例</p>
<p>实例<code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分为两种：</p>
<ul>
<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</li>
<li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数</li>
</ul>
<p>注意，如果作为参数的 <code>Promise</code> 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">'hello'</span>);</span><br><span class="line">})</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">})</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// ["hello", Error: 报错了]</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">'hello'</span>);</span><br><span class="line">})</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">})</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// Error: 报错了</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="race"><a href="#race" class="headerlink" title="race()"></a>race()</h3><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></tbody></table></figure>

<p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变</p>
<p>率先改变的 Promise 实例的返回值则传递给<code>p</code>的回调函数</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) {</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  })</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled()"></a>allSettled()</h3><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</p>
<p>只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">'/api-1'</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">'/api-2'</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">'/api-3'</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line"><span class="title function_">removeLoadingIndicator</span>();</span><br></pre></td></tr></tbody></table></figure>

<h4 id="resolve"><a href="#resolve" class="headerlink" title="resolve()"></a>resolve()</h4><p>将现有对象转为 <code>Promise</code>对象</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="string">'foo'</span>))</span><br></pre></td></tr></tbody></table></figure>

<p>参数可以分成四种情况，分别如下：</p>
<ul>
<li>参数是一个 Promise 实例，<code>promise.resolve</code>将不做任何修改、原封不动地返回这个实例</li>
<li>参数是一个<code>thenable</code>对象，<code>promise.resolve</code>会将这个对象转为 <code>Promise</code>对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法</li>
<li>参数不是具有<code>then()</code>方法的对象，或根本就不是对象，<code>Promise.resolve()</code>会返回一个新的 Promise 对象，状态为<code>resolved</code></li>
<li>没有参数时，直接返回一个<code>resolved</code>状态的 Promise 对象</li>
</ul>
<h4 id="reject"><a href="#reject" class="headerlink" title="reject()"></a>reject()</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejected</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">'出错了'</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">'出错了'</span>))</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="keyword">function</span> (<span class="params">s</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">});</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>Promise.reject()</code>方法的参数，会原封不动地变成后续方法的参数</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">'出错了'</span>)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e === <span class="string">'出错了'</span>)</span><br><span class="line">})</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h2><p>将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="keyword">function</span> (<span class="params">path</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) {</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">    image.<span class="property">onload</span>  = resolve;</span><br><span class="line">    image.<span class="property">onerror</span> = reject;</span><br><span class="line">    image.<span class="property">src</span> = path;</span><br><span class="line">  });</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>通过链式操作，将多个渲染数据分别给个<code>then</code>，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 各司其职</span></span><br><span class="line"><span class="title function_">getInfo</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>{</span><br><span class="line">    <span class="keyword">let</span> { bannerList } = res</span><br><span class="line">    <span class="comment">//渲染轮播图</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bannerList)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">}).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> { storeList } = res</span><br><span class="line">    <span class="comment">//渲染店铺列表</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(storeList)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">}).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>{</span><br><span class="line">    <span class="keyword">let</span> { categoryList } = res</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(categoryList)</span><br><span class="line">    <span class="comment">//渲染分类列表</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>通过<code>all()</code>实现多个请求合并在一起，汇总所有请求结果，只需设置一个<code>loading</code>即可</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initLoad</span>(<span class="params"></span>){</span><br><span class="line">    <span class="comment">// loading.show() //加载loading</span></span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getBannerList</span>(),<span class="title function_">getStoreList</span>(),<span class="title function_">getCategoryList</span>()]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>{</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        loading.<span class="title function_">hide</span>() <span class="comment">//关闭loading</span></span><br><span class="line">    }).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>{</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        loading.<span class="title function_">hide</span>()<span class="comment">//关闭loading</span></span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"><span class="comment">//数据初始化    </span></span><br><span class="line"><span class="title function_">initLoad</span>()</span><br></pre></td></tr></tbody></table></figure>

<p>通过<code>race</code>可以设置图片请求超时</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//请求某个图片资源</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">requestImg</span>(<span class="params"></span>){</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>){</span><br><span class="line">        <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">        img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">           <span class="title function_">resolve</span>(img);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//img.src = "https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg"; 正确的</span></span><br><span class="line">        img.<span class="property">src</span> = <span class="string">"https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1"</span>;</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时函数，用于给请求计时</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>){</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>){</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">'图片请求超时'</span>);</span><br><span class="line">        }, <span class="number">5000</span>);</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span></span><br><span class="line">.<span class="title function_">race</span>([<span class="title function_">requestImg</span>(), <span class="title function_">timeout</span>()])</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">results</span>){</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">})</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>){</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://es6.ruanyifeng.com/#docs/promise">https://es6.ruanyifeng.com/#docs/promise</a></li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>说说你对promise的理解</tag>
      </tags>
  </entry>
  <entry>
    <title>说说你对slot的理解</title>
    <url>/posts/3047.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="说说你对slot的理解"><a href="#说说你对slot的理解" class="headerlink" title="说说你对slot的理解"></a>说说你对slot的理解</h1><h2 id="面试官：说说你对slot的理解？slot使用场景有哪些？"><a href="#面试官：说说你对slot的理解？slot使用场景有哪些？" class="headerlink" title="面试官：说说你对slot的理解？slot使用场景有哪些？"></a>面试官：说说你对slot的理解？slot使用场景有哪些？</h2><img src="/posts/3047/3047/image-20221024062845179.png" class="" title="image-20221024062845179">

<h3 id="一、slot是什么"><a href="#一、slot是什么" class="headerlink" title="一、slot是什么"></a>一、slot是什么</h3><p>在HTML中 <code>slot</code> 元素 ，作为 <code>Web Components</code> 技术套件的一部分，是Web组件内的一个占位符</p>
<p>该占位符可以在后期使用自己的标记语言填充</p>
<span id="more"></span>

<p>举个栗子</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"element-details-template"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"element-name"</span>&gt;</span>Slot template<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">element-details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"element-name"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">element-details</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">element-details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"element-name"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">element-details</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>template</code>不会展示到页面中，需要用先获取它的引用，然后添加到<code>DOM</code>中，</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">customElements.<span class="title function_">define</span>(<span class="string">'element-details'</span>,</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">HTMLElement</span> {</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) {</span><br><span class="line">      <span class="variable language_">super</span>();</span><br><span class="line">      <span class="keyword">const</span> template = <span class="variable language_">document</span></span><br><span class="line">        .<span class="title function_">getElementById</span>(<span class="string">'element-details-template'</span>)</span><br><span class="line">        .<span class="property">content</span>;</span><br><span class="line">      <span class="keyword">const</span> shadowRoot = <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>({<span class="attr">mode</span>: <span class="string">'open'</span>})</span><br><span class="line">        .<span class="title function_">appendChild</span>(template.<span class="title function_">cloneNode</span>(<span class="literal">true</span>));</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>Vue</code>中的概念也是如此</p>
<p><code>Slot</code> 艺名插槽，花名“占坑”，我们可以理解为<code>solt</code>在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中<code>slot</code>位置），作为承载分发内容的出口</p>
<p>可以将其类比为插卡式的FC游戏机，游戏机暴露卡槽（插槽）让用户插入不同的游戏磁条（自定义内容）</p>
<p>放张图感受一下</p>
<img src="/posts/3047/3047/image-20221024063011755.png" class="" title="image-20221024063011755">

<h3 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h3><p>通过插槽可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理</p>
<p>如果父组件在使用到一个复用组件的时候，获取这个组件在不同的地方有少量的更改，如果去重写组件是一件不明智的事情</p>
<p>通过<code>slot</code>插槽向组件内部指定位置传递内容，完成这个复用组件在不同场景的应用</p>
<p>比如布局组件、表格列、下拉选、弹框显示内容等</p>
<h3 id="三、分类"><a href="#三、分类" class="headerlink" title="三、分类"></a>三、分类</h3><p><code>slot</code>可以分来以下三种：</p>
<ul>
<li>默认插槽</li>
<li>具名插槽</li>
<li>作用域插槽</li>
</ul>
<h4 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h4><p>子组件用<code>&lt;slot&gt;</code>标签来确定渲染的位置，标签里面可以放<code>DOM</code>结构，当父组件使用的时候没有往插槽传入内容，标签内<code>DOM</code>结构就会显示在页面</p>
<p>父组件在使用的时候，直接在子组件的标签内写入内容即可</p>
<p>子组件<code>Child.vue</code></p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>父组件</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>默认插槽<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>子组件用<code>name</code>属性来表示插槽的名字，不传为默认插槽</p>
<p>父组件中在使用时在默认插槽的基础上加上<code>slot</code>属性，值为子组件插槽<code>name</code>属性值</p>
<p>子组件<code>Child.vue</code></p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"content"</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>父组件</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span>具名插槽<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 具名插槽⽤插槽名做参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:content</span>&gt;</span>内容...<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件<code>v-slot</code>接受的对象上</p>
<p>父组件中在使用时通过<code>v-slot:</code>（简写：#）获取子组件的信息，在内容中使用</p>
<p>子组件<code>Child.vue</code></p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span> <span class="attr">testProps</span>=<span class="string">"子组件的值"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>没传footer插槽<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>父组件</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 把v-slot的值指定为作⽤域上下⽂对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">      来⾃⼦组件数据：{{slotProps.testProps}}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">      来⾃⼦组件数据：{{slotProps.testProps}}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul>
<li><code>v-slot</code>属性只能在<code>&lt;template&gt;</code>上使用，但在只有默认插槽时可以在组件标签上使用</li>
<li>默认插槽名为<code>default</code>，可以省略default直接写<code>v-slot</code></li>
<li>缩写为<code>#</code>时不能不写参数，写成<code>#default</code></li>
<li>可以通过解构获取<code>v-slot={user}</code>，还可以重命名<code>v-slot="{user: newName}"</code>和定义默认值<code>v-slot="{user = '默认值'}"</code></li>
</ul>
<h3 id="四、原理分析"><a href="#四、原理分析" class="headerlink" title="四、原理分析"></a>四、原理分析</h3><p><code>slot</code>本质上是返回<code>VNode</code>的函数，一般情况下，<code>Vue</code>中的组件要渲染到页面上需要经过<code>template -&gt; render function -&gt; VNode -&gt; DOM</code> 过程，这里看看<code>slot</code>如何实现：</p>
<p>编写一个<code>buttonCounter</code>组件，使用匿名插槽</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">'button-counter'</span>, {</span><br><span class="line">  <span class="attr">template</span>: <span class="string">'&lt;div&gt; &lt;slot&gt;我是默认内容&lt;/slot&gt;&lt;/div&gt;'</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>使用该组件</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>({</span><br><span class="line">    <span class="attr">el</span>: <span class="string">'#app'</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">'&lt;button-counter&gt;&lt;span&gt;我是slot传入内容&lt;/span&gt;&lt;/button-counter&gt;'</span>,</span><br><span class="line">    <span class="attr">components</span>:{buttonCounter}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>获取<code>buttonCounter</code>组件渲染函数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">anonymous</span>(<span class="params"></span></span><br><span class="line"><span class="params"></span>) {</span><br><span class="line"><span class="title function_">with</span>(<span class="params"><span class="variable language_">this</span></span>){<span class="keyword">return</span> <span class="title function_">_c</span>(<span class="string">'div'</span>,[<span class="title function_">_t</span>(<span class="string">"default"</span>,[<span class="title function_">_v</span>(<span class="string">"我是默认内容"</span>)])],<span class="number">2</span>)}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p><code>_v</code>表示穿件普通文本节点，<code>_t</code>表示渲染插槽的函数</p>
<p>渲染插槽函数<code>renderSlot</code>（做了简化）</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">renderSlot</span> (</span><br><span class="line">  name,</span><br><span class="line">  fallback,</span><br><span class="line">  props,</span><br><span class="line">  bindObject</span><br><span class="line">) {</span><br><span class="line">  <span class="comment">// 得到渲染插槽内容的函数    </span></span><br><span class="line">  <span class="keyword">var</span> scopedSlotFn = <span class="variable language_">this</span>.<span class="property">$scopedSlots</span>[name];</span><br><span class="line">  <span class="keyword">var</span> nodes;</span><br><span class="line">  <span class="comment">// 如果存在插槽渲染函数，则执行插槽渲染函数，生成nodes节点返回</span></span><br><span class="line">  <span class="comment">// 否则使用默认值</span></span><br><span class="line">  nodes = <span class="title function_">scopedSlotFn</span>(props) || fallback;</span><br><span class="line">  <span class="keyword">return</span> nodes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>name</code>属性表示定义插槽的名字，默认值为<code>default</code>，<code>fallback</code>表示子组件中的<code>slot</code>节点的默认值</p>
<p>关于<code>this.$scopredSlots</code>是什么，我们可以先看看<code>vm.slot</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initRender</span> (vm) {</span><br><span class="line">  ...</span><br><span class="line">  vm.<span class="property">$slots</span> = <span class="title function_">resolveSlots</span>(options.<span class="property">_renderChildren</span>, renderContext);</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">resolveSlots`函数会对`children`节点做归类和过滤处理，返回`slots</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveSlots</span> (</span><br><span class="line">    children,</span><br><span class="line">    context</span><br><span class="line">  ) {</span><br><span class="line">    <span class="keyword">if</span> (!children || !children.<span class="property">length</span>) {</span><br><span class="line">      <span class="keyword">return</span> {}</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> slots = {};</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = children.<span class="property">length</span>; i &lt; l; i++) {</span><br><span class="line">      <span class="keyword">var</span> child = children[i];</span><br><span class="line">      <span class="keyword">var</span> data = child.<span class="property">data</span>;</span><br><span class="line">      <span class="comment">// remove slot attribute if the node is resolved as a Vue slot node</span></span><br><span class="line">      <span class="keyword">if</span> (data &amp;&amp; data.<span class="property">attrs</span> &amp;&amp; data.<span class="property">attrs</span>.<span class="property">slot</span>) {</span><br><span class="line">        <span class="keyword">delete</span> data.<span class="property">attrs</span>.<span class="property">slot</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// named slots should only be respected if the vnode was rendered in the</span></span><br><span class="line">      <span class="comment">// same context.</span></span><br><span class="line">      <span class="keyword">if</span> ((child.<span class="property">context</span> === context || child.<span class="property">fnContext</span> === context) &amp;&amp;</span><br><span class="line">        data &amp;&amp; data.<span class="property">slot</span> != <span class="literal">null</span></span><br><span class="line">      ) {</span><br><span class="line">        <span class="comment">// 如果slot存在(slot="header") 则拿对应的值作为key</span></span><br><span class="line">        <span class="keyword">var</span> name = data.<span class="property">slot</span>;</span><br><span class="line">        <span class="keyword">var</span> slot = (slots[name] || (slots[name] = []));</span><br><span class="line">        <span class="comment">// 如果是tempalte元素 则把template的children添加进数组中，这也就是为什么你写的template标签并不会渲染成另一个标签到页面</span></span><br><span class="line">        <span class="keyword">if</span> (child.<span class="property">tag</span> === <span class="string">'template'</span>) {</span><br><span class="line">          slot.<span class="property">push</span>.<span class="title function_">apply</span>(slot, child.<span class="property">children</span> || []);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          slot.<span class="title function_">push</span>(child);</span><br><span class="line">        }</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 如果没有就默认是default</span></span><br><span class="line">        (slots.<span class="property">default</span> || (slots.<span class="property">default</span> = [])).<span class="title function_">push</span>(child);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ignore slots that contains only whitespace</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> name$1 <span class="keyword">in</span> slots) {</span><br><span class="line">      <span class="keyword">if</span> (slots[name$1].<span class="title function_">every</span>(isWhitespace)) {</span><br><span class="line">        <span class="keyword">delete</span> slots[name$1];</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> slots</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">_render`渲染函数通过`normalizeScopedSlots`得到`vm.$scopedSlots</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">vm.<span class="property">$scopedSlots</span> = <span class="title function_">normalizeScopedSlots</span>(</span><br><span class="line">  _parentVnode.<span class="property">data</span>.<span class="property">scopedSlots</span>,</span><br><span class="line">  vm.<span class="property">$slots</span>,</span><br><span class="line">  vm.<span class="property">$scopedSlots</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>作用域插槽中父组件能够得到子组件的值是因为在<code>renderSlot</code>的时候执行会传入<code>props</code>，也就是上述<code>_t</code>第三个参数，父组件则能够得到子组件传递过来的值</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://juejin.cn/post/6844903817746628615#heading-4">https://juejin.cn/post/6844903817746628615#heading-4</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots">https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots</a></li>
<li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li>
<li><a href="https://segmentfault.com/a/1190000019492734?utm_source=tag-newest">https://segmentfault.com/a/1190000019492734?utm_source=tag-newest</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>说说你对slot的理解</tag>
      </tags>
  </entry>
  <entry>
    <title>说说你对vue的mixin的理解</title>
    <url>/posts/11537.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="说说你对vue的mixin的理解"><a href="#说说你对vue的mixin的理解" class="headerlink" title="说说你对vue的mixin的理解"></a>说说你对vue的mixin的理解</h1><h2 id="面试官：说说你对vue的mixin的理解，有什么应用场景？"><a href="#面试官：说说你对vue的mixin的理解，有什么应用场景？" class="headerlink" title="面试官：说说你对vue的mixin的理解，有什么应用场景？"></a>面试官：说说你对vue的mixin的理解，有什么应用场景？</h2><img src="/posts/11537/11537/image-20221023131918749.png" class="" title="image-20221023131918749">

<h3 id="一、mixin是什么"><a href="#一、mixin是什么" class="headerlink" title="一、mixin是什么"></a>一、mixin是什么</h3><p><code>Mixin</code>是面向对象程序设计语言中的类，提供了方法的实现。其他类可以访问<code>mixin</code>类的方法而不必成为其子类</p>
<p><code>Mixin</code>类通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用又避免了多继承的复杂</p>
<span id="more"></span>

<h4 id="Vue中的mixin"><a href="#Vue中的mixin" class="headerlink" title="Vue中的mixin"></a>Vue中的mixin</h4><p>先来看一下官方定义</p>
<blockquote>
<p><code>mixin</code>（混入），提供了一种非常灵活的方式，来分发 <code>Vue</code> 组件中的可复用功能。</p>
</blockquote>
<p>本质其实就是一个<code>js</code>对象，它可以包含我们组件中任意功能选项，如<code>data</code>、<code>components</code>、<code>methods</code>、<code>created</code>、<code>computed</code>等等</p>
<p>我们只要将共用的功能以对象的方式传入 <code>mixins</code>选项中，当组件使用 <code>mixins</code>对象时所有<code>mixins</code>对象的选项都将被混入该组件本身的选项中来</p>
<p>在<code>Vue</code>中我们可以<strong>局部混入</strong>跟<strong>全局混入</strong></p>
<h4 id="局部混入"><a href="#局部混入" class="headerlink" title="局部混入"></a>局部混入</h4><p>定义一个<code>mixin</code>对象，有组件<code>options</code>的<code>data</code>、<code>methods</code>属性</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMixin = {</span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">hello</span>()</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">methods</span>: {</span><br><span class="line">    <span class="attr">hello</span>: <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'hello from mixin!'</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>组件通过<code>mixins</code>属性调用<code>mixin</code>对象</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">'componentA'</span>,{</span><br><span class="line">  <span class="attr">mixins</span>: [myMixin]</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>该组件在使用的时候，混合了<code>mixin</code>里面的方法，在自动执行<code>created</code>生命钩子，执行<code>hello</code>方法</p>
<h4 id="全局混入"><a href="#全局混入" class="headerlink" title="全局混入"></a>全局混入</h4><p>通过<code>Vue.mixin()</code>进行全局的混入</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>({</span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"全局混入"</span>)</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>使用全局混入需要特别注意，因为它会影响到每一个组件实例（包括第三方组件）</p>
<p>PS：全局混入常用于插件的编写</p>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>当组件存在与<code>mixin</code>对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖<code>mixin</code>的选项</p>
<p>但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行<code>mixin</code>的钩子，再执行组件的钩子</p>
<h3 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h3><p>在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立</p>
<p>这时，可以通过<code>Vue</code>的<code>mixin</code>功能将相同或者相似的代码提出来</p>
<p>举个例子</p>
<p>定义一个<code>modal</code>弹窗组件，内部通过<code>isShowing</code>来控制显示</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Modal</span> = {</span><br><span class="line">  <span class="attr">template</span>: <span class="string">'#modal'</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      <span class="attr">isShowing</span>: <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">methods</span>: {</span><br><span class="line">    <span class="title function_">toggleShow</span>(<span class="params"></span>) {</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">isShowing</span> = !<span class="variable language_">this</span>.<span class="property">isShowing</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义一个<code>tooltip</code>提示框，内部通过<code>isShowing</code>来控制显示</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Tooltip</span> = {</span><br><span class="line">  <span class="attr">template</span>: <span class="string">'#tooltip'</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      <span class="attr">isShowing</span>: <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">methods</span>: {</span><br><span class="line">    <span class="title function_">toggleShow</span>(<span class="params"></span>) {</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">isShowing</span> = !<span class="variable language_">this</span>.<span class="property">isShowing</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过观察上面两个组件，发现两者的逻辑是相同，代码控制显示也是相同的，这时候<code>mixin</code>就派上用场了</p>
<p>首先抽出共同代码，编写一个<code>mixin</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toggle = {</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      <span class="attr">isShowing</span>: <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">methods</span>: {</span><br><span class="line">    <span class="title function_">toggleShow</span>(<span class="params"></span>) {</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">isShowing</span> = !<span class="variable language_">this</span>.<span class="property">isShowing</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>两个组件在使用上，只需要引入<code>mixin</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Modal</span> = {</span><br><span class="line">  <span class="attr">template</span>: <span class="string">'#modal'</span>,</span><br><span class="line">  <span class="attr">mixins</span>: [toggle]</span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Tooltip</span> = {</span><br><span class="line">  <span class="attr">template</span>: <span class="string">'#tooltip'</span>,</span><br><span class="line">  <span class="attr">mixins</span>: [toggle]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过上面小小的例子，让我们知道了<code>Mixin</code>对于封装一些可复用的功能如此有趣、方便、实用</p>
<h3 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h3><p>首先从<code>Vue.mixin</code>入手</p>
<p>源码位置：/src/core/global-api/mixin.js</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initMixin</span> (<span class="title class_">Vue</span>: <span class="title class_">GlobalAPI</span>) {</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">mixin</span> = <span class="keyword">function</span> (<span class="params">mixin: <span class="built_in">Object</span></span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">options</span> = <span class="title function_">mergeOptions</span>(<span class="variable language_">this</span>.<span class="property">options</span>, mixin)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>主要是调用<code>merOptions</code>方法</p>
<p>源码位置：/src/core/util/options.js</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mergeOptions</span> (</span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">Object</span>,</span><br><span class="line">  <span class="attr">child</span>: <span class="title class_">Object</span>,</span><br><span class="line">  vm?: <span class="title class_">Component</span></span><br><span class="line">): <span class="title class_">Object</span> {</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child.<span class="property">mixins</span>) { <span class="comment">// 判断有没有mixin 也就是mixin里面挂mixin的情况 有的话递归进行合并</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.<span class="property">mixins</span>.<span class="property">length</span>; i &lt; l; i++) {</span><br><span class="line">    parent = <span class="title function_">mergeOptions</span>(parent, child.<span class="property">mixins</span>[i], vm)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = {} </span><br><span class="line">  <span class="keyword">let</span> key</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> parent) {</span><br><span class="line">    <span class="title function_">mergeField</span>(key) <span class="comment">// 先遍历parent的key 调对应的strats[XXX]方法进行合并</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> child) {</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">hasOwn</span>(parent, key)) { <span class="comment">// 如果parent已经处理过某个key 就不处理了</span></span><br><span class="line">      <span class="title function_">mergeField</span>(key) <span class="comment">// 处理child中的key 也就parent中没有处理过的key</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">mergeField</span> (key) {</span><br><span class="line">    <span class="keyword">const</span> strat = strats[key] || defaultStrat</span><br><span class="line">    options[key] = <span class="title function_">strat</span>(parent[key], child[key], vm, key) <span class="comment">// 根据不同类型的options调用strats中不同的方法进行合并</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从上面的源码，我们得到以下几点：</p>
<ul>
<li>优先递归处理 <code>mixins</code></li>
<li>先遍历合并<code>parent</code> 中的<code>key</code>，调用<code>mergeField</code>方法进行合并，然后保存在变量<code>options</code></li>
<li>再遍历 <code>child</code>，合并补上 <code>parent</code> 中没有的<code>key</code>，调用<code>mergeField</code>方法进行合并，保存在变量<code>options</code></li>
<li>通过 <code>mergeField</code> 函数进行了合并</li>
</ul>
<p>下面是关于<code>Vue</code>的几种类型的合并策略</p>
<ul>
<li>替换型</li>
<li>合并型</li>
<li>队列型</li>
<li>叠加型</li>
</ul>
<h4 id="替换型"><a href="#替换型" class="headerlink" title="替换型"></a>替换型</h4><p>替换型合并有<code>props</code>、<code>methods</code>、<code>inject</code>、<code>computed</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">strats.<span class="property">props</span> =</span><br><span class="line">strats.<span class="property">methods</span> =</span><br><span class="line">strats.<span class="property">inject</span> =</span><br><span class="line">strats.<span class="property">computed</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  parentVal: ?<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  childVal: ?<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  vm?: Component,</span></span><br><span class="line"><span class="params">  key: string</span></span><br><span class="line"><span class="params"></span>): ?<span class="title class_">Object</span> {</span><br><span class="line">  <span class="keyword">if</span> (!parentVal) <span class="keyword">return</span> childVal <span class="comment">// 如果parentVal没有值，直接返回childVal</span></span><br><span class="line">  <span class="keyword">const</span> ret = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>) <span class="comment">// 创建一个第三方对象 ret</span></span><br><span class="line">  <span class="title function_">extend</span>(ret, parentVal) <span class="comment">// extend方法实际是把parentVal的属性复制到ret中</span></span><br><span class="line">  <span class="keyword">if</span> (childVal) <span class="title function_">extend</span>(ret, childVal) <span class="comment">// 把childVal的属性复制到ret中</span></span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">}</span><br><span class="line">strats.<span class="property">provide</span> = mergeDataOrFn</span><br></pre></td></tr></tbody></table></figure>

<p>同名的<code>props</code>、<code>methods</code>、<code>inject</code>、<code>computed</code>会被后来者代替</p>
<h4 id="合并型"><a href="#合并型" class="headerlink" title="合并型"></a>合并型</h4><p>和并型合并有：<code>data</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">strats.<span class="property">data</span> = <span class="keyword">function</span>(<span class="params">parentVal, childVal, vm</span>) {    </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mergeDataOrFn</span>(</span><br><span class="line">        parentVal, childVal, vm</span><br><span class="line">    )</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeDataOrFn</span>(<span class="params">parentVal, childVal, vm</span>) {    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">mergedInstanceDataFn</span>(<span class="params"></span>) {        </span><br><span class="line">        <span class="keyword">var</span> childData = childVal.<span class="title function_">call</span>(vm, vm) <span class="comment">// 执行data挂的函数得到对象</span></span><br><span class="line">        <span class="keyword">var</span> parentData = parentVal.<span class="title function_">call</span>(vm, vm)        </span><br><span class="line">        <span class="keyword">if</span> (childData) {            </span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">mergeData</span>(childData, parentData) <span class="comment">// 将2个对象进行合并                                 </span></span><br><span class="line">        } <span class="keyword">else</span> {            </span><br><span class="line">            <span class="keyword">return</span> parentData <span class="comment">// 如果没有childData 直接返回parentData</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeData</span>(<span class="params">to, <span class="keyword">from</span></span>) {    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">from</span>) <span class="keyword">return</span> to    </span><br><span class="line">    <span class="keyword">var</span> key, toVal, fromVal;    </span><br><span class="line">    <span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="keyword">from</span>);   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) {</span><br><span class="line">        key = keys[i];</span><br><span class="line">        toVal = to[key];</span><br><span class="line">        fromVal = <span class="keyword">from</span>[key];    </span><br><span class="line">        <span class="comment">// 如果不存在这个属性，就重新设置</span></span><br><span class="line">        <span class="keyword">if</span> (!to.<span class="title function_">hasOwnProperty</span>(key)) {</span><br><span class="line">            <span class="title function_">set</span>(to, key, fromVal);</span><br><span class="line">        }      </span><br><span class="line">        <span class="comment">// 存在相同属性，合并对象</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> toVal ==<span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> fromVal ==<span class="string">"object"</span>) {</span><br><span class="line">            <span class="title function_">mergeData</span>(toVal, fromVal);</span><br><span class="line">        }</span><br><span class="line">    }    </span><br><span class="line">    <span class="keyword">return</span> to</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>mergeData</code>函数遍历了要合并的 data 的所有属性，然后根据不同情况进行合并：</p>
<ul>
<li>当目标 data 对象不包含当前属性时，调用 <code>set</code> 方法进行合并（set方法其实就是一些合并重新赋值的方法）</li>
<li>当目标 data 对象包含当前属性并且当前值为纯对象时，递归合并当前对象值，这样做是为了防止对象存在新增属性</li>
</ul>
<h4 id="队列性"><a href="#队列性" class="headerlink" title="队列性"></a>队列性</h4><p>队列性合并有：全部生命周期和<code>watch</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeHook</span> (</span><br><span class="line">  <span class="attr">parentVal</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">Function</span>&gt;,</span><br><span class="line">  <span class="attr">childVal</span>: ?<span class="title class_">Function</span> | ?<span class="title class_">Array</span>&lt;<span class="title class_">Function</span>&gt;</span><br><span class="line">): ?<span class="title class_">Array</span>&lt;<span class="title class_">Function</span>&gt; {</span><br><span class="line">  <span class="keyword">return</span> childVal</span><br><span class="line">    ? parentVal</span><br><span class="line">      ? parentVal.<span class="title function_">concat</span>(childVal)</span><br><span class="line">      : <span class="title class_">Array</span>.<span class="title function_">isArray</span>(childVal)</span><br><span class="line">        ? childVal</span><br><span class="line">        : [childVal]</span><br><span class="line">    : parentVal</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">LIFECYCLE_HOOKS</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">hook</span> =&gt;</span> {</span><br><span class="line">  strats[hook] = mergeHook</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// watch</span></span><br><span class="line">strats.<span class="property">watch</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  parentVal,</span></span><br><span class="line"><span class="params">  childVal,</span></span><br><span class="line"><span class="params">  vm,</span></span><br><span class="line"><span class="params">  key</span></span><br><span class="line"><span class="params"></span>) {</span><br><span class="line">  <span class="comment">// work around Firefox's Object.prototype.watch...</span></span><br><span class="line">  <span class="keyword">if</span> (parentVal === nativeWatch) { parentVal = <span class="literal">undefined</span>; }</span><br><span class="line">  <span class="keyword">if</span> (childVal === nativeWatch) { childVal = <span class="literal">undefined</span>; }</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (!childVal) { <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">create</span>(parentVal || <span class="literal">null</span>) }</span><br><span class="line">  {</span><br><span class="line">    <span class="title function_">assertObjectType</span>(key, childVal, vm);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (!parentVal) { <span class="keyword">return</span> childVal }</span><br><span class="line">  <span class="keyword">var</span> ret = {};</span><br><span class="line">  <span class="title function_">extend</span>(ret, parentVal);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key$1 <span class="keyword">in</span> childVal) {</span><br><span class="line">    <span class="keyword">var</span> parent = ret[key$1];</span><br><span class="line">    <span class="keyword">var</span> child = childVal[key$1];</span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; !<span class="title class_">Array</span>.<span class="title function_">isArray</span>(parent)) {</span><br><span class="line">      parent = [parent];</span><br><span class="line">    }</span><br><span class="line">    ret[key$1] = parent</span><br><span class="line">      ? parent.<span class="title function_">concat</span>(child)</span><br><span class="line">      : <span class="title class_">Array</span>.<span class="title function_">isArray</span>(child) ? child : [child];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>生命周期钩子和<code>watch</code>被合并为一个数组，然后正序遍历一次执行</p>
<h4 id="叠加型"><a href="#叠加型" class="headerlink" title="叠加型"></a>叠加型</h4><p>叠加型合并有：<code>component</code>、<code>directives</code>、<code>filters</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">strats.<span class="property">components</span>=</span><br><span class="line">strats.<span class="property">directives</span>=</span><br><span class="line"></span><br><span class="line">strats.<span class="property">filters</span> = <span class="keyword">function</span> <span class="title function_">mergeAssets</span>(<span class="params"></span></span><br><span class="line"><span class="params">    parentVal, childVal, vm, key</span></span><br><span class="line"><span class="params"></span>) {    </span><br><span class="line">    <span class="keyword">var</span> res = <span class="title class_">Object</span>.<span class="title function_">create</span>(parentVal || <span class="literal">null</span>);    </span><br><span class="line">    <span class="keyword">if</span> (childVal) { </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> childVal) {</span><br><span class="line">            res[key] = childVal[key];</span><br><span class="line">        }   </span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>叠加型主要是通过原型链进行层层的叠加</p>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul>
<li>替换型策略有<code>props</code>、<code>methods</code>、<code>inject</code>、<code>computed</code>，就是将新的同名参数替代旧的参数</li>
<li>合并型策略是<code>data</code>, 通过<code>set</code>方法进行合并和重新赋值</li>
<li>队列型策略有生命周期函数和<code>watch</code>，原理是将函数存入一个数组，然后正序遍历依次执行</li>
<li>叠加型有<code>component</code>、<code>directives</code>、<code>filters</code>，通过原型链进行层层的叠加</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/31018570">https://zhuanlan.zhihu.com/p/31018570</a></li>
<li><a href="https://juejin.cn/post/6844904015495446536#heading-1">https://juejin.cn/post/6844904015495446536#heading-1</a></li>
<li><a href="https://juejin.cn/post/6844903846775357453">https://juejin.cn/post/6844903846775357453</a></li>
<li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li>
<li>@Js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>说说你对vue的mixin的理解</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈Vue.observable</title>
    <url>/posts/34079.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="谈谈Vue-observable"><a href="#谈谈Vue-observable" class="headerlink" title="谈谈Vue.observable"></a>谈谈Vue.observable</h1><h2 id="面试官：Vue-observable你有了解过吗？说说看"><a href="#面试官：Vue-observable你有了解过吗？说说看" class="headerlink" title="面试官：Vue.observable你有了解过吗？说说看"></a>面试官：Vue.observable你有了解过吗？说说看</h2><img src="/posts/34079/34079/image-20221025070423402.png" class="" title="image-20221025070423402">

<h3 id="一、Observable-是什么"><a href="#一、Observable-是什么" class="headerlink" title="一、Observable 是什么"></a>一、Observable 是什么</h3><p><code>Observable</code> 翻译过来我们可以理解成<strong>可观察的</strong></p>
<span id="more"></span>

<p>我们先来看一下其在<code>Vue</code>中的定义</p>
<blockquote>
<p><code>Vue.observable</code>，让一个对象变成响应式数据。<code>Vue</code> 内部会用它来处理 <code>data</code> 函数返回的对象</p>
</blockquote>
<p>返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">observable</span>({ count : <span class="number">1</span>})</span><br></pre></td></tr></tbody></table></figure>

<p>其作用等同于</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title function_">vue</span>({ count : <span class="number">1</span>})</span><br></pre></td></tr></tbody></table></figure>

<p>在 <code>Vue 2.x</code> 中，被传入的对象会直接被 <code>Vue.observable</code> 变更，它和被返回的对象是同一个对象</p>
<p>在 <code>Vue 3.x</code> 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的</p>
<h3 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h3><p>在非父子组件通信时，可以使用通常的<code>bus</code>或者使用<code>vuex</code>，但是实现的功能不是太复杂，而使用上面两个又有点繁琐。这时，<code>observable</code>就是一个很好的选择</p>
<p>创建一个<code>js</code>文件</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 引入vue</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">'vue</span></span><br><span class="line"><span class="string">// 创建state对象，使用observable让state对象可响应</span></span><br><span class="line"><span class="string">export let state = Vue.observable({</span></span><br><span class="line"><span class="string">  name: '</span>张三<span class="string">',</span></span><br><span class="line"><span class="string">  '</span>age<span class="string">': 38</span></span><br><span class="line"><span class="string">})</span></span><br><span class="line"><span class="string">// 创建对应的方法</span></span><br><span class="line"><span class="string">export let mutations = {</span></span><br><span class="line"><span class="string">  changeName(name) {</span></span><br><span class="line"><span class="string">    state.name = name</span></span><br><span class="line"><span class="string">  },</span></span><br><span class="line"><span class="string">  setAge(age) {</span></span><br><span class="line"><span class="string">    state.age = age</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>在<code>.vue</code>文件中直接使用即可</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    姓名：{{ name }}</span></span><br><span class="line"><span class="language-xml">    年龄：{{ age }}</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeName('李四')"</span>&gt;</span>改变姓名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"setAge(18)"</span>&gt;</span>改变年龄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="keyword">import</span> { state, mutations } <span class="keyword">from</span> <span class="string">'@/store</span></span><br><span class="line"><span class="string">export default {</span></span><br><span class="line"><span class="string">  // 在计算属性中拿到值</span></span><br><span class="line"><span class="string">  computed: {</span></span><br><span class="line"><span class="string">    name() {</span></span><br><span class="line"><span class="string">      return state.name</span></span><br><span class="line"><span class="string">    },</span></span><br><span class="line"><span class="string">    age() {</span></span><br><span class="line"><span class="string">      return state.age</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  },</span></span><br><span class="line"><span class="string">  // 调用mutations里面的方法，更新数据</span></span><br><span class="line"><span class="string">  methods: {</span></span><br><span class="line"><span class="string">    changeName: mutations.changeName,</span></span><br><span class="line"><span class="string">    setAge: mutations.setAge</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a>三、原理分析</h3><p>源码位置：src\core\observer\index.js</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">observe</span> (<span class="attr">value</span>: any, <span class="attr">asRootData</span>: ?boolean): <span class="title class_">Observer</span> | <span class="keyword">void</span> {</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(value) || value <span class="keyword">instanceof</span> <span class="title class_">VNode</span>) {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">ob</span>: <span class="title class_">Observer</span> | <span class="keyword">void</span></span><br><span class="line">  <span class="comment">// 判断是否存在__ob__响应式属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(value, <span class="string">'__ob__'</span>) &amp;&amp; value.<span class="property">__ob__</span> <span class="keyword">instanceof</span> <span class="title class_">Observer</span>) {</span><br><span class="line">    ob = value.<span class="property">__ob__</span></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !<span class="title function_">isServerRendering</span>() &amp;&amp;</span><br><span class="line">    (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value) || <span class="title function_">isPlainObject</span>(value)) &amp;&amp;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(value) &amp;&amp;</span><br><span class="line">    !value.<span class="property">_isVue</span></span><br><span class="line">  ) {</span><br><span class="line">    <span class="comment">// 实例化Observer响应式对象</span></span><br><span class="line">    ob = <span class="keyword">new</span> <span class="title class_">Observer</span>(value)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) {</span><br><span class="line">    ob.<span class="property">vmCount</span>++</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>Observer</code>类</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observer</span> {</span><br><span class="line">    <span class="attr">value</span>: any;</span><br><span class="line">    <span class="attr">dep</span>: <span class="title class_">Dep</span>;</span><br><span class="line">    <span class="attr">vmCount</span>: number; <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span> (<span class="attr">value</span>: any) {</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vmCount</span> = <span class="number">0</span></span><br><span class="line">        <span class="title function_">def</span>(value, <span class="string">'__ob__'</span>, <span class="variable language_">this</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) {</span><br><span class="line">            <span class="keyword">if</span> (hasProto) {</span><br><span class="line">                <span class="title function_">protoAugment</span>(value, arrayMethods)</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="title function_">copyAugment</span>(value, arrayMethods, arrayKeys)</span><br><span class="line">            }</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">observeArray</span>(value)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 实例化对象是一个对象，进入walk方法</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">walk</span>(value)</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>walk</code>函数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">walk (<span class="attr">obj</span>: <span class="title class_">Object</span>) {</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line">    <span class="comment">// 遍历key，通过defineReactive创建响应式对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) {</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, keys[i])</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>defineReactive</code>方法</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineReactive</span> (</span><br><span class="line">  <span class="attr">obj</span>: <span class="title class_">Object</span>,</span><br><span class="line">  <span class="attr">key</span>: string,</span><br><span class="line">  <span class="attr">val</span>: any,</span><br><span class="line">  customSetter?: ?<span class="title class_">Function</span>,</span><br><span class="line">  shallow?: boolean</span><br><span class="line">) {</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.<span class="property">configurable</span> === <span class="literal">false</span>) {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.<span class="property">get</span></span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.<span class="property">set</span></span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) {</span><br><span class="line">    val = obj[key]</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(val)</span><br><span class="line">  <span class="comment">// 接下来调用Object.defineProperty()给对象定义响应式属性</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, {</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> () {</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) {</span><br><span class="line">        dep.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">if</span> (childOb) {</span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) {</span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span> (newVal) {</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      }</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp; customSetter) {</span><br><span class="line">        <span class="title function_">customSetter</span>()</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) {</span><br><span class="line">        setter.<span class="title function_">call</span>(obj, newVal)</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        val = newVal</span><br><span class="line">      }</span><br><span class="line">      childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(newVal)</span><br><span class="line">      <span class="comment">// 对观察者watchers进行通知,state就成了全局响应式对象</span></span><br><span class="line">      dep.<span class="title function_">notify</span>()</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://blog.csdn.net/qq_32682301/article/details/105419673">https://blog.csdn.net/qq_32682301/article/details/105419673</a></li>
<li><a href="https://wbbyouzi.com/archives/343">https://wbbyouzi.com/archives/343</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>Vue.observable</tag>
      </tags>
  </entry>
  <entry>
    <title>说说你对vue的理解</title>
    <url>/posts/25539.html</url>
    <content><![CDATA[<html><head></head><body><p>我们要了解一个东西的时候， 要研究它的历史， 为什么会有它， 它的存在给我们带来了什么？</p>
<h1 id="面试官：有使用过vue吗？说说你对vue的理解"><a href="#面试官：有使用过vue吗？说说你对vue的理解" class="headerlink" title="面试官：有使用过vue吗？说说你对vue的理解"></a>面试官：有使用过vue吗？说说你对vue的理解</h1><img src="/posts/25539/25539/image-20221010064433999.png" class="" title="image-20221010064433999">

<h2 id="一、从历史说起"><a href="#一、从历史说起" class="headerlink" title="一、从历史说起"></a>一、从历史说起</h2><p>Web是World Wide Web的简称，中文译为万维网我们可以将它规划成如下的几个时代来进行理解</p>
<ul>
<li>石器时代</li>
<li>文明时代</li>
<li>工业革命时代</li>
<li>百花齐放时代</li>
</ul>
<span id="more"></span>

<h3 id="石器时代"><a href="#石器时代" class="headerlink" title="石器时代"></a>石器时代</h3><p>石器时代指的就是我们的静态网页，可以欣赏一下1997的Apple官网</p>
<img src="/posts/25539/25539/image-20221010064505654.png" class="" title="image-20221010064505654">

<p>最早的网页是没有数据库的，可以理解成就是一张可以在网络上浏览的报纸，直到CGI技术的出现通过 CGI Perl 运行一小段代码与数据库或文件系统进行交互，如当时的Google（1998年）</p>
<img src="/posts/25539/25539/image-20221010064531950.png" class="" title="image-20221010064531950">

<h3 id="文明时代"><a href="#文明时代" class="headerlink" title="文明时代"></a>文明时代</h3><p>ASP，JSP大家应该都不会太陌生，最早出现于 2005 年左右，先后出现了微软的 ASP 和 Java Server Pages [JSP] 等技术,取代了 CGI ，增强了 WEB 与服务端的交互的安全性，类似于下面这样，其实就是Java + HTML</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%@ page language="java" contentType="text/html; charset=utf-8"   pageEncoding="utf-8"%&gt; <span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> <span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="tag">&lt;<span class="name">head</span>&gt;</span>  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span>  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JSP demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span> <span class="tag">&lt;<span class="name">body</span>&gt;</span>  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/web05_session/1.jpg"</span> <span class="attr">width</span>=<span class="string">200</span> <span class="attr">height</span>=<span class="string">100</span> /&gt;</span> <span class="tag">&lt;/<span class="name">body</span>&gt;</span> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>JSP有一个很大的缺点，就是不太灵活，因为JSP是在服务器端执行的，通常返回该客户端的就是一个HTML文本。我们每次的请求：获取的数据、内容的加载，都是服务器为我们返回渲染完成之后的 DOM，这也就使得我们开发网站的灵活度大打折扣在这种情况下，同年：Ajax火了(小细节，这里为什么说火了，因为 Ajax 技术并不是 2005 年出现的，他的雏形是 1999 年)，现在看来很常见的技术手段，在当时可是珍贵无比</p>
<h3 id="工业革命时代"><a href="#工业革命时代" class="headerlink" title="工业革命时代"></a>工业革命时代</h3><p>到这里大家就更熟悉了，移动设备的普及，Jquery的出现，以及SPA（Single Page Application 单页面应用）的雏形，Backbone EmberJS AngularJS 这样一批前端框架随之出现，但当时SPA的路不好走，例如SEO问题，SPA 过多的页面、复杂场景下 View 的绑定等，都没有很好的处理经过这几年的飞速发展，节约了开发人员大量的精力、降低了开发者和开发过程的门槛，极大提升了开发效率和迭代速度，我们可以称之其为工业时代</p>
<h3 id="百花齐放时代"><a href="#百花齐放时代" class="headerlink" title="百花齐放时代"></a>百花齐放时代</h3><p>这里没有文字，放一张图感受一下</p>
<img src="/posts/25539/25539/image-20221010064557197.png" class="" title="image-20221010064557197">

<p>PS：这里为什么要说这么多Web的历史，我们可以看到Web技术的变化之大与快，每一种新的技术出现都是一些特定场景的解决方案，那我们今天的主角Vue又是为了解决什么呢？我们接着往下看</p>
<h2 id="二、vue是什么"><a href="#二、vue是什么" class="headerlink" title="二、vue是什么"></a>二、vue是什么</h2><p>Vue.js（/vjuː/，或简称为Vue）是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架。2016年一项针对JavaScript的调查表明，Vue有着89%的开发者满意度。在GitHub上，该项目平均每天能收获95颗星，为Github有史以来星标数第3多的项目同时也是一款流行的JavaScript前端框架，旨在更好地组织与简化Web开发。Vue所关注的核心是MVC模式中的视图层，同时，它也能方便地获取数据更新，并通过组件内部特定的方法实现视图与模型的交互PS: Vue作者尤雨溪是在为AngularJS工作之后开发出了这一框架。他声称自己的思路是提取Angular中为自己所喜欢的部分，构建出一款相当轻量的框架最早发布于2014年2月</p>
<h2 id="三、Vue核心特性"><a href="#三、Vue核心特性" class="headerlink" title="三、Vue核心特性"></a>三、Vue核心特性</h2><h3 id="数据驱动（MVVM"><a href="#数据驱动（MVVM" class="headerlink" title="数据驱动（MVVM)"></a>数据驱动（MVVM)</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">MVVM`表示的是 `Model-View-ViewModel</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li>
<li>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面</li>
<li>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁</li>
</ul>
<p>这时候需要一张直观的关系图，如下</p>
<img src="/posts/25539/25539/image-20221010064628546.png" class="" title="image-20221010064628546">

<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>1.什么是组件化一句话来说就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件2.组件化的优势</p>
<ul>
<li>降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</li>
<li>调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</li>
<li>提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</li>
</ul>
<h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><p>解释：指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p>
<ul>
<li>常用的指令<ul>
<li>条件渲染指令 <code>v-if</code></li>
<li>列表渲染指令<code>v-for</code></li>
<li>属性绑定指令<code>v-bind</code></li>
<li>事件绑定指令<code>v-on</code></li>
<li>双向数据绑定指令<code>v-model</code></li>
</ul>
</li>
</ul>
<p>没有指令之前我们是怎么做的？是不是先要获取到DOM然后在….干点啥</p>
<h2 id="四、Vue跟传统开发的区别"><a href="#四、Vue跟传统开发的区别" class="headerlink" title="四、Vue跟传统开发的区别"></a>四、Vue跟传统开发的区别</h2><p>没有落地使用场景的革命不是好革命，就以一个高频的应用场景来示意吧注册账号这个需求大家应该很熟悉了，如下</p>
<img src="/posts/25539/25539/image-20221010064654317.png" class="" title="image-20221010064654317">

<p>用<code>jquery</code>来实现大概的思路就是选择流程dom对象，点击按钮隐藏当前活动流程dom对象，显示下一流程dom对象如下图(代码就不上了，上了就篇文章就没了..)</p>
<img src="/posts/25539/25539/image-20221010064711619.png" class="" title="image-20221010064711619">

<p>用<code>vue</code>来实现，我们知道<code>vue</code>基本不操作<code>dom</code>节点， 双向绑定使<code>dom</code>节点跟视图绑定后，通过修改变量的值控制<code>dom</code>节点的各类属性。所以其实现思路为：视图层使用一变量控制dom节点显示与否，点击按钮则改变该变量，如下图</p>
<img src="/posts/25539/25539/image-20221010064731312.png" class="" title="image-20221010064731312">

<p>总结就是：</p>
<ul>
<li>Vue所有的界面事件，都是只去操作数据的，Jquery操作DOM</li>
<li>Vue所有界面的变动，都是根据数据自动绑定出来的，Jquery操作DOM</li>
</ul>
<h2 id="五、Vue和React对比"><a href="#五、Vue和React对比" class="headerlink" title="五、Vue和React对比"></a>五、Vue和React对比</h2><p>这里就做几个简单的类比吧，当然没有好坏之分，只是使用场景不同</p>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul>
<li>都有组件化思想</li>
<li>都支持服务器端渲染</li>
<li>都有Virtual DOM（虚拟dom）</li>
<li>数据驱动视图</li>
<li>都有支持native的方案：<code>Vue</code>的<code>weex</code>、<code>React</code>的<code>React native</code></li>
<li>都有自己的构建工具：<code>Vue</code>的<code>vue-cli</code>、<code>React</code>的<code>Create React App</code></li>
</ul>
<p>区别</p>
<ul>
<li>数据流向的不同。<code>react</code>从诞生开始就推崇单向数据流，而<code>Vue</code>是双向数据流</li>
<li>数据变化的实现原理不同。<code>react</code>使用的是不可变数据，而<code>Vue</code>使用的是可变的数据</li>
<li>组件化通信的不同。<code>react</code>中我们通过使用回调函数来进行通信的，而<code>Vue</code>中子组件向父组件传递消息有两种方式：事件和回调函数</li>
<li>diff算法不同。<code>react</code>主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。<code>Vue</code> 使用双向指针，边对比，边更新DOM</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://segmentfault.com/a/1190000016269636">https://segmentfault.com/a/1190000016269636</a></li>
<li><a href="https://zh.wikipedia.org/zh-cn/Vue.js">https://zh.wikipedia.org/zh-cn/Vue.js</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20197803">https://zhuanlan.zhihu.com/p/20197803</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/38296857">https://zhuanlan.zhihu.com/p/38296857</a></li>
<li>@js语音答题社群</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>对vue的理解</tag>
      </tags>
  </entry>
  <entry>
    <title>说说你对双向绑定的理解</title>
    <url>/posts/20922.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="双向绑定："><a href="#双向绑定：" class="headerlink" title="双向绑定："></a>双向绑定：</h1><h2 id="面试官：双向数据绑定是什么？"><a href="#面试官：双向数据绑定是什么？" class="headerlink" title="面试官：双向数据绑定是什么？"></a>面试官：双向数据绑定是什么？</h2><img src="/posts/20922/20922/image-20221021060613772.png" class="" title="image-20221021060613772">

<h3 id="一、什么是双向绑定"><a href="#一、什么是双向绑定" class="headerlink" title="一、什么是双向绑定"></a>一、什么是双向绑定</h3><p>我们先从单向绑定切入单向绑定非常简单，就是把<code>Model</code>绑定到<code>View</code>，当我们用<code>JavaScript</code>代码更新<code>Model</code>时，<code>View</code>就会自动更新双向绑定就很容易联想到了，在单向绑定的基础上，用户更新了<code>View</code>，<code>Model</code>的数据也自动被更新了，这种情况就是双向绑定举个栗子</p>
<span id="more"></span>

<img src="/posts/20922/20922/image-20221021060637237.png" class="" title="image-20221021060637237">

<p>当用户填写表单时，<code>View</code>的状态就被更新了，如果此时可以自动更新<code>Model</code>的状态，那就相当于我们把<code>Model</code>和<code>View</code>做了双向绑定关系图如下</p>
<img src="/posts/20922/20922/image-20221021060655835.png" class="" title="image-20221021060655835">

<h3 id="二、双向绑定的原理是什么"><a href="#二、双向绑定的原理是什么" class="headerlink" title="二、双向绑定的原理是什么"></a>二、双向绑定的原理是什么</h3><p>我们都知道 <code>Vue</code> 是数据双向绑定的框架，双向绑定由三个重要部分构成</p>
<ul>
<li>数据层（Model）：应用的数据及业务逻辑</li>
<li>视图层（View）：应用的展示效果，各类UI组件</li>
<li>业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来</li>
</ul>
<p>而上面的这个分层的架构方案，可以用一个专业术语进行称呼：<code>MVVM</code>这里的控制层的核心功能便是 “数据双向绑定” 。自然，我们只需弄懂它是什么，便可以进一步了解数据绑定的原理</p>
<h4 id="理解ViewModel"><a href="#理解ViewModel" class="headerlink" title="理解ViewModel"></a>理解ViewModel</h4><p>它的主要职责就是：</p>
<ul>
<li>数据变化后更新视图</li>
<li>视图变化后更新数据</li>
</ul>
<p>当然，它还有两个主要部分组成</p>
<ul>
<li>监听器（Observer）：对所有数据的属性进行监听</li>
<li>解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</li>
</ul>
<h3 id="三、实现双向绑定"><a href="#三、实现双向绑定" class="headerlink" title="三、实现双向绑定"></a>三、实现双向绑定</h3><p>我们还是以<code>Vue</code>为例，先来看看<code>Vue</code>中的双向绑定流程是什么的</p>
<ol>
<li><code>new Vue()</code>首先执行初始化，对<code>data</code>执行响应化处理，这个过程发生<code>Observe</code>中</li>
<li>同时对模板执行编译，找到其中动态绑定的数据，从<code>data</code>中获取并初始化视图，这个过程发生在<code>Compile</code>中</li>
<li>同时定义⼀个更新函数和<code>Watcher</code>，将来对应数据变化时<code>Watcher</code>会调用更新函数</li>
<li>由于<code>data</code>的某个<code>key</code>在⼀个视图中可能出现多次，所以每个<code>key</code>都需要⼀个管家<code>Dep</code>来管理多个<code>Watcher</code></li>
<li>将来data中数据⼀旦发生变化，会首先找到对应的<code>Dep</code>，通知所有<code>Watcher</code>执行更新函数</li>
</ol>
<p>流程图如下：</p>
<img src="/posts/20922/20922/image-20221021060721770.png" class="" title="image-20221021060721770">

<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>先来一个构造函数：执行初始化，对<code>data</code>执行响应化处理</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> {  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) {  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$options</span> = options;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;  </span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 对data选项做响应式处理  </span></span><br><span class="line">    <span class="title function_">observe</span>(<span class="variable language_">this</span>.<span class="property">$data</span>);  </span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 代理data到vm上  </span></span><br><span class="line">    <span class="title function_">proxy</span>(<span class="variable language_">this</span>);  </span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 执行编译  </span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Compile</span>(options.<span class="property">el</span>, <span class="variable language_">this</span>);  </span><br><span class="line">  }  </span><br></pre></td></tr></tbody></table></figure>

<p>对<code>data</code>选项执行响应化具体操作</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) {  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">"object"</span> || obj == <span class="literal">null</span>) {  </span><br><span class="line">    <span class="keyword">return</span>;  </span><br><span class="line">  }  </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Observer</span>(obj);  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> {  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) {  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">walk</span>(value);  </span><br><span class="line">  }  </span><br><span class="line">  <span class="title function_">walk</span>(<span class="params">obj</span>) {  </span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> {  </span><br><span class="line">      <span class="title function_">defineReactive</span>(obj, key, obj[key]);  </span><br><span class="line">    });  </span><br><span class="line">  }  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<h5 id="编译Compile"><a href="#编译Compile" class="headerlink" title="编译Compile"></a>编译<code>Compile</code></h5><p>对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</p>
<img src="/posts/20922/20922/image-20221021060822249.png" class="" title="image-20221021060822249">

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compile</span> {  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">el, vm</span>) {  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$vm</span> = vm;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(el);  <span class="comment">// 获取dom  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">$el</span>) {  </span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">compile</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);  </span><br><span class="line">    }  </span><br><span class="line">  }  </span><br><span class="line">  <span class="title function_">compile</span>(<span class="params">el</span>) {  </span><br><span class="line">    <span class="keyword">const</span> childNodes = el.<span class="property">childNodes</span>;   </span><br><span class="line">    <span class="title class_">Array</span>.<span class="title function_">from</span>(childNodes).<span class="title function_">forEach</span>(<span class="function">(<span class="params">node</span>) =&gt;</span> { <span class="comment">// 遍历子元素  </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isElement</span>(node)) {   <span class="comment">// 判断是否为节点  </span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"编译元素"</span> + node.<span class="property">nodeName</span>);  </span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isInterpolation</span>(node)) {  </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"编译插值⽂本"</span> + node.<span class="property">textContent</span>);  <span class="comment">// 判断是否为插值文本 {{}}  </span></span><br><span class="line">      }  </span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">childNodes</span> &amp;&amp; node.<span class="property">childNodes</span>.<span class="property">length</span> &gt; <span class="number">0</span>) {  <span class="comment">// 判断是否有子元素  </span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">compile</span>(node);  <span class="comment">// 对子元素进行递归遍历  </span></span><br><span class="line">      }  </span><br><span class="line">    });  </span><br><span class="line">  }  </span><br><span class="line">  <span class="title function_">isElement</span>(<span class="params">node</span>) {  </span><br><span class="line">    <span class="keyword">return</span> node.<span class="property">nodeType</span> == <span class="number">1</span>;  </span><br><span class="line">  }  </span><br><span class="line">  <span class="title function_">isInterpolation</span>(<span class="params">node</span>) {  </span><br><span class="line">    <span class="keyword">return</span> node.<span class="property">nodeType</span> == <span class="number">3</span> &amp;&amp; <span class="regexp">/\{\{(.*)\}\}/</span>.<span class="title function_">test</span>(node.<span class="property">textContent</span>);  </span><br><span class="line">  }  </span><br><span class="line">}  </span><br><span class="line">  </span><br></pre></td></tr></tbody></table></figure>

<h5 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h5><p>视图中会用到<code>data</code>中某<code>key</code>，这称为依赖。同⼀个<code>key</code>可能出现多次，每次都需要收集出来用⼀个<code>Watcher</code>来维护它们，此过程称为依赖收集多个<code>Watcher</code>需要⼀个<code>Dep</code>来管理，需要更新时由<code>Dep</code>统⼀通知</p>
<img src="/posts/20922/20922/image-20221021060853096.png" class="" title="image-20221021060853096">

<p>实现思路</p>
<ol>
<li><code>defineReactive</code>时为每⼀个<code>key</code>创建⼀个<code>Dep</code>实例</li>
<li>初始化视图时读取某个<code>key</code>，例如<code>name1</code>，创建⼀个<code>watcher1</code></li>
<li>由于触发<code>name1</code>的<code>getter</code>方法，便将<code>watcher1</code>添加到<code>name1</code>对应的Dep中</li>
<li>当<code>name1</code>更新，<code>setter</code>触发时，便可通过对应<code>Dep</code>通知其管理所有<code>Watcher</code>更新</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 负责更新视图  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> {  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm, key, updater</span>) {  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">updaterFn</span> = updater  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建实例时，把当前实例指定到Dep.target静态属性上  </span></span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>  </span><br><span class="line">    <span class="comment">// 读一下key，触发get  </span></span><br><span class="line">    vm[key]  </span><br><span class="line">    <span class="comment">// 置空  </span></span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>  </span><br><span class="line">  }  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 未来执行dom更新函数，由dep调用的  </span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) {  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">updaterFn</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>])  </span><br><span class="line">  }  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<p>声明<code>Dep</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> {  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) {  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = [];  <span class="comment">// 依赖管理  </span></span><br><span class="line">  }  </span><br><span class="line">  <span class="title function_">addDep</span>(<span class="params">dep</span>) {  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="title function_">push</span>(dep);  </span><br><span class="line">  }  </span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) {   </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">dep</span>) =&gt;</span> dep.<span class="title function_">update</span>());  </span><br><span class="line">  }  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<p>创建<code>watcher</code>时触发<code>getter</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> {  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm, key, updateFn</span>) {  </span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>];  </span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;  </span><br><span class="line">  }  </span><br><span class="line">}  </span><br><span class="line">  </span><br></pre></td></tr></tbody></table></figure>

<p>依赖收集，创建<code>Dep</code>实例</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) {  </span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">observe</span>(val);  </span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();  </span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, {  </span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) {  </span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span> &amp;&amp; dep.<span class="title function_">addDep</span>(<span class="title class_">Dep</span>.<span class="property">target</span>);<span class="comment">// Dep.target也就是Watcher实例  </span></span><br><span class="line">      <span class="keyword">return</span> val;  </span><br><span class="line">    },  </span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newVal</span>) {  </span><br><span class="line">      <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span>;  </span><br><span class="line">      dep.<span class="title function_">notify</span>(); <span class="comment">// 通知dep执行更新方法  </span></span><br><span class="line">    },  </span><br><span class="line">  });  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1109527162256416">https://www.liaoxuefeng.com/wiki/1022910821149312/1109527162256416</a></li>
<li><a href="https://juejin.cn/post/6844903942254510087#heading-9%E3%80%81">https://juejin.cn/post/6844903942254510087#heading-9、</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>双向绑定</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈this的理解</title>
    <url>/posts/35575.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="面试官：谈谈this对象的理解"><a href="#面试官：谈谈this对象的理解" class="headerlink" title="面试官：谈谈this对象的理解"></a>面试官：谈谈this对象的理解</h1><img src="/posts/35575/35575/46c820d0-74b7-11eb-85f6-6fac77c0c9b3.png" class="" title="img">

<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>函数的 <code>this</code> 关键字在 <code>JavaScript</code> 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别</p>
<p>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值（运行时绑定）</p>
<p><code>this</code> 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象</p>
<span id="more"></span>

<p>举个例子：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置是全局作用域</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">"baz"</span> );</span><br><span class="line">    <span class="title function_">bar</span>(); <span class="comment">// &lt;-- bar的调用位置</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz --&gt; bar</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在baz中</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">"bar"</span> );</span><br><span class="line">    <span class="title function_">foo</span>(); <span class="comment">// &lt;-- foo的调用位置</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz --&gt; bar --&gt; foo</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在bar中</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">"foo"</span> );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">baz</span>(); <span class="comment">// &lt;-- baz的调用位置</span></span><br></pre></td></tr></tbody></table></figure>

<p>同时，<code>this</code>在函数执行过程中，<code>this</code>一旦被确定了，就不可以再更改</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = {</span><br><span class="line">  <span class="attr">a</span>: <span class="number">20</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">this</span> = obj; <span class="comment">// 修改this，运行后会报错</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></tbody></table></figure>

<h2 id="二、绑定规则"><a href="#二、绑定规则" class="headerlink" title="二、绑定规则"></a>二、绑定规则</h2><p>根据不同的使用场合，<code>this</code>有不同的值，主要分为下面几种情况：</p>
<ul>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>new绑定</li>
<li>显示绑定</li>
</ul>
<h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>全局环境中定义<code>person</code>函数，内部使用<code>this</code>关键字</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Jenny'</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">person</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">}</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">person</span>());  <span class="comment">//Jenny</span></span><br></pre></td></tr></tbody></table></figure>

<p>上述代码输出<code>Jenny</code>，原因是调用函数的对象在游览器中位<code>window</code>，因此<code>this</code>指向<code>window</code>，所以输出<code>Jenny</code></p>
<p>注意：</p>
<p>严格模式下，不能将全局对象用于默认绑定，this会绑定到<code>undefined</code>，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象</p>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>函数还可以作为某个对象的方法调用，这时<code>this</code>就指这个上级对象</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = {};</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">m</span> = test;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">m</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，<code>this</code>指向的也只是它上一级的对象</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = {</span><br><span class="line">    <span class="attr">a</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>:{</span><br><span class="line">        <span class="attr">fn</span>:<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">//undefined</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">o.<span class="property">b</span>.<span class="title function_">fn</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码中，<code>this</code>的上一级对象为<code>b</code>，<code>b</code>内部并没有<code>a</code>变量的定义，所以输出<code>undefined</code></p>
<p>这里再举一种特殊情况</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = {</span><br><span class="line">    <span class="attr">a</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>:{</span><br><span class="line">        <span class="attr">a</span>:<span class="number">12</span>,</span><br><span class="line">        <span class="attr">fn</span>:<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">//undefined</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//window</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> j = o.<span class="property">b</span>.<span class="property">fn</span>;</span><br><span class="line"><span class="title function_">j</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>此时<code>this</code>指向的是<code>window</code>，这里的大家需要记住，<code>this</code>永远指向的是最后调用它的对象，虽然<code>fn</code>是对象<code>b</code>的方法，但是<code>fn</code>赋值给<code>j</code>时候并没有执行，所以最终指向<code>window</code></p>
<h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>通过构建函数<code>new</code>关键字生成一个实例对象，此时<code>this</code>指向这个实例对象</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) {</span><br><span class="line">　<span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title function_">test</span>();</span><br><span class="line">obj.<span class="property">x</span> <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure>

<p>上述代码之所以能过输出1，是因为<code>new</code>关键字改变了<code>this</code>的指向</p>
<p>这里再列举一些特殊情况：</p>
<p><code>new</code>过程遇到<code>return</code>一个对象，此时<code>this</code>指向为返回的对象</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)  </span><br><span class="line">{  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">'xxx'</span>;  </span><br><span class="line">    <span class="keyword">return</span> {};  </span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">fn</span>();  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//undefined</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果返回一个简单类型的时候，则<code>this</code>指向实例对象</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)  </span><br><span class="line">{  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">'xxx'</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//xxx</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意的是<code>null</code>虽然也是对象，但是此时<code>new</code>仍然指向实例对象</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)  </span><br><span class="line">{  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">'xxx'</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//xxx</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="显示修改"><a href="#显示修改" class="headerlink" title="显示修改"></a>显示修改</h3><p><code>apply()、call()、bind()</code>是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时<code>this</code>指的就是这第一个参数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) {</span><br><span class="line">　<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = {};</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">m</span> = test;</span><br><span class="line">obj.<span class="property">m</span>.<span class="title function_">apply</span>(obj) <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure>

<p>关于<code>apply、call、bind</code>三者的区别，我们后面再详细说</p>
<h2 id="三、箭头函数"><a href="#三、箭头函数" class="headerlink" title="三、箭头函数"></a>三、箭头函数</h2><p>在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 <code>this</code> 的指向（编译时绑定）</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = {</span><br><span class="line">  <span class="attr">sayThis</span>: <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">sayThis</span>(); <span class="comment">// window 因为 JavaScript 没有块作用域，所以在定义 sayThis 的时候，里面的 this 就绑到 window 上去了</span></span><br><span class="line"><span class="keyword">const</span> globalSay = obj.<span class="property">sayThis</span>;</span><br><span class="line"><span class="title function_">globalSay</span>(); <span class="comment">// window 浏览器中的 global 对象</span></span><br></pre></td></tr></tbody></table></figure>

<p>虽然箭头函数的<code>this</code>能够在编译的时候就确定了<code>this</code>的指向，但也需要注意一些潜在的坑</p>
<p>下面举个例子：</p>
<p>绑定事件监听</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'mngb'</span>);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">'click'</span>, <span class="function">()=&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>) <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">'clicked button'</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>上述可以看到，我们其实是想要<code>this</code>为点击的<code>button</code>，但此时<code>this</code>指向了<code>window</code></p>
<p>包括在原型上添加方法时候，此时<code>this</code>指向<code>window</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>) <span class="comment">//true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">'mm'</span>);</span><br><span class="line">cat.<span class="title function_">sayName</span>()</span><br></pre></td></tr></tbody></table></figure>

<p>同样的，箭头函数不能作为构建函数</p>
<h2 id="四、优先级"><a href="#四、优先级" class="headerlink" title="四、优先级"></a>四、优先级</h2><h3 id="隐式绑定-VS-显式绑定"><a href="#隐式绑定-VS-显式绑定" class="headerlink" title="隐式绑定 VS 显式绑定"></a>隐式绑定 VS 显式绑定</h3><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">a</span> );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = {</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = {</span><br><span class="line">    <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br><span class="line">obj2.<span class="title function_">foo</span>(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>( obj2 ); <span class="comment">// 3</span></span><br><span class="line">obj2.<span class="property">foo</span>.<span class="title function_">call</span>( obj1 ); <span class="comment">// 2</span></span><br></pre></td></tr></tbody></table></figure>

<p>显然，显示绑定的优先级更高</p>
<h3 id="new绑定-VS-隐式绑定"><a href="#new绑定-VS-隐式绑定" class="headerlink" title="new绑定 VS 隐式绑定"></a>new绑定 VS 隐式绑定</h3><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = {</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = {};</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>( <span class="number">2</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>( obj2, <span class="number">3</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj2.<span class="property">a</span> ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.<span class="title function_">foo</span>( <span class="number">4</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( bar.<span class="property">a</span> ); <span class="comment">// 4</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，new绑定的优先级<code>&gt;</code>隐式绑定</p>
<h3 id="new绑定-VS-显式绑定"><a href="#new绑定-VS-显式绑定" class="headerlink" title="new绑定 VS 显式绑定"></a><code>new</code>绑定 VS 显式绑定</h3><p>因为<code>new</code>和<code>apply、call</code>无法一起使用，但硬绑定也是显式绑定的一种，可以替换测试</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = {};</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>( obj1 );</span><br><span class="line"><span class="title function_">bar</span>( <span class="number">2</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="title function_">bar</span>( <span class="number">3</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( baz.<span class="property">a</span> ); <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">bar<span class="string">`被绑定到obj1上，但是`</span><span class="keyword">new</span> <span class="title function_">bar</span>(<span class="number">3</span>)<span class="string">` 并没有像我们预计的那样把`</span>obj1.<span class="property">a</span><span class="string">`修改为3。但是，`</span><span class="keyword">new</span><span class="string">`修改了绑定调用`</span><span class="title function_">bar</span>()<span class="string">`中的`</span><span class="variable language_">this</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们可认为<code>new</code>绑定优先级<code>&gt;</code>显式绑定</p>
<p>综上，new绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this</a></li>
<li>@js语言答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>谈谈this</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈vue修饰符</title>
    <url>/posts/57648.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="Vue常用的修饰符"><a href="#Vue常用的修饰符" class="headerlink" title="Vue常用的修饰符"></a>Vue常用的修饰符</h1><h2 id="面试官：Vue常用的修饰符有哪些有什么应用场景"><a href="#面试官：Vue常用的修饰符有哪些有什么应用场景" class="headerlink" title="面试官：Vue常用的修饰符有哪些有什么应用场景"></a>面试官：Vue常用的修饰符有哪些有什么应用场景</h2><img src="/posts/57648/57648/image-20221028090853302.png" class="" title="image-20221028090853302">

<h3 id="一、修饰符是什么"><a href="#一、修饰符是什么" class="headerlink" title="一、修饰符是什么"></a>一、修饰符是什么</h3><p>在程序世界里，修饰符是用于限定类型以及类型成员的声明的一种符号</p>
<p>在<code>Vue</code>中，修饰符处理了许多<code>DOM</code>事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理</p>
<span id="more"></span>

<p><code>vue</code>中修饰符分为以下五种：</p>
<ul>
<li>表单修饰符</li>
<li>事件修饰符</li>
<li>鼠标按键修饰符</li>
<li>键值修饰符</li>
<li>v-bind修饰符</li>
</ul>
<h3 id="二、修饰符的作用"><a href="#二、修饰符的作用" class="headerlink" title="二、修饰符的作用"></a>二、修饰符的作用</h3><h4 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h4><p>在我们填写表单的时候用得最多的是<code>input</code>标签，指令用得最多的是<code>v-model</code></p>
<p>关于表单的修饰符有如下：</p>
<ul>
<li>lazy</li>
<li>trim</li>
<li>number</li>
</ul>
<h5 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h5><p>在我们填完信息，光标离开标签的时候，才会将值赋予给<code>value</code>，也就是在<code>change</code>事件之后再进行信息同步</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> v-model.<span class="property">lazy</span>=<span class="string">"value"</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>{{value}}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h5><p>自动过滤用户输入的首空格字符，而中间的空格不会过滤</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> v-model.<span class="property">trim</span>=<span class="string">"value"</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="number"><a href="#number" class="headerlink" title="number"></a>number</h5><p>自动将用户的输入值转为数值类型，但如果这个值无法被<code>parseFloat</code>解析，则会返回原来的值</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;input v-model.<span class="property">number</span>=<span class="string">"age"</span> type=<span class="string">"number"</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p>事件修饰符是对事件捕获以及目标进行了处理，有如下修饰符：</p>
<ul>
<li>stop</li>
<li>prevent</li>
<li>self</li>
<li>once</li>
<li>capture</li>
<li>passive</li>
<li>native</li>
</ul>
<h5 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h5><p>阻止了事件冒泡，相当于调用了<code>event.stopPropagation</code>方法</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div @click=<span class="string">"shout(2)"</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">"shout(1)"</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">//只输出1</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="prevent"><a href="#prevent" class="headerlink" title="prevent"></a>prevent</h5><p>阻止了事件的默认行为，相当于调用了<code>event.preventDefault</code>方法</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;form v-<span class="attr">on</span>:submit.<span class="property">prevent</span>=<span class="string">"onSubmit"</span>&gt;&lt;/form&gt;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="self"><a href="#self" class="headerlink" title="self"></a>self</h5><p>只当在 <code>event.target</code> 是当前元素自身时触发处理函数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div v-<span class="attr">on</span>:click.<span class="property">self</span>=<span class="string">"doThat"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击</p>
</blockquote>
<h5 id="once"><a href="#once" class="headerlink" title="once"></a>once</h5><p>绑定了事件以后只能触发一次，第二次就不会触发</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;button @click.<span class="property">once</span>=<span class="string">"shout(1)"</span>&gt;ok&lt;/button&gt;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="capture"><a href="#capture" class="headerlink" title="capture"></a>capture</h5><p>使事件触发从包含这个元素的顶层开始往下触发</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div @click.<span class="property">capture</span>=<span class="string">"shout(1)"</span>&gt;</span><br><span class="line">    obj1</span><br><span class="line">&lt;div @click.<span class="property">capture</span>=<span class="string">"shout(2)"</span>&gt;</span><br><span class="line">    obj2</span><br><span class="line">&lt;div @click=<span class="string">"shout(3)"</span>&gt;</span><br><span class="line">    obj3</span><br><span class="line">&lt;div @click=<span class="string">"shout(4)"</span>&gt;</span><br><span class="line">    obj4</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">// 输出结构: 1 2 4 3 </span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="passive"><a href="#passive" class="headerlink" title="passive"></a>passive</h5><p>在移动端，当我们在监听元素滚动事件的时候，会一直触发<code>onscroll</code>事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给<code>onscroll</code>事件整了一个<code>.lazy</code>修饰符</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class="line">&lt;!-- 而不会等待 <span class="string">`onScroll`</span> 完成  --&gt;</span><br><span class="line">&lt;!-- 这其中包含 <span class="string">`event.preventDefault()`</span> 的情况 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">"onScroll"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用,因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。</p>
<p><code>passive</code> 会告诉浏览器你不想阻止事件的默认行为</p>
</blockquote>
<h5 id="native"><a href="#native" class="headerlink" title="native"></a>native</h5><p>让组件变成像<code>html</code>内置标签那样监听根元素的原生事件，否则组件上使用 <code>v-on</code> 只会监听自定义事件</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;my-component v-<span class="attr">on</span>:click.<span class="property">native</span>=<span class="string">"doSomething"</span>&gt;&lt;/my-component&gt;</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>使用.native修饰符来操作普通HTML标签是会令事件失效的</p>
</blockquote>
<h4 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h4><p>鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下：</p>
<ul>
<li>left 左键点击</li>
<li>right 右键点击</li>
<li>middle 中键点击</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;button @click.<span class="property">left</span>=<span class="string">"shout(1)"</span>&gt;ok&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.right</span>=<span class="string">"shout(1)"</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.middle</span>=<span class="string">"shout(1)"</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="键盘修饰符"><a href="#键盘修饰符" class="headerlink" title="键盘修饰符"></a>键盘修饰符</h4><p>键盘修饰符是用来修饰键盘事件（<code>onkeyup</code>，<code>onkeydown</code>）的，有如下：</p>
<p><code>keyCode</code>存在很多，但<code>vue</code>为我们提供了别名，分为以下两种：</p>
<ul>
<li>普通键（enter、tab、delete、space、esc、up…）</li>
<li>系统修饰键（ctrl、alt、meta、shift…）</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 只有按键为keyCode的时候才触发</span></span><br><span class="line">&lt;input type=<span class="string">"text"</span> @keyup.<span class="property">keyCode</span>=<span class="string">"shout()"</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>还可以通过以下方式自定义一些全局的键盘码别名</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">keyCodes</span>.<span class="property">f2</span> = <span class="number">113</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="v-bind修饰符"><a href="#v-bind修饰符" class="headerlink" title="v-bind修饰符"></a>v-bind修饰符</h5><p>v-bind修饰符主要是为属性进行操作，用来分别有如下：</p>
<ul>
<li>async</li>
<li>prop</li>
<li>camel</li>
</ul>
<h5 id="async"><a href="#async" class="headerlink" title="async"></a>async</h5><p>能对<code>props</code>进行一个双向绑定</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;comp :myMessage.<span class="property">sync</span>=<span class="string">"bar"</span>&gt;&lt;/comp&gt; </span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">'update:myMessage'</span>,params);</span><br></pre></td></tr></tbody></table></figure>

<p>以上这种方法相当于以下的简写</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//父亲组件</span></span><br><span class="line">&lt;comp :myMessage=<span class="string">"bar"</span> @<span class="attr">update</span>:myMessage=<span class="string">"func"</span>&gt;&lt;/comp&gt;</span><br><span class="line"><span class="title function_">func</span>(<span class="params">e</span>){</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">bar</span> = e;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//子组件js</span></span><br><span class="line"><span class="title function_">func2</span>(<span class="params"></span>){</span><br><span class="line">  <span class="variable language_">this</span>.$emit(<span class="string">'update:myMessage'</span>,params);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用<code>async</code>需要注意以下两点：</p>
<ul>
<li>使用<code>sync</code>的时候，子组件传递的事件名格式必须为<code>update:value</code>，其中<code>value</code>必须与子组件中<code>props</code>中声明的名称完全一致</li>
<li>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> 不能和表达式一起使用</li>
<li>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”{ title: doc.title }”</code>，是无法正常工作的</li>
</ul>
<h5 id="props"><a href="#props" class="headerlink" title="props"></a>props</h5><p>设置自定义标签属性，避免暴露数据，防止污染HTML结构</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;input id=<span class="string">"uid"</span> title=<span class="string">"title1"</span> value=<span class="string">"1"</span> :index.<span class="property">prop</span>=<span class="string">"index"</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="camel"><a href="#camel" class="headerlink" title="camel"></a>camel</h5><p>将命名变为驼峰命名法，如将<code>view-Box</code>属性名转换为 <code>viewBox</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;svg :viewBox=<span class="string">"viewBox"</span>&gt;&lt;/svg&gt;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h3><p>根据每一个修饰符的功能，我们可以得到以下修饰符的应用场景：</p>
<ul>
<li>.stop：阻止事件冒泡</li>
<li>.native：绑定原生事件</li>
<li>.once：事件只执行一次</li>
<li>.self ：将事件绑定在自身身上，相当于阻止事件冒泡</li>
<li>.prevent：阻止默认事件</li>
<li>.caption：用于事件捕获</li>
<li>.once：只触发一次</li>
<li>.keyCode：监听特定键盘按下</li>
<li>.right：右键</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://segmentfault.com/a/1190000016786254">https://segmentfault.com/a/1190000016786254</a></li>
<li><a href="https://vue3js.cn/docs/zh%E3%80%81">https://vue3js.cn/docs/zh、</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈vue过滤器</title>
    <url>/posts/31303.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="vue过滤器"><a href="#vue过滤器" class="headerlink" title="vue过滤器"></a>vue过滤器</h1><h2 id="面试官：Vue中的过滤器了解吗？过滤器的应用场景有哪些？"><a href="#面试官：Vue中的过滤器了解吗？过滤器的应用场景有哪些？" class="headerlink" title="面试官：Vue中的过滤器了解吗？过滤器的应用场景有哪些？"></a>面试官：Vue中的过滤器了解吗？过滤器的应用场景有哪些？</h2><img src="/posts/31303/31303/image-20221031071227577.png" class="" title="image-20221031071227577">

<h3 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h3><p>过滤器（<code>filter</code>）是输送介质管道上不可缺少的一种装置</p>
<p>大白话，就是把一些不必要的东西过滤掉</p>
<span id="more"></span>

<p>过滤器实质不改变原始数据，只是对数据进行加工处理后返回过滤后的数据再进行调用处理，我们也可以理解其为一个纯函数</p>
<p><code>Vue</code> 允许你自定义过滤器，可被用于一些常见的文本格式化</p>
<p>ps: <code>Vue3</code>中已废弃<code>filter</code></p>
<h3 id="二、如何用"><a href="#二、如何用" class="headerlink" title="二、如何用"></a>二、如何用</h3><p><code>vue</code>中的过滤器可以用在两个地方：双花括号插值和 <code>v-bind</code> 表达式，过滤器应该被添加在 <code>JavaScript</code>表达式的尾部，由“管道”符号指示：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!-- 在双花括号中 --&gt;</span><br><span class="line">{{ message | capitalize }}</span><br><span class="line"></span><br><span class="line">&lt;!-- 在 <span class="string">`v-bind`</span> 中 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"rawId | formatId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="定义filter"><a href="#定义filter" class="headerlink" title="定义filter"></a>定义filter</h4><p>在组件的选项中定义本地的过滤器</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">filters</span>: {</span><br><span class="line">  <span class="attr">capitalize</span>: <span class="keyword">function</span> (<span class="params">value</span>) {</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    value = value.<span class="title function_">toString</span>()</span><br><span class="line">    <span class="keyword">return</span> value.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + value.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义全局过滤器：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">'capitalize'</span>, <span class="keyword">function</span> (<span class="params">value</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">  value = value.<span class="title function_">toString</span>()</span><br><span class="line">  <span class="keyword">return</span> value.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + value.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>({</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>注意：当全局过滤器和局部过滤器重名时，会采用局部过滤器</p>
<p>过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，<code>capitalize</code> 过滤器函数将会收到 <code>message</code> 的值作为第一个参数</p>
<p>过滤器可以串联：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">{{ message | filterA | filterB }}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，<code>filterA</code> 被定义为接收单个参数的过滤器函数，表达式 <code>message</code> 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 <code>filterB</code>，将 <code>filterA</code> 的结果传递到 <code>filterB</code> 中。</p>
<p>过滤器是 <code>JavaScript</code>函数，因此可以接收参数：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">{{ message | filterA('arg1', arg2) }}</span><br></pre></td></tr></tbody></table></figure>

<p>这里，<code>filterA</code> 被定义为接收三个参数的过滤器函数。</p>
<p>其中 <code>message</code> 的值作为第一个参数，普通字符串 <code>'arg1'</code> 作为第二个参数，表达式 <code>arg2</code> 的值作为第三个参数</p>
<p>举个例子：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>{{ msg | msgFormat('疯狂','--')}}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 定义一个 Vue 全局的过滤器，名字叫做  msgFormat</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">'msgFormat'</span>, <span class="keyword">function</span>(<span class="params">msg, arg, arg2</span>) {</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 字符串的  replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> msg.<span class="title function_">replace</span>(<span class="regexp">/单纯/g</span>, arg+arg2)</span></span><br><span class="line"><span class="language-javascript">    })</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul>
<li>部过滤器优先于全局过滤器被调用</li>
<li>一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右</li>
</ul>
<h3 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h3><p>平时开发中，需要用到过滤器的地方有很多，比如单位转换、数字打点、文本格式化、时间格式化之类的等</p>
<p>比如我们要实现将30000 =&gt; 30,000，这时候我们就需要使用过滤器</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">'toThousandFilter'</span>, <span class="keyword">function</span> (<span class="params">value</span>) {</span><br><span class="line">     <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">     value = value.<span class="title function_">toString</span>()</span><br><span class="line">     <span class="keyword">return</span> .<span class="title function_">replace</span>(str.<span class="title function_">indexOf</span>(<span class="string">'.'</span>) &gt; -<span class="number">1</span> ? <span class="regexp">/(\d)(?=(\d{3})+\.)/g</span> : <span class="regexp">/(\d)(?=(?:\d{3})+$)/g</span>, <span class="string">'$1,'</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<h3 id="四、原理分析"><a href="#四、原理分析" class="headerlink" title="四、原理分析"></a>四、原理分析</h3><p>使用过滤器</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{{ message | capitalize }}</span><br></pre></td></tr></tbody></table></figure>

<p>在模板编译阶段过滤器表达式将会被编译为过滤器函数，主要是用过<code>parseFilters</code>，我们放到最后讲</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">_s</span>(<span class="title function_">_f</span>(<span class="string">'filterFormat'</span>)(message))</span><br></pre></td></tr></tbody></table></figure>

<p>首先分析一下<code>_f</code>：</p>
<p>_f 函数全名是：<code>resolveFilter</code>，这个函数的作用是从<code>this.$options.filters</code>中找出注册的过滤器并返回</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 变为</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">filters</span>[<span class="string">'filterFormat'</span>](message) <span class="comment">// message为参数</span></span><br></pre></td></tr></tbody></table></figure>

<p>关于<code>resolveFilter</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { indentity,resolveAsset } <span class="keyword">from</span> <span class="string">'core/util/index'</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resolveFilter</span>(<span class="params">id</span>){</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">resolveAsset</span>(<span class="variable language_">this</span>.<span class="property">$options</span>,<span class="string">'filters'</span>,id,<span class="literal">true</span>) || identity</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>内部直接调用<code>resolveAsset</code>，将<code>option</code>对象，类型，过滤器<code>id</code>，以及一个触发警告的标志作为参数传递，如果找到，则返回过滤器；</p>
<p><code>resolveAsset</code>的代码如下：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resolveAsset</span>(<span class="params">options,type,id,warnMissing</span>){ <span class="comment">// 因为我们找的是过滤器，所以在 resolveFilter函数中调用时 type 的值直接给的 'filters',实际这个函数还可以拿到其他很多东西</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> id !== <span class="string">'string'</span>){ <span class="comment">// 判断传递的过滤器id 是不是字符串，不是则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">const</span> assets = options[type]  <span class="comment">// 将我们注册的所有过滤器保存在变量中</span></span><br><span class="line">    <span class="comment">// 接下来的逻辑便是判断id是否在assets中存在，即进行匹配</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">hasOwn</span>(assets,id)) <span class="keyword">return</span> assets[id] <span class="comment">// 如找到，直接返回过滤器</span></span><br><span class="line">    <span class="comment">// 没有找到，代码继续执行</span></span><br><span class="line">    <span class="keyword">const</span> camelizedId  = <span class="title function_">camelize</span>(id) <span class="comment">// 万一你是驼峰的呢</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">hasOwn</span>(assets,camelizedId)) <span class="keyword">return</span> assets[camelizedId]</span><br><span class="line">    <span class="comment">// 没找到，继续执行</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">PascalCaseId</span> = <span class="title function_">capitalize</span>(camelizedId) <span class="comment">// 万一你是首字母大写的驼峰呢</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">hasOwn</span>(assets,<span class="title class_">PascalCaseId</span>)) <span class="keyword">return</span> assets[<span class="title class_">PascalCaseId</span>]</span><br><span class="line">    <span class="comment">// 如果还是没找到，则检查原型链(即访问属性)</span></span><br><span class="line">    <span class="keyword">const</span> result = assets[id] || assets[camelizedId] || assets[<span class="title class_">PascalCaseId</span>]</span><br><span class="line">    <span class="comment">// 如果依然没找到，则在非生产环境的控制台打印警告</span></span><br><span class="line">    <span class="keyword">if</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp; warnMissing &amp;&amp; !result){</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">'Failed to resolve '</span> + type.<span class="title function_">slice</span>(<span class="number">0</span>,-<span class="number">1</span>) + <span class="string">': '</span> + id, options)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 无论是否找到，都返回查找结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下面再来分析一下<code>_s</code>：</p>
<p><code>_s</code> 函数的全称是 <code>toString</code>,过滤器处理后的结果会当作参数传递给 <code>toString</code>函数，最终 <code>toString</code>函数执行后的结果会保存到<code>Vnode</code>中的text属性中，渲染到视图中</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">value</span>){</span><br><span class="line">    <span class="keyword">return</span> value == <span class="literal">null</span></span><br><span class="line">    ? <span class="string">''</span></span><br><span class="line">    : <span class="keyword">typeof</span> value === <span class="string">'object'</span></span><br><span class="line">      ? <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value,<span class="literal">null</span>,<span class="number">2</span>)<span class="comment">// JSON.stringify()第三个参数可用来控制字符串里面的间距</span></span><br><span class="line">      : <span class="title class_">String</span>(value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，在分析下<code>parseFilters</code>，在模板编译阶段使用该函数阶段将模板过滤器解析为过滤器函数调用表达式</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseFilters</span> (filter) {</span><br><span class="line">    <span class="keyword">let</span> filters = filter.<span class="title function_">split</span>(<span class="string">'|'</span>)</span><br><span class="line">    <span class="keyword">let</span> expression = filters.<span class="title function_">shift</span>().<span class="title function_">trim</span>() <span class="comment">// shift()删除数组第一个元素并将其返回，该方法会更改原数组</span></span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">if</span> (filters) {</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; filters.<span class="property">length</span>;i++){</span><br><span class="line">            experssion = <span class="title function_">warpFilter</span>(expression,filters[i].<span class="title function_">trim</span>()) <span class="comment">// 这里传进去的expression实际上是管道符号前面的字符串，即过滤器的第一个参数</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> expression</span><br><span class="line">}</span><br><span class="line"><span class="comment">// warpFilter函数实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">warpFilter</span>(<span class="params">exp,filter</span>){</span><br><span class="line">    <span class="comment">// 首先判断过滤器是否有其他参数</span></span><br><span class="line">    <span class="keyword">const</span> i = filter.<span class="title function_">indexof</span>(<span class="string">'('</span>)</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>){ <span class="comment">// 不含其他参数，直接进行过滤器表达式字符串的拼接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`_f("<span class="subst">${filter}</span>")(<span class="subst">${exp}</span>)`</span></span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">const</span> name = filter.<span class="title function_">slice</span>(<span class="number">0</span>,i) <span class="comment">// 过滤器名称</span></span><br><span class="line">        <span class="keyword">const</span> args = filter.<span class="title function_">slice</span>(i+<span class="number">1</span>) <span class="comment">// 参数，但还多了 ‘)’</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`_f('<span class="subst">${name}</span>')(<span class="subst">${exp}</span>,<span class="subst">${args}</span>`</span> <span class="comment">// 注意这一步少给了一个 ')'</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h4><ul>
<li>在编译阶段通过<code>parseFilters</code>将过滤器编译成函数调用（串联过滤器则是一个嵌套的函数调用，前一个过滤器执行的结果是后一个过滤器函数的参数）</li>
<li>编译后通过调用<code>resolveFilter</code>函数找到对应过滤器并返回结果</li>
<li>执行结果作为参数传递给<code>toString</code>函数，而<code>toString</code>执行后，其结果会保存在<code>Vnode</code>的<code>text</code>属性中，渲染到视图</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://cn.vuejs.org/v2/guide/filters.html#ad">https://cn.vuejs.org/v2/guide/filters.html#ad</a></li>
<li><a href="https://blog.csdn.net/weixin_42724176/article/details/105546684">https://blog.csdn.net/weixin_42724176/article/details/105546684</a></li>
<li><a href="https://vue3js.cn/">https://vue3js.cn</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>vue过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈你对axios封装的理解</title>
    <url>/posts/5373.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="谈谈你对axios封装的理解"><a href="#谈谈你对axios封装的理解" class="headerlink" title="谈谈你对axios封装的理解"></a>谈谈你对axios封装的理解</h1><h2 id="面试官：Vue项目中有封装过axios吗？主要是封装哪方面的？"><a href="#面试官：Vue项目中有封装过axios吗？主要是封装哪方面的？" class="headerlink" title="面试官：Vue项目中有封装过axios吗？主要是封装哪方面的？"></a>面试官：Vue项目中有封装过axios吗？主要是封装哪方面的？</h2><img src="/posts/5373/5373/image-20221103055626680.png" class="" title="image-20221103055626680">

<h3 id="一、axios是什么"><a href="#一、axios是什么" class="headerlink" title="一、axios是什么"></a>一、axios是什么</h3><p><code>axios</code> 是一个轻量的 <code>HTTP</code>客户端</p>
<p>基于 <code>XMLHttpRequest</code> 服务来执行 <code>HTTP</code> 请求，支持丰富的配置，支持 <code>Promise</code>，支持浏览器端和 <code>Node.js</code> 端。自<code>Vue</code>2.0起，尤大宣布取消对 <code>vue-resource</code> 的官方推荐，转而推荐 <code>axios</code>。现在 <code>axios</code> 已经成为大部分 <code>Vue</code> 开发者的首选</p>
<span id="more"></span>

<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>从浏览器中创建 <code>XMLHttpRequests</code></li>
<li>从 <code>node.js</code> 创建 <code>http</code>请求</li>
<li>支持 <code>Promise</code> API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换<code>JSON</code> 数据</li>
<li>客户端支持防御<code>XSRF</code></li>
</ul>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>安装</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 项目中安装</span></span><br><span class="line">npm install axios --S</span><br><span class="line"><span class="comment">// cdn 引入</span></span><br><span class="line">&lt;script src=<span class="string">"https://unpkg.com/axios/dist/axios.min.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>导入</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br></pre></td></tr></tbody></table></figure>

<p>发送请求</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>({        </span><br><span class="line">  <span class="attr">url</span>:<span class="string">'xxx'</span>,    <span class="comment">// 设置请求的地址</span></span><br><span class="line">  <span class="attr">method</span>:<span class="string">"GET"</span>, <span class="comment">// 设置请求方法</span></span><br><span class="line">  <span class="attr">params</span>:{      <span class="comment">// get请求使用params进行参数凭借,如果是post请求用data</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">''</span>,</span><br><span class="line">    <span class="attr">page</span>: <span class="number">1</span></span><br><span class="line">  }</span><br><span class="line">}).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> {  </span><br><span class="line">  <span class="comment">// res为后端返回的数据</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);   </span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>并发请求<code>axios.all([])</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUserAccount</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">'/user/12345'</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUserPermissions</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">'/user/12345/permissions'</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">all</span>([<span class="title function_">getUserAccount</span>(), <span class="title function_">getUserPermissions</span>()])</span><br><span class="line">    .<span class="title function_">then</span>(axios.<span class="title function_">spread</span>(<span class="keyword">function</span> (<span class="params">res1, res2</span>) { </span><br><span class="line">    <span class="comment">// res1第一个请求的返回的内容，res2第二个请求返回的内容</span></span><br><span class="line">    <span class="comment">// 两个请求都执行完成才会执行</span></span><br><span class="line">}));</span><br></pre></td></tr></tbody></table></figure>

<h3 id="二、为什么要封装"><a href="#二、为什么要封装" class="headerlink" title="二、为什么要封装"></a>二、为什么要封装</h3><p><code>axios</code> 的 API 很友好，你完全可以很轻松地在项目中直接使用。</p>
<p>不过随着项目规模增大，如果每发起一次<code>HTTP</code>请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都需要写一遍</p>
<p>这种重复劳动不仅浪费时间，而且让代码变得冗余不堪，难以维护。为了提高我们的代码质量，我们应该在项目中二次封装一下 <code>axios</code> 再使用</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(<span class="string">'http://localhost:3000/data'</span>, {</span><br><span class="line">  <span class="comment">// 配置代码</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">'GET'</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">headers</span>: {</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">    <span class="title class_">Authorization</span>: <span class="string">'xxx'</span>,</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">transformRequest</span>: [<span class="keyword">function</span> (<span class="params">data, headers</span>) {</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  }],</span><br><span class="line">  <span class="comment">// 其他请求配置...</span></span><br><span class="line">})</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// todo: 真正业务逻辑代码</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">}, <span class="function">(<span class="params">err</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 错误处理代码  </span></span><br><span class="line">  <span class="keyword">if</span> (err.<span class="property">response</span>.<span class="property">status</span> === <span class="number">401</span>) {</span><br><span class="line">  <span class="comment">// handle authorization error</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (err.<span class="property">response</span>.<span class="property">status</span> === <span class="number">403</span>) {</span><br><span class="line">  <span class="comment">// handle server forbidden error</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 其他错误处理.....</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>如果每个页面都发送类似的请求，都要写一堆的配置与错误处理，就显得过于繁琐了</p>
<p>这时候我们就需要对<code>axios</code>进行二次封装，让使用更为便利</p>
<h3 id="三、如何封装"><a href="#三、如何封装" class="headerlink" title="三、如何封装"></a>三、如何封装</h3><p>封装的同时，你需要和 后端协商好一些约定，请求头，状态码，请求超时时间…….</p>
<p>设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分</p>
<p>请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)</p>
<p>状态码: 根据接口返回的不同<code>status</code> ， 来执行不同的业务，这块需要和后端约定好</p>
<p>请求方法：根据<code>get</code>、<code>post</code>等方法进行一个再次封装，使用起来更为方便</p>
<p>请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问</p>
<p>响应拦截器： 这块就是根据 后端`返回来的状态码判定执行不同业务</p>
<h4 id="设置接口请求前缀"><a href="#设置接口请求前缀" class="headerlink" title="设置接口请求前缀"></a>设置接口请求前缀</h4><p>利用<code>node</code>环境变量来作判断，用来区分开发、测试、生产环境</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">'development'</span>) {</span><br><span class="line">  axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">'http://dev.xxx.com'</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">'production'</span>) {</span><br><span class="line">  axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">'http://prod.xxx.com'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在本地调试的时候，还需要在<code>vue.config.js</code>文件中配置<code>devServer</code>实现代理转发，从而实现跨域</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: {</span><br><span class="line">    <span class="attr">proxy</span>: {</span><br><span class="line">      <span class="string">'/proxyApi'</span>: {</span><br><span class="line">        <span class="attr">target</span>: <span class="string">'http://dev.xxx.com'</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: {</span><br><span class="line">          <span class="string">'/proxyApi'</span>: <span class="string">''</span></span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="设置请求头与超时时间"><a href="#设置请求头与超时时间" class="headerlink" title="设置请求头与超时时间"></a>设置请求头与超时时间</h4><p>大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，这里将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> service = axios.<span class="title function_">create</span>({</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">30000</span>,  <span class="comment">// 请求 30s 超时</span></span><br><span class="line">	  <span class="attr">headers</span>: {</span><br><span class="line">        <span class="attr">get</span>: {</span><br><span class="line">          <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded;charset=utf-8'</span></span><br><span class="line">          <span class="comment">// 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来</span></span><br><span class="line">        },</span><br><span class="line">        <span class="attr">post</span>: {</span><br><span class="line">          <span class="string">'Content-Type'</span>: <span class="string">'application/json;charset=utf-8'</span></span><br><span class="line">          <span class="comment">// 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来</span></span><br><span class="line">        }</span><br><span class="line">  },</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<h4 id="封装请求方法"><a href="#封装请求方法" class="headerlink" title="封装请求方法"></a>封装请求方法</h4><p>先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// get 请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">httpGet</span>(<span class="params">{</span></span><br><span class="line"><span class="params">  url,</span></span><br><span class="line"><span class="params">  params = {}</span></span><br><span class="line"><span class="params">}</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    axios.<span class="title function_">get</span>(url, {</span><br><span class="line">      params</span><br><span class="line">    }).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">      <span class="title function_">resolve</span>(res.<span class="property">data</span>)</span><br><span class="line">    }).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> {</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    })</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// post</span></span><br><span class="line"><span class="comment">// post请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">httpPost</span>(<span class="params">{</span></span><br><span class="line"><span class="params">  url,</span></span><br><span class="line"><span class="params">  data = {},</span></span><br><span class="line"><span class="params">  params = {}</span></span><br><span class="line"><span class="params">}</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    <span class="title function_">axios</span>({</span><br><span class="line">      url,</span><br><span class="line">      <span class="attr">method</span>: <span class="string">'post'</span>,</span><br><span class="line">      <span class="attr">transformRequest</span>: [<span class="keyword">function</span> (<span class="params">data</span>) {</span><br><span class="line">        <span class="keyword">let</span> ret = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> it <span class="keyword">in</span> data) {</span><br><span class="line">          ret += <span class="built_in">encodeURIComponent</span>(it) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(data[it]) + <span class="string">'&amp;'</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">      }],</span><br><span class="line">      <span class="comment">// 发送的数据</span></span><br><span class="line">      data,</span><br><span class="line">      <span class="comment">// url参数</span></span><br><span class="line">      params</span><br><span class="line"></span><br><span class="line">    }).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> {</span><br><span class="line">      <span class="title function_">resolve</span>(res.<span class="property">data</span>)</span><br><span class="line">    })</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>把封装的方法放在一个<code>api.js</code>文件中</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> { httpGet, httpPost } <span class="keyword">from</span> <span class="string">'./http'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getorglist</span> = (<span class="params">params = {}</span>) =&gt; <span class="title function_">httpGet</span>({ <span class="attr">url</span>: <span class="string">'apps/api/org/list'</span>, params })</span><br></pre></td></tr></tbody></table></figure>

<p>页面中就能直接调用</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// .vue</span></span><br><span class="line"><span class="keyword">import</span> { getorglist } <span class="keyword">from</span> <span class="string">'@/assets/js/api'</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">getorglist</span>({ <span class="attr">id</span>: <span class="number">200</span> }).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>这样可以把<code>api</code>统一管理起来，以后维护修改只需要在<code>api.js</code>文件操作即可</p>
<h4 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h4><p>请求拦截器可以在每个请求里加上token，做了统一处理后维护起来也方便</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> {</span><br><span class="line">    <span class="comment">// 每次发送请求之前判断是否存在token</span></span><br><span class="line">    <span class="comment">// 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的</span></span><br><span class="line">    token &amp;&amp; (config.<span class="property">headers</span>.<span class="property">Authorization</span> = token)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  },</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">error</span>(error)</span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> {</span><br><span class="line">    <span class="comment">// 每次发送请求之前判断是否存在token</span></span><br><span class="line">    <span class="comment">// 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的</span></span><br><span class="line">    token &amp;&amp; (config.<span class="property">headers</span>.<span class="property">Authorization</span> = token)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  },</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">error</span>(error)</span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">response</span> =&gt;</span> {</span><br><span class="line">  <span class="comment">// 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据</span></span><br><span class="line">  <span class="comment">// 否则的话抛出错误</span></span><br><span class="line">  <span class="keyword">if</span> (response.<span class="property">status</span> === <span class="number">200</span>) {</span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">511</span>) {</span><br><span class="line">      <span class="comment">// 未授权调取授权接口</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">510</span>) {</span><br><span class="line">      <span class="comment">// 未登录跳转登录页</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(response)</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(response)</span><br><span class="line">  }</span><br><span class="line">}, <span class="function"><span class="params">error</span> =&gt;</span> {</span><br><span class="line">  <span class="comment">// 我们可以在这里对异常状态作统一处理</span></span><br><span class="line">  <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">status</span>) {</span><br><span class="line">    <span class="comment">// 处理请求失败的情况</span></span><br><span class="line">    <span class="comment">// 对不同返回码对相应处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error.<span class="property">response</span>)</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>封装是编程中很有意义的手段，简单的<code>axios</code>封装，就可以让我们可以领略到它的魅力</li>
<li>封装 <code>axios</code> 没有一个绝对的标准，只要你的封装可以满足你的项目需求，并且用起来方便，那就是一个好的封装方案</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://www.html.cn/qa/vue-js/20544.html">https://www.html.cn/qa/vue-js/20544.html</a></li>
<li><a href="https://juejin.cn/post/6844904033782611976">https://juejin.cn/post/6844904033782611976</a></li>
<li><a href="https://juejin.cn/post/6844903801451708429">https://juejin.cn/post/6844903801451708429</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>对axios封装的理解</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈虚拟dom</title>
    <url>/posts/37478.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="谈谈虚拟dom"><a href="#谈谈虚拟dom" class="headerlink" title="谈谈虚拟dom"></a>谈谈虚拟dom</h1><h2 id="面试官：什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路"><a href="#面试官：什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路" class="headerlink" title="面试官：什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路"></a>面试官：什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路</h2><img src="/posts/37478/37478/image-20221101055808458.png" class="" title="image-20221101055808458">

<h3 id="一、什么是虚拟DOM"><a href="#一、什么是虚拟DOM" class="headerlink" title="一、什么是虚拟DOM"></a>一、什么是虚拟DOM</h3><p>虚拟 DOM （<code>Virtual DOM</code> ）这个概念相信大家都不陌生，从 <code>React</code> 到 <code>Vue</code> ，虚拟 <code>DOM</code> 为这两个框架都带来了跨平台的能力（<code>React-Native</code> 和 <code>Weex</code>）</p>
<span id="more"></span>

<p>实际上它只是一层对真实<code>DOM</code>的抽象，以<code>JavaScript</code> 对象 (<code>VNode</code> 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上</p>
<p>在<code>Javascript</code>对象中，虚拟<code>DOM</code> 表现为一个 <code>Object</code>对象。并且最少包含标签名 (<code>tag</code>)、属性 (<code>attrs</code>) 和子元素对象 (<code>children</code>) 三个属性，不同框架对这三个属性的名命可能会有差别</p>
<p>创建虚拟<code>DOM</code>就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟<code>DOM</code>对象的节点与真实<code>DOM</code>的属性一一照应</p>
<p>在<code>vue</code>中同样使用到了虚拟<code>DOM</code>技术</p>
<p>定义真实<code>DOM</code></p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"p"</span>&gt;</span>节点内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>{{ foo }}<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>实例化<code>vue</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>({</span><br><span class="line">    <span class="attr">el</span>:<span class="string">"#app"</span>,</span><br><span class="line">    <span class="attr">data</span>:{</span><br><span class="line">        <span class="attr">foo</span>:<span class="string">"foo"</span></span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>观察<code>render</code>的<code>render</code>，我们能得到虚拟<code>DOM</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">anonymous</span>(<span class="params"></span></span><br><span class="line"><span class="params"></span>) {</span><br><span class="line">	<span class="title function_">with</span>(<span class="params"><span class="variable language_">this</span></span>){<span class="keyword">return</span> <span class="title function_">_c</span>(<span class="string">'div'</span>,{<span class="attr">attrs</span>:{<span class="string">"id"</span>:<span class="string">"app"</span>}},[<span class="title function_">_c</span>(<span class="string">'p'</span>,{<span class="attr">staticClass</span>:<span class="string">"p"</span>},</span><br><span class="line">					  [<span class="title function_">_v</span>(<span class="string">"节点内容"</span>)]),<span class="title function_">_v</span>(<span class="string">" "</span>),<span class="title function_">_c</span>(<span class="string">'h3'</span>,[<span class="title function_">_v</span>(<span class="title function_">_s</span>(foo))])])}})</span><br></pre></td></tr></tbody></table></figure>

<p>通过<code>VNode</code>，<code>vue</code>可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过<code>diff</code>算法得出一些需要修改的最小单位,再更新视图，减少了<code>dom</code>操作，提高了性能</p>
<h3 id="二、为什么需要虚拟DOM"><a href="#二、为什么需要虚拟DOM" class="headerlink" title="二、为什么需要虚拟DOM"></a>二、为什么需要虚拟DOM</h3><p><code>DOM</code>是很慢的，其元素非常庞大，页面的性能问题，大部分都是由<code>DOM</code>操作引起的</p>
<p>真实的<code>DOM</code>节点，哪怕一个最简单的<code>div</code>也包含着很多属性，可以打印出来直观感受一下：</p>
<img src="/posts/37478/37478/image-20221101055932532.png" class="" title="image-20221101055932532">

<p>由此可见，操作<code>DOM</code>的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验</p>
<p><strong>举个例子：</strong></p>
<p>你用传统的原生<code>api</code>或<code>jQuery</code>去操作<code>DOM</code>时，浏览器会从构建<code>DOM</code>树开始从头到尾执行一遍流程</p>
<p>当你在一次操作时，需要更新10个<code>DOM</code>节点，浏览器没这么智能，收到第一个更新<code>DOM</code>请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程</p>
<p>而通过<code>VNode</code>，同样更新10个<code>DOM</code>节点，虚拟<code>DOM</code>不会立即操作<code>DOM</code>，而是将这10次更新的<code>diff</code>内容保存到本地的一个<code>js</code>对象中，最终将这个<code>js</code>对象一次性<code>attach</code>到<code>DOM</code>树上，避免大量的无谓计算</p>
<blockquote>
<p>很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI</p>
</blockquote>
<h3 id="三、如何实现虚拟DOM"><a href="#三、如何实现虚拟DOM" class="headerlink" title="三、如何实现虚拟DOM"></a>三、如何实现虚拟DOM</h3><p>首先可以看看<code>vue</code>中<code>VNode</code>的结构</p>
<p>源码位置：src/core/vdom/vnode.js</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VNode</span> {</span><br><span class="line">  <span class="attr">tag</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">data</span>: <span class="title class_">VNodeData</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">children</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;;</span><br><span class="line">  <span class="attr">text</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">elm</span>: <span class="title class_">Node</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">ns</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span> | <span class="keyword">void</span>; <span class="comment">// rendered in this component's scope</span></span><br><span class="line">  <span class="attr">functionalContext</span>: <span class="title class_">Component</span> | <span class="keyword">void</span>; <span class="comment">// only for functional component root nodes</span></span><br><span class="line">  <span class="attr">key</span>: string | number | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">componentOptions</span>: <span class="title class_">VNodeComponentOptions</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">componentInstance</span>: <span class="title class_">Component</span> | <span class="keyword">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">VNode</span> | <span class="keyword">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line">  <span class="attr">raw</span>: boolean; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  <span class="attr">isStatic</span>: boolean; <span class="comment">// hoisted static node</span></span><br><span class="line">  <span class="attr">isRootInsert</span>: boolean; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  <span class="attr">isComment</span>: boolean; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  <span class="attr">isCloned</span>: boolean; <span class="comment">// is a cloned node?</span></span><br><span class="line">  <span class="attr">isOnce</span>: boolean; <span class="comment">// is a v-once node?</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: <span class="title class_">VNodeData</span>,</span><br><span class="line">    children?: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: <span class="title class_">Node</span>,</span><br><span class="line">    context?: <span class="title class_">Component</span>,</span><br><span class="line">    componentOptions?: <span class="title class_">VNodeComponentOptions</span></span><br><span class="line">  ) {</span><br><span class="line">    <span class="comment">/*当前节点的标签名*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tag</span> = tag</span><br><span class="line">    <span class="comment">/*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = data</span><br><span class="line">    <span class="comment">/*当前节点的子节点，是一个数组*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span> = children</span><br><span class="line">    <span class="comment">/*当前节点的文本*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">text</span> = text</span><br><span class="line">    <span class="comment">/*当前虚拟节点对应的真实dom节点*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">elm</span> = elm</span><br><span class="line">    <span class="comment">/*当前节点的名字空间*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ns</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">/*编译作用域*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span> = context</span><br><span class="line">    <span class="comment">/*函数化组件作用域*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">functionalContext</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">/*节点的key属性，被当作节点的标志，用以优化*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = data &amp;&amp; data.<span class="property">key</span></span><br><span class="line">    <span class="comment">/*组件的option选项*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">componentOptions</span> = componentOptions</span><br><span class="line">    <span class="comment">/*当前节点对应的组件的实例*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">componentInstance</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">/*当前节点的父节点*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">/*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">raw</span> = <span class="literal">false</span></span><br><span class="line">    <span class="comment">/*静态节点标志*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isStatic</span> = <span class="literal">false</span></span><br><span class="line">    <span class="comment">/*是否作为跟节点插入*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isRootInsert</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">/*是否为注释节点*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isComment</span> = <span class="literal">false</span></span><br><span class="line">    <span class="comment">/*是否为克隆节点*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isCloned</span> = <span class="literal">false</span></span><br><span class="line">    <span class="comment">/*是否有v-once指令*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isOnce</span> = <span class="literal">false</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DEPRECATED: alias for componentInstance for backwards compat.</span></span><br><span class="line">  <span class="comment">/* istanbul ignore next https://github.com/answershuto/learnVue*/</span></span><br><span class="line">  get child (): <span class="title class_">Component</span> | <span class="keyword">void</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">componentInstance</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里对<code>VNode</code>进行稍微的说明：</p>
<ul>
<li>所有对象的 <code>context</code> 选项都指向了 <code>Vue</code> 实例</li>
<li><code>elm</code> 属性则指向了其相对应的真实 <code>DOM</code> 节点</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">vue`是通过`createElement`生成`VNode</span><br></pre></td></tr></tbody></table></figure>

<p>源码位置：src/core/vdom/create-element.js</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span> (</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">tag</span>: any,</span><br><span class="line">  <span class="attr">data</span>: any,</span><br><span class="line">  <span class="attr">children</span>: any,</span><br><span class="line">  <span class="attr">normalizationType</span>: any,</span><br><span class="line">  <span class="attr">alwaysNormalize</span>: boolean</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; {</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(data) || <span class="title function_">isPrimitive</span>(data)) {</span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = <span class="literal">undefined</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(alwaysNormalize)) {</span><br><span class="line">    normalizationType = <span class="variable constant_">ALWAYS_NORMALIZE</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_createElement</span>(context, tag, data, children, normalizationType)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面可以看到<code>createElement</code> 方法实际上是对 <code>_createElement</code> 方法的封装，对参数的传入进行了判断</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">_createElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">    context: Component,</span></span><br><span class="line"><span class="params">    tag?: string | Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">    data?: VNodeData,</span></span><br><span class="line"><span class="params">    children?: any,</span></span><br><span class="line"><span class="params">    normalizationType?: number</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; {</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>((<span class="attr">data</span>: any).<span class="property">__ob__</span>)) {</span><br><span class="line">        process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">`Avoid using observed data object as vnode data: <span class="subst">${<span class="built_in">JSON</span>.stringify(data)}</span>\n`</span> +</span><br><span class="line">            <span class="string">'Always create fresh vnode data objects in each render!'</span>,</span><br><span class="line">            context<span class="string">`</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">        return createEmptyVNode()</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    // object syntax in v-bind</span></span><br><span class="line"><span class="string">    if (isDef(data) &amp;&amp; isDef(data.is)) {</span></span><br><span class="line"><span class="string">        tag = data.is</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    if (!tag) {</span></span><br><span class="line"><span class="string">        // in case of component :is set to falsy value</span></span><br><span class="line"><span class="string">        return createEmptyVNode()</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    ... </span></span><br><span class="line"><span class="string">    // support single function children as default scoped slot</span></span><br><span class="line"><span class="string">    if (Array.isArray(children) &amp;&amp;</span></span><br><span class="line"><span class="string">        typeof children[0] === 'function'</span></span><br><span class="line"><span class="string">    ) {</span></span><br><span class="line"><span class="string">        data = data || {}</span></span><br><span class="line"><span class="string">        data.scopedSlots = { default: children[0] }</span></span><br><span class="line"><span class="string">        children.length = 0</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    if (normalizationType === ALWAYS_NORMALIZE) {</span></span><br><span class="line"><span class="string">        children = normalizeChildren(children)</span></span><br><span class="line"><span class="string">    } else if ( === SIMPLE_NORMALIZE) {</span></span><br><span class="line"><span class="string">        children = simpleNormalizeChildren(children)</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">	// 创建VNode</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure>


<p>可以看到<code>_createElement</code>接收5个参数：</p>
<ul>
<li><code>context</code> 表示 <code>VNode</code> 的上下文环境，是 <code>Component</code> 类型</li>
<li>tag 表示标签，它可以是一个字符串，也可以是一个 <code>Component</code></li>
<li><code>data</code> 表示 <code>VNode</code> 的数据，它是一个 <code>VNodeData</code> 类型</li>
<li><code>children</code> 表示当前 <code>VNode</code>的子节点，它是任意类型的</li>
<li><code>normalizationType</code> 表示子节点规范的类型，类型不同规范的方法也就不一样，主要是参考 <code>render</code> 函数是编译生成的还是用户手写的</li>
</ul>
<p>根据<code>normalizationType</code> 的类型，<code>children</code>会有不同的定义</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (normalizationType === <span class="variable constant_">ALWAYS_NORMALIZE</span>) {</span><br><span class="line">    children = <span class="title function_">normalizeChildren</span>(children)</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> ( === <span class="variable constant_">SIMPLE_NORMALIZE</span>) {</span><br><span class="line">    children = <span class="title function_">simpleNormalizeChildren</span>(children)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>simpleNormalizeChildren</code>方法调用场景是 <code>render</code> 函数是编译生成的</p>
<p><code>normalizeChildren</code>方法调用场景分为下面两种：</p>
<ul>
<li><code>render</code> 函数是用户手写的</li>
<li>编译 <code>slot</code>、<code>v-for</code> 的时候会产生嵌套数组</li>
</ul>
<p>无论是<code>simpleNormalizeChildren</code>还是<code>normalizeChildren</code>都是对<code>children</code>进行规范（使<code>children</code> 变成了一个类型为 <code>VNode</code> 的 <code>Array</code>），这里就不展开说了</p>
<p>规范化<code>children</code>的源码位置在：src/core/vdom/helpers/normalzie-children.js</p>
<p>在规范化<code>children</code>后，就去创建<code>VNode</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vnode, ns</span><br><span class="line"><span class="comment">// 对tag进行判断</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'string'</span>) {</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Ctor</span></span><br><span class="line">  ns = (context.<span class="property">$vnode</span> &amp;&amp; context.<span class="property">$vnode</span>.<span class="property">ns</span>) || config.<span class="title function_">getTagNamespace</span>(tag)</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="title function_">isReservedTag</span>(tag)) {</span><br><span class="line">    <span class="comment">// 如果是内置的节点，则直接创建一个普通VNode</span></span><br><span class="line">    vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">      config.<span class="title function_">parsePlatformTagName</span>(tag), data, children,</span><br><span class="line">      <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">    )</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(<span class="title class_">Ctor</span> = <span class="title function_">resolveAsset</span>(context.<span class="property">$options</span>, <span class="string">'components'</span>, tag))) {</span><br><span class="line">    <span class="comment">// component</span></span><br><span class="line">    <span class="comment">// 如果是component类型，则会通过createComponent创建VNode节点</span></span><br><span class="line">    vnode = <span class="title function_">createComponent</span>(<span class="title class_">Ctor</span>, data, context, children, tag)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">      tag, data, children,</span><br><span class="line">      <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">    )</span><br><span class="line">  }</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">// direct component options / constructor</span></span><br><span class="line">  vnode = <span class="title function_">createComponent</span>(tag, data, context, children)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">createComponent`同样是创建`VNode</span><br></pre></td></tr></tbody></table></figure>

<p>源码位置：src/core/vdom/create-component.js</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createComponent</span> (</span><br><span class="line">  <span class="title class_">Ctor</span>: <span class="title class_">Class</span>&lt;<span class="title class_">Component</span>&gt; | <span class="title class_">Function</span> | <span class="title class_">Object</span> | <span class="keyword">void</span>,</span><br><span class="line">  <span class="attr">data</span>: ?<span class="title class_">VNodeData</span>,</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">children</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;,</span><br><span class="line">  tag?: string</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; | <span class="keyword">void</span> {</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(<span class="title class_">Ctor</span>)) {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line"> <span class="comment">// 构建子类构造函数 </span></span><br><span class="line">  <span class="keyword">const</span> baseCtor = context.<span class="property">$options</span>.<span class="property">_base</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// plain options object: turn it into a constructor</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isObject</span>(<span class="title class_">Ctor</span>)) {</span><br><span class="line">    <span class="title class_">Ctor</span> = baseCtor.<span class="title function_">extend</span>(<span class="title class_">Ctor</span>)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if at this stage it's not a constructor or an async component factory,</span></span><br><span class="line">  <span class="comment">// reject.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Ctor</span> !== <span class="string">'function'</span>) {</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">'production'</span>) {</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`Invalid Component definition: <span class="subst">${<span class="built_in">String</span>(Ctor)}</span>`</span>, context)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// async component</span></span><br><span class="line">  <span class="keyword">let</span> asyncFactory</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(<span class="title class_">Ctor</span>.<span class="property">cid</span>)) {</span><br><span class="line">    asyncFactory = <span class="title class_">Ctor</span></span><br><span class="line">    <span class="title class_">Ctor</span> = <span class="title function_">resolveAsyncComponent</span>(asyncFactory, baseCtor, context)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Ctor</span> === <span class="literal">undefined</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createAsyncPlaceholder</span>(</span><br><span class="line">        asyncFactory,</span><br><span class="line">        data,</span><br><span class="line">        context,</span><br><span class="line">        children,</span><br><span class="line">        tag</span><br><span class="line">      )</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  data = data || {}</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve constructor options in case global mixins are applied after</span></span><br><span class="line">  <span class="comment">// component constructor creation</span></span><br><span class="line">  <span class="title function_">resolveConstructorOptions</span>(<span class="title class_">Ctor</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// transform component v-model data into props &amp; events</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data.<span class="property">model</span>)) {</span><br><span class="line">    <span class="title function_">transformModel</span>(<span class="title class_">Ctor</span>.<span class="property">options</span>, data)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// extract props</span></span><br><span class="line">  <span class="keyword">const</span> propsData = <span class="title function_">extractPropsFromVNodeData</span>(data, <span class="title class_">Ctor</span>, tag)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// functional component</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(<span class="title class_">Ctor</span>.<span class="property">options</span>.<span class="property">functional</span>)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createFunctionalComponent</span>(<span class="title class_">Ctor</span>, propsData, data, context, children)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// extract listeners, since these needs to be treated as</span></span><br><span class="line">  <span class="comment">// child component listeners instead of DOM listeners</span></span><br><span class="line">  <span class="keyword">const</span> listeners = data.<span class="property">on</span></span><br><span class="line">  <span class="comment">// replace with listeners with .native modifier</span></span><br><span class="line">  <span class="comment">// so it gets processed during parent component patch.</span></span><br><span class="line">  data.<span class="property">on</span> = data.<span class="property">nativeOn</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(<span class="title class_">Ctor</span>.<span class="property">options</span>.<span class="property">abstract</span>)) {</span><br><span class="line">    <span class="keyword">const</span> slot = data.<span class="property">slot</span></span><br><span class="line">    data = {}</span><br><span class="line">    <span class="keyword">if</span> (slot) {</span><br><span class="line">      data.<span class="property">slot</span> = slot</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 安装组件钩子函数，把钩子函数合并到data.hook中</span></span><br><span class="line">  <span class="title function_">installComponentHooks</span>(data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实例化一个VNode返回。组件的VNode是没有children的</span></span><br><span class="line">  <span class="keyword">const</span> name = <span class="title class_">Ctor</span>.<span class="property">options</span>.<span class="property">name</span> || tag</span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">${Ctor.cid}</span><span class="subst">${name ? <span class="string">`-<span class="subst">${name}</span>`</span> : <span class="string">''</span>}</span>`</span>,</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    { <span class="title class_">Ctor</span>, propsData, listeners, tag, children },</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">if</span> (__WEEX__ &amp;&amp; <span class="title function_">isRecyclableComponent</span>(vnode)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">renderRecyclableComponentTemplate</span>(vnode)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>稍微提下<code>createComponent</code>生成<code>VNode</code>的三个关键流程：</p>
<ul>
<li>构造子类构造函数<code>Ctor</code></li>
<li><code>installComponentHooks</code>安装组件钩子函数</li>
<li>实例化 <code>vnode</code></li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>createElement</code> 创建 <code>VNode</code> 的过程，每个 <code>VNode</code> 有 <code>children</code>，<code>children</code> 每个元素也是一个<code>VNode</code>，这样就形成了一个虚拟树结构，用于描述真实的<code>DOM</code>树结构</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/create-element.html#children-%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96">https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/create-element.html#children-%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96</a></li>
<li><a href="https://juejin.cn/post/6876711874050818061">https://juejin.cn/post/6876711874050818061</a></li>
<li>@js语音答题社区</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>虚拟dom</tag>
      </tags>
  </entry>
  <entry>
    <title>非原始值的响应式方案</title>
    <url>/posts/58809.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="非原始值的响应式方案"><a href="#非原始值的响应式方案" class="headerlink" title="非原始值的响应式方案"></a>非原始值的响应式方案</h1><h2 id="vue2的实现："><a href="#vue2的实现：" class="headerlink" title="vue2的实现："></a>vue2的实现：</h2><h3 id="使Object数据变得“可观测”"><a href="#使Object数据变得“可观测”" class="headerlink" title="使Object数据变得“可观测”"></a>使Object数据变得“可观测”</h3><p>数据的每次读和写能够被我们看的见，即我们能够知道数据什么时候被读取了或数据什么时候被改写了，我们将其称为数据变的‘可观测’。</p>
<span id="more"></span>

<p>要将数据变的‘可观测’，我们就要借助前言中提到的<code>Object.defineProperty</code>方法了，在本文中，我们就使用这个方法使数据变得“可观测”。</p>
<p>首先，我们定义一个数据对象<code>car</code>：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> car = {</span><br><span class="line">  <span class="string">'brand'</span>:<span class="string">'BMW'</span>,</span><br><span class="line">  <span class="string">'price'</span>:<span class="number">3000</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们定义了这个<code>car</code>的品牌<code>brand</code>是<code>BMW</code>,价格<code>price</code>是3000。现在我们可以通过<code>car.brand</code>和<code>car.price</code>直接读写这个<code>car</code>对应的属性值。但是，当这个<code>car</code>的属性被读取或修改时，我们并不知情。那么应该如何做才能够让<code>car</code>主动告诉我们，它的属性被修改了呢？</p>
<p>接下来，我们使用<code>Object.defineProperty()</code>改写上面的例子：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> car = {}</span><br><span class="line"><span class="keyword">let</span> val = <span class="number">3000</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(car, <span class="string">'price'</span>, {</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,     <span class="comment">//枚举</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>){</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'price属性被读取了'</span>)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newVal</span>){</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'price属性被修改了'</span>)</span><br><span class="line">    val = newVal</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>通过<code>Object.defineProperty()</code>方法给<code>car</code>定义了一个<code>price</code>属性，并把这个属性的读和写分别使用<code>get()</code>和<code>set()</code>进行拦截，每当该属性进行读或写操作的时候就会触发<code>get()</code>和<code>set()</code>。如下图：</p>
<img src="/posts/58809/58809/image-20221102073423099.png" class="" title="image-20221102073423099">

<p>可以看到，<code>car</code>已经可以主动告诉我们它的属性的读写情况了，这也意味着，这个<code>car</code>的数据对象已经是“可观测”的了。</p>
<p>为了把<code>car</code>的所有属性都变得可观测，我们可以编写如下代码：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 源码位置：src/core/observer/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observer</span> {</span><br><span class="line">  <span class="title function_">constructor</span> (value) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    <span class="comment">// 给value新增一个__ob__属性，值为该value的Observer实例</span></span><br><span class="line">    <span class="comment">// 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作</span></span><br><span class="line">    <span class="title function_">def</span>(value,<span class="string">'__ob__'</span>,<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) {</span><br><span class="line">      <span class="comment">// 当value为数组时的逻辑</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">walk</span>(value)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  walk (<span class="attr">obj</span>: <span class="title class_">Object</span>) {</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) {</span><br><span class="line">      <span class="title function_">defineReactive</span>(obj, keys[i])</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使一个对象转化成可观测对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type"> Object </span>} obj 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type"> String </span>} key 对象的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type"> Any </span>} val 对象的某个key的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span> (obj,key,val) {</span><br><span class="line">  <span class="comment">// 如果只传了obj和key，那么val = obj[key]</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) {</span><br><span class="line">    val = obj[key]</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">'object'</span>){</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Observer</span>(val)</span><br><span class="line">  }</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, {</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>){</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">${key}</span>属性被读取了`</span>);</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    },</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newVal</span>){</span><br><span class="line">      <span class="keyword">if</span>(val === newVal){</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      }</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">${key}</span>属性被修改了`</span>);</span><br><span class="line">      val = newVal;</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的代码中，我们定义了<code>observer</code>类，它用来将一个正常的<code>object</code>转换成可观测的<code>object</code>。</p>
<p>并且给<code>value</code>新增一个<code>__ob__</code>属性，值为该<code>value</code>的<code>Observer</code>实例。这个操作相当于为<code>value</code>打上标记，表示它已经被转化成响应式了，避免重复操作</p>
<p>然后判断数据的类型，只有<code>object</code>类型的数据才会调用<code>walk</code>将每一个属性转换成<code>getter/setter</code>的形式来侦测变化。 最后，在<code>defineReactive</code>中当传入的属性值还是一个<code>object</code>时使用<code>new observer（val）</code>来递归子属性，这样我们就可以把<code>obj</code>中的所有属性（包括子属性）都转换成<code>getter/seter</code>的形式来侦测变化。 也就是说，只要我们将一个<code>object</code>传到<code>observer</code>中，那么这个<code>object</code>就会变成可观测的、响应式的<code>object</code>。</p>
<p><code>observer</code>类位于源码的<code>src/core/observer/index.js</code>中。</p>
<p>那么现在，我们就可以这样定义<code>car</code>:</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Observer</span>({</span><br><span class="line">  <span class="string">'brand'</span>:<span class="string">'BMW'</span>,</span><br><span class="line">  <span class="string">'price'</span>:<span class="number">3000</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>这样，<code>car</code>的两个属性都变得可观测了。</p>
<h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><h4 id="什么是依赖收集"><a href="#什么是依赖收集" class="headerlink" title="什么是依赖收集"></a>什么是依赖收集</h4><p>在上一章中，我们迈出了第一步：让<code>object</code>数据变的可观测。变的可观测以后，我们就能知道数据什么时候发生了变化，那么当数据发生变化时，我们去通知视图更新就好了。那么问题又来了，视图那么大，我们到底该通知谁去变化？总不能一个数据变化了，把整个视图全部更新一遍吧，这样显然是不合理的。此时，你肯定会想到，视图里谁用到了这个数据就更新谁呗。对！你想的没错，就是这样。</p>
<p>视图里谁用到了这个数据就更新谁，我们换个优雅说法：我们把”谁用到了这个数据”称为”谁依赖了这个数据”,我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们：”你们依赖的数据变啦，你们该更新啦！”。这个过程就是依赖收集。</p>
<h4 id="何时收集依赖？何时通知依赖更新？"><a href="#何时收集依赖？何时通知依赖更新？" class="headerlink" title="何时收集依赖？何时通知依赖更新？"></a>何时收集依赖？何时通知依赖更新？</h4><p>明白了什么是依赖收集后，那么我们到底该在何时收集依赖？又该在何时通知依赖更新？</p>
<p>其实这个问题在上一小节中已经回答了，我们说过：谁用到了这个数据，那么当这个数据变化时就通知谁。所谓谁用到了这个数据，其实就是谁获取了这个数据，而可观测的数据被获取时会触发<code>getter</code>属性，那么我们就可以在<code>getter</code>中收集这个依赖。同样，当这个数据变化时会触发<code>setter</code>属性，那么我们就可以在<code>setter</code>中通知依赖更新。</p>
<p>总结一句话就是：<strong>在getter中收集依赖，在setter中通知依赖更新</strong>。</p>
<h4 id="把依赖收集到哪里"><a href="#把依赖收集到哪里" class="headerlink" title="把依赖收集到哪里"></a>把依赖收集到哪里</h4><p>明白了什么是依赖收集以及何时收集何时通知后，那么我们该把依赖收集到哪里？</p>
<p>我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。单单用一个数组来存放依赖的话，功能好像有点欠缺并且代码过于耦合。我们应该将依赖数组的功能扩展一下，更好的做法是我们应该为每一个数据都建立一个依赖管理器，把这个数据所有的依赖都管理起来。OK，到这里，我们的依赖管理器<code>Dep</code>类应运而生，代码如下：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 源码位置：src/core/observer/dep.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Dep</span> {</span><br><span class="line">  <span class="title function_">constructor</span> () {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  addSub (sub) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 删除一个依赖</span></span><br><span class="line">  removeSub (sub) {</span><br><span class="line">    <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">subs</span>, sub)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 添加一个依赖</span></span><br><span class="line">  depend () {</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">target</span>) {</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">addSub</span>(<span class="variable language_">window</span>.<span class="property">target</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 通知所有依赖更新</span></span><br><span class="line">  notify () {</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) {</span><br><span class="line">      subs[i].<span class="title function_">update</span>()</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove an item from an array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">remove</span> (arr, item) {</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span>) {</span><br><span class="line">    <span class="keyword">const</span> index = arr.<span class="title function_">indexOf</span>(item)</span><br><span class="line">    <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) {</span><br><span class="line">      <span class="keyword">return</span> arr.<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>在上面的依赖管理器<code>Dep</code>类中，我们先初始化了一个<code>subs</code>数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作。</p>
<p>有了依赖管理器后，我们就可以在getter中收集依赖，在setter中通知依赖更新了，代码如下：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span> (obj,key,val) {</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) {</span><br><span class="line">    val = obj[key]</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">'object'</span>){</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Observer</span>(val)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()  <span class="comment">//实例化一个依赖管理器，生成一个依赖管理数组dep</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, {</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>){</span><br><span class="line">      dep.<span class="title function_">depend</span>()    <span class="comment">// 在getter中收集依赖</span></span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    },</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newVal</span>){</span><br><span class="line">      <span class="keyword">if</span>(val === newVal){</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      }</span><br><span class="line">      val = newVal;</span><br><span class="line">      dep.<span class="title function_">notify</span>()   <span class="comment">// 在setter中通知依赖更新</span></span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上述代码中，我们在<code>getter</code>中调用了<code>dep.depend()</code>方法收集依赖，在<code>setter</code>中调用<code>dep.notify()</code>方法通知所有依赖更新。</p>
<h3 id="依赖到底是谁"><a href="#依赖到底是谁" class="headerlink" title="依赖到底是谁"></a>依赖到底是谁</h3><p>我们明白了什么是依赖？何时收集依赖？以及收集的依赖存放到何处？那么我们收集的依赖到底是谁？</p>
<p>虽然我们一直在说”谁用到了这个数据谁就是依赖“，但是这仅仅是在口语层面上，那么反应在代码上该如何来描述这个”谁“呢？</p>
<p>其实在<code>Vue</code>中还实现了一个叫做<code>Watcher</code>的类，而<code>Watcher</code>类的实例就是我们上面所说的那个”谁”。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的<code>Watch</code>实例，由<code>Watcher</code>实例去通知真正的视图。</p>
<p><code>Watcher</code>类的具体实现如下：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> {</span><br><span class="line">  <span class="title function_">constructor</span> (vm,expOrFn,cb) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  }</span><br><span class="line">  get () {</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">target</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span>.<span class="property">vm</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">target</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  }</span><br><span class="line">  update () {</span><br><span class="line">    <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, <span class="variable language_">this</span>.<span class="property">value</span>, oldValue)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse simple path.</span></span><br><span class="line"><span class="comment"> * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来</span></span><br><span class="line"><span class="comment"> * 例如：</span></span><br><span class="line"><span class="comment"> * data = {a:{b:{c:2}}}</span></span><br><span class="line"><span class="comment"> * parsePath('a.b.c')(data)  // 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parsePath</span> (path) {</span><br><span class="line">  <span class="keyword">if</span> (bailRE.<span class="title function_">test</span>(path)) {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">const</span> segments = path.<span class="title function_">split</span>(<span class="string">'.'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">obj</span>) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.<span class="property">length</span>; i++) {</span><br><span class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></span><br><span class="line">      obj = obj[segments[i]]</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>谁用到了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例，在创建<code>Watcher</code>实例的过程中会自动的把自己添加到这个数据对应的依赖管理器中，以后这个<code>Watcher</code>实例就代表这个依赖，当数据变化时，我们就通知<code>Watcher</code>实例，由<code>Watcher</code>实例再去通知真正的依赖。</p>
<p>那么，在创建<code>Watcher</code>实例的过程中它是如何的把自己添加到这个数据对应的依赖管理器中呢？</p>
<p>下面我们分析<code>Watcher</code>类的代码实现逻辑：</p>
<ol>
<li>当实例化<code>Watcher</code>类时，会先执行其构造函数；</li>
<li>在构造函数中调用了<code>this.get()</code>实例方法；</li>
<li>在<code>get()</code>方法中，首先通过<code>window.target = this</code>把实例自身赋给了全局的一个唯一对象<code>window.target</code>上，然后通过<code>let value = this.getter.call(vm, vm)</code>获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的<code>getter</code>，上文我们说过，在<code>getter</code>里会调用<code>dep.depend()</code>收集依赖，而在<code>dep.depend()</code>中取到挂载<code>window.target</code>上的值并将其存入依赖数组中，在<code>get()</code>方法最后将<code>window.target</code>释放掉。</li>
<li>而当数据变化时，会触发数据的<code>setter</code>，在<code>setter</code>中调用了<code>dep.notify()</code>方法，在<code>dep.notify()</code>方法中，遍历所有依赖(即watcher实例)，执行依赖的<code>update()</code>方法，也就是<code>Watcher</code>类中的<code>update()</code>实例方法，在<code>update()</code>方法中调用数据变化的更新回调函数，从而更新视图。</li>
</ol>
<p>简单总结一下就是：<code>Watcher</code>先把自己设置到全局唯一的指定位置（<code>window.target</code>），然后读取数据。因为读取了数据，所以会触发这个数据的<code>getter</code>。接着，在<code>getter</code>中就会从全局唯一的那个位置读取当前正在读取数据的<code>Watcher</code>，并把这个<code>watcher</code>收集到<code>Dep</code>中去。收集好之后，当数据发生变化时，会向<code>Dep</code>中的每个<code>Watcher</code>发送通知。通过这样的方式，<code>Watcher</code>可以主动去订阅任意一个数据的变化。为了便于理解，我们画出了其关系流程图，如下图：</p>
<img src="/posts/58809/58809/image-20221102074920068.png" class="" title="image-20221102074920068">

<p>以上，就彻底完成了对<code>Object</code>数据的侦测，依赖收集，依赖的更新等所有操作</p>
<h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><p>虽然我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，但是这个方法仅仅只能观测到<code>object</code>数据的取值及设置值，当我们向<code>object</code>数据里添加一对新的<code>key/value</code>或删除一对已有的<code>key/value</code>时，它是无法观测到的，导致当我们对<code>object</code>数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。</p>
<p>当然，<code>Vue</code>也注意到了这一点，为了解决这一问题，<code>Vue</code>增加了两个全局API:<code>Vue.set</code>和<code>Vue.delete</code>，这两个API的实现原理将会在后面学习全局API的时候说到。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先，我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，并且封装了<code>Observer</code>类，让我们能够方便的把<code>object</code>数据中的所有属性（包括子属性）都转换成<code>getter/seter</code>的形式来侦测变化。</p>
<p>接着，我们学习了什么是依赖收集？并且知道了在<code>getter</code>中收集依赖，在<code>setter</code>中通知依赖更新，以及封装了依赖管理器<code>Dep</code>，用于存储收集到的依赖。</p>
<p>最后，我们为每一个依赖都创建了一个<code>Watcher</code>实例，当数据发生变化时，通知<code>Watcher</code>实例，由<code>Watcher</code>实例去做真实的更新操作。</p>
<p>其整个流程大致如下：</p>
<ol>
<li><code>Data</code>通过<code>observer</code>转换成了<code>getter/setter</code>的形式来追踪变化。</li>
<li>当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而将<code>Watcher</code>添加到依赖中。</li>
<li>当数据发生了变化时，会触发<code>setter</code>，从而向<code>Dep</code>中的依赖（即Watcher）发送通知。</li>
<li><code>Watcher</code>接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</li>
</ol>
<h2 id="vue3的实现："><a href="#vue3的实现：" class="headerlink" title="vue3的实现："></a>vue3的实现：</h2><h3 id="理解proxy和reflect"><a href="#理解proxy和reflect" class="headerlink" title="理解proxy和reflect"></a>理解proxy和reflect</h3><h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h4><p>简单地说，使用 Proxy 可以创建一个代理对象。它能够实现对其他对象 的代理，这里的关键词是其他对象，也就是说，Proxy 只能代理对象，无法代理非对象值，例如字符串、布尔值等。那么，代理指的是什么呢？所谓代理，指的是对一个对象基本语义的代理。它允许我们拦截并重新定义对一个对象的基本操作。这句话的关键词比较多，我们逐一解释。</p>
<p>什么是基本语义？给出一个对象 obj，可以对它进行一些操作， 例如读取属性值、设置属性值：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> obj.<span class="property">foo</span> <span class="comment">// 读取属性 foo 的值</span></span><br><span class="line"><span class="number">02</span> obj.<span class="property">foo</span>++ <span class="comment">// 读取和设置属性 foo 的值</span></span><br></pre></td></tr></tbody></table></figure>

<p>Proxy定义: 用于定义基本操作的自定义行为</p>
<p><code>proxy</code>修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程(<code>meta</code> <code>programming</code>)</p>
<ul>
<li><strong>元编程（英语：Metaprogramming</strong>，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作</li>
</ul>
<p>一段代码来理解元编程:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># metaprogram</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'#!/bin/bash'</span> &gt;program</span><br><span class="line"><span class="keyword">for</span> ((I=<span class="number">1</span>; I&lt;=<span class="number">1024</span>; I++)) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"echo <span class="variable">$I</span>"</span> &gt;&gt;program</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">chmod</span> +x program</span><br></pre></td></tr></tbody></table></figure>

<p>这段程序每执行一次能帮我们生成一个名为program的文件，文件内容为1024行<code>echo</code>，如果我们手动来写1024行代码，效率显然低效</p>
<p><strong>元编程优点</strong>：与手工编写全部代码相比，程序员可以获得更高的工作效率，或者给与程序更大的灵活度去处理新的情形而无需重新编译</p>
<p><code>proxy</code> 译为代理，可以理解为在操作目标对象前架设一层代理，将所有本该我们手动编写的程序交由代理来处理，生活中也有许许多多的“proxy”, 如代购，中介，因为他们所有的行为都不会直接触达到目标对象</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul>
<li>target 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理</li>
<li>handler 一个通常以函数作为属性的对象，用来定制拦截行为</li>
</ul>
<p>类似这种读取、设置属性值的操作，就属于基本语义的操作，即 基本操作。既然是基本操作，那么它就可以使用 Proxy 拦截：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, {</span><br><span class="line"><span class="number">02</span> <span class="comment">// 拦截读取属性操作</span></span><br><span class="line"><span class="number">03</span> <span class="title function_">get</span>(<span class="params"></span>) { <span class="comment">/*...*/</span> },</span><br><span class="line"><span class="number">04</span> <span class="comment">// 拦截设置属性操作</span></span><br><span class="line"><span class="number">05</span> <span class="title function_">set</span>(<span class="params"></span>) { <span class="comment">/*...*/</span> }</span><br><span class="line"><span class="number">06</span> })</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>如以上代码所示，Proxy 构造函数接收两个参数。第一个参数是 被代理的对象，第二个参数也是一个对象，这个对象是一组夹子 （trap）。其中 get 函数用来拦截读取操作，set 函数用来拦截设置 操作。 </p>
<p>在 JavaScript 的世界里，万物皆对象。例如一个函数也是一个对 象，所以调用函数也是对一个对象的基本操作：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">name</span>) =&gt; {</span><br><span class="line"><span class="number">02</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'我是：'</span>, name)</span><br><span class="line"><span class="number">03</span> }</span><br><span class="line"><span class="number">04</span></span><br><span class="line"><span class="number">05</span> <span class="comment">// 调用函数是对对象的基本操作</span></span><br><span class="line"><span class="number">06</span> <span class="title function_">fn</span>()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>因此，我们可以用 Proxy 来拦截函数的调用操作，这里我们使用 apply 拦截函数的调用：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(fn, {</span><br><span class="line"><span class="number">02</span> <span class="comment">// 使用 apply 拦截函数调用</span></span><br><span class="line"><span class="number">03</span> <span class="title function_">apply</span>(<span class="params">target, thisArg, argArray</span>) {</span><br><span class="line"><span class="number">04</span> target.<span class="title function_">call</span>(thisArg, ...argArray)</span><br><span class="line"><span class="number">05</span> }</span><br><span class="line"><span class="number">06</span> })</span><br><span class="line"><span class="number">07</span></span><br><span class="line"><span class="number">08</span> <span class="title function_">p2</span>(<span class="string">'hcy'</span>) <span class="comment">// 输出：'我是：hcy'</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面两个例子说明了什么是基本操作。Proxy 只能够拦截对一个 对象的基本操作。那么，什么是非基本操作呢？其实调用对象下的方 法就是典型的非基本操作，我们叫它复合操作：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> obj.<span class="title function_">fn</span>()</span><br></pre></td></tr></tbody></table></figure>

<p>实际上，调用一个对象下的方法，是由两个基本语义组成的。第一个基本语义是 get，即先通过 get 操作得到 obj.fn 属性。第二个基本语义是函数调用，即通过 get 得到 obj.fn 的值后再调用它，也就是我们上面说到的 apply。理解 Proxy 只能够代理对象的基本语义 很重要，后续我们讲解如何实现对数组或 Map、Set 等数据类型的代 理时，都利用了 Proxy 的这个特点。</p>
<h4 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h4><p>理解了 Proxy，我们再来讨论 Reflect。Reflect 是一个全局对象，其下有许多方法，例如：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>()</span><br><span class="line"><span class="number">02</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>()</span><br><span class="line"><span class="number">03</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>()</span><br><span class="line"><span class="number">04</span> <span class="comment">// ...</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>你可能已经注意到了，Reflect 下的方法与 Proxy 的拦截器方 法名字相同，其实这不是偶然。任何在 Proxy 的拦截器中能够找到的 方法，都能够在 Reflect 中找到同名函数，那么这些函数的作用是什 么呢？其实它们的作用一点儿都不神秘。拿 Reflect.get 函数来 说，它的功能就是提供了访问一个对象属性的默认行为，例如下面两 个操作是等价的：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> obj = { <span class="attr">foo</span>: <span class="number">1</span> }</span><br><span class="line"><span class="number">02</span></span><br><span class="line"><span class="number">03</span> <span class="comment">// 直接读取</span></span><br><span class="line"><span class="number">04</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="number">05</span> <span class="comment">// 使用 Reflect.get 读取</span></span><br><span class="line"><span class="number">06</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(obj, <span class="string">'foo'</span>)) <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure>

<p>可能有的读者会产生疑问：既然操作等价，那么它存在的意义是 什么呢？实际上 Reflect.get 函数还能接收第三个参数，即指定接 收者 receiver，你可以把它理解为函数调用过程中的 this，例如：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> obj = { <span class="attr">foo</span>: <span class="number">1</span> }</span><br><span class="line"><span class="number">02</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(obj, <span class="string">'foo'</span>, { <span class="attr">foo</span>: <span class="number">2</span> })) <span class="comment">// 输出的是 2 而</span></span><br><span class="line">不是 <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在这段代码中，我们指定第三个参数 receiver 为一个对象 { foo: 2 }，这时读取到的值是 receiver 对象的 foo 属性值。实际 上，Reflect.* 方法还有很多其他方面的意义，但这里我们只关心并 讨论这一点，因为它与响应式数据的实现密切相关。为了说明问题， 回顾一下在上一节中实现响应式数据的代码：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> obj = { <span class="attr">foo</span>: <span class="number">1</span> }</span><br><span class="line"><span class="number">02</span></span><br><span class="line"><span class="number">03</span> <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, {</span><br><span class="line"><span class="number">04</span> <span class="title function_">get</span>(<span class="params">target, key</span>) {</span><br><span class="line"><span class="number">05</span> <span class="title function_">track</span>(target, key)</span><br><span class="line"><span class="number">06</span> <span class="comment">// 注意，这里我们没有使用 Reflect.get 完成读取</span></span><br><span class="line"><span class="number">07</span> <span class="keyword">return</span> target[key]</span><br><span class="line"><span class="number">08</span> },</span><br><span class="line"><span class="number">09</span> <span class="title function_">set</span>(<span class="params">target, key, newVal</span>) {</span><br><span class="line"><span class="number">10</span> <span class="comment">// 这里同样没有使用 Reflect.set 完成设置</span></span><br><span class="line"><span class="number">11</span> target[key] = newVal</span><br><span class="line"><span class="number">12</span> <span class="title function_">trigger</span>(target, key)</span><br><span class="line"><span class="number">13</span> }</span><br><span class="line"><span class="number">14</span> })</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这是上一章中用来实现响应式数据的最基本的代码。在 get 和 set 拦截函数中，我们都是直接使用原始对象 target 来完成对属性 的读取和设置操作的，其中原始对象 target 就是上述代码中的 obj 对象。 那么这段代码有什么问题吗？我们借助 effect 让问题暴露出 来。首先，我们修改一下 obj 对象，为它添加 bar 属性：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> obj = {</span><br><span class="line"><span class="number">02</span>   <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line"><span class="number">03</span>   <span class="keyword">get</span> <span class="title function_">bar</span>() {</span><br><span class="line"><span class="number">04</span>      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span></span><br><span class="line"><span class="number">05</span>   }</span><br><span class="line"><span class="number">06</span> }</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，bar 属性是一个访问器属性，它返回了 this.foo 属 性的值。接着，我们在 effect 副作用函数中通过代理对象 p 访问 bar 属性：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="title function_">effect</span>(<span class="function">() =&gt;</span> {</span><br><span class="line"><span class="number">02</span> 		<span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">bar</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="number">03</span> })</span><br></pre></td></tr></tbody></table></figure>

<p>我们来分析一下这个过程发生了什么。当 effect 注册的副作用 函数执行时，会读取 p.bar 属性，它发现 p.bar 是一个访问器属 性，因此执行 getter 函数。由于在 getter 函数中通过 this.foo 读取了 foo 属性值，因此我们认为副作用函数与属性 foo 之间也会建 立联系。当我们修改 p.foo 的值时应该能够触发响应，使得副作用函 数重新执行才对。然而实际并非如此，当我们尝试修改 p.foo 的值 时：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">01 p.foo++</span><br></pre></td></tr></tbody></table></figure>

<p>副作用函数并没有重新执行，问题出在哪里呢？ 实际上，问题就出在 bar 属性的访问器函数 getter 里：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> obj = {</span><br><span class="line"><span class="number">02</span> 		<span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line"><span class="number">03</span> 		<span class="keyword">get</span> <span class="title function_">bar</span>() {</span><br><span class="line"><span class="number">04</span> 			<span class="comment">// 这里的 this 指向的是谁？</span></span><br><span class="line"><span class="number">05</span> 			<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span></span><br><span class="line"><span class="number">06</span> 		}</span><br><span class="line"><span class="number">07</span> }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>当我们使用 this.foo 读取 foo 属性值时，这里的 this 指向的 是谁呢？我们回顾一下整个流程。首先，我们通过代理对象 p 访问 p.bar，这会触发代理对象的 get 拦截函数执行：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, {</span><br><span class="line"><span class="number">02</span> 	  <span class="title function_">get</span>(<span class="params">target, key</span>) {</span><br><span class="line"><span class="number">03</span> 		<span class="title function_">track</span>(target, key)</span><br><span class="line"><span class="number">04</span> 		<span class="comment">// 注意，这里我们没有使用 Reflect.get 完成读取</span></span><br><span class="line"><span class="number">05</span> 		<span class="keyword">return</span> target[key]</span><br><span class="line"><span class="number">06</span> 	  },</span><br><span class="line"><span class="number">07</span>    <span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="number">08</span> })</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在 get 拦截函数内，通过 target[key] 返回属性值。其中 target 是原始对象 obj，而 key 就是字符串 ‘bar’，所以 target[key] 相当于 obj.bar。因此，当我们使用 p.bar 访问 bar 属性时，它的 getter 函数内的 this 指向的其实是原始对象 obj， 这说明我们最终访问的其实是 obj.foo。很显然，在副作用函数内通 过原始对象访问它的某个属性是不会建立响应联系的，这等价于：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="title function_">effect</span>(<span class="function">() =&gt;</span> {</span><br><span class="line"><span class="number">02</span> 		<span class="comment">// obj 是原始数据，不是代理对象，这样的访问不能够建立响应联系</span></span><br><span class="line"><span class="number">03</span> 		obj.<span class="property">foo</span></span><br><span class="line"><span class="number">04</span> })</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>因为这样做不会建立响应联系，所以出现了无法触发响应的问 题。那么这个问题应该如何解决呢？这时 Reflect.get 函数就派上 用场了。先给出解决问题的代码：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, {</span><br><span class="line"><span class="number">02</span> 		<span class="comment">// 拦截读取操作，接收第三个参数 receiver</span></span><br><span class="line"><span class="number">03</span> 		<span class="title function_">get</span>(<span class="params">target, key, receiver</span>) {</span><br><span class="line"><span class="number">04</span> 			<span class="title function_">track</span>(target, key)</span><br><span class="line"><span class="number">05</span> 			<span class="comment">// 使用 Reflect.get 返回读取到的属性值</span></span><br><span class="line"><span class="number">06</span> 				<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line"><span class="number">07</span> 		},</span><br><span class="line"><span class="number">08</span> 		<span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="number">09</span> })</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>如上面的代码所示，代理对象的 get 拦截函数接收第三个参数 receiver，它代表谁在读取属性，例如：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> p.<span class="property">bar</span> <span class="comment">// 代理对象 p 在读取 bar 属性</span></span><br></pre></td></tr></tbody></table></figure>

<p>当我们使用代理对象 p 访问 bar 属性时，那么 receiver 就是 p，你可以把它简单地理解为函数调用中的 this。接着关键的一步发 生了，我们使用 Reflect.get(target, key, receiver) 代替 之前的 target[key]，这里的关键点就是第三个参数 receiver。 我们已经知道它就是代理对象 p，所以访问器属性 bar 的 getter 函 数内的 this 指向代理对象 p：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> obj = {</span><br><span class="line"><span class="number">02</span> 		<span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line"><span class="number">03</span> 		<span class="keyword">get</span> <span class="title function_">bar</span>() {</span><br><span class="line"><span class="number">04</span> 			<span class="comment">// 现在这里的 this 为代理对象 p</span></span><br><span class="line"><span class="number">05</span> 			<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span></span><br><span class="line"><span class="number">06</span> 		}</span><br><span class="line"><span class="number">07</span> }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，this 由原始对象 obj 变成了代理对象 p。很显然，这 会在副作用函数与响应式数据之间建立响应联系，从而达到依赖收集 的效果。如果此时再对 p.foo 进行自增操作，会发现已经能够触发副 作用函数重新执行了。</p>
<h3 id="Handler-对象常用的方法"><a href="#Handler-对象常用的方法" class="headerlink" title="Handler 对象常用的方法"></a>Handler 对象常用的方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>handler.has()</td>
<td>in 操作符的捕捉器。</td>
</tr>
<tr>
<td>handler.get()</td>
<td>属性读取操作的捕捉器。</td>
</tr>
<tr>
<td>handler.set()</td>
<td>属性设置操作的捕捉器。</td>
</tr>
<tr>
<td>handler.deleteProperty()</td>
<td>delete 操作符的捕捉器。</td>
</tr>
<tr>
<td>handler.ownKeys()</td>
<td>Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。</td>
</tr>
<tr>
<td>handler.apply()</td>
<td>函数调用操作的捕捉器。</td>
</tr>
<tr>
<td>handler.construct()</td>
<td>new 操作符的捕捉器</td>
</tr>
</tbody></table>
<p>下面挑<code>handler.get</code>重点讲一下，其它方法的使用也都大同小异，不同的是参数的区别</p>
<h4 id="handler-get"><a href="#handler-get" class="headerlink" title="handler.get"></a>handler.get</h4><p><code>get</code>我们在上面例子已经体验过了，现在详细介绍一下，用于代理目标对象的属性读取操作</p>
<p>授受三个参数 <code>get(target, propKey, ?receiver)</code></p>
<ul>
<li>target 目标对象</li>
<li>propkey 属性名</li>
<li>receiver Proxy 实例本身</li>
</ul>
<p><strong>举个例子</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = {</span><br><span class="line">  <span class="attr">like</span>: <span class="string">"vuejs"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, {</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) {</span><br><span class="line">    <span class="keyword">if</span> (propKey <span class="keyword">in</span> target) {</span><br><span class="line">      <span class="keyword">return</span> target[propKey];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(<span class="string">"Prop name \""</span> + propKey + <span class="string">"\" does not exist."</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">obj.<span class="property">like</span> <span class="comment">// vuejs</span></span><br><span class="line">obj.<span class="property">test</span> <span class="comment">// Uncaught ReferenceError: Prop name "test" does not exist.</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码表示在读取代理目标的值时，如果有值则直接返回，没有值就抛出一个自定义的错误</p>
<p><strong>注意:</strong></p>
<ul>
<li>如果要访问的目标属性是不可写以及不可配置的，则返回的值必须与该目标属性的值相同</li>
<li>如果要访问的目标属性没有配置访问方法，即get方法是undefined的，则返回值必须为undefined</li>
</ul>
<p>如下面的例子</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = {};</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">"a"</span>, { </span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>, </span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>, </span><br><span class="line">  <span class="attr">value</span>: <span class="number">10</span>, </span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span> </span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, {</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, prop</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">p.<span class="property">a</span> <span class="comment">// Uncaught TypeError: 'get' on proxy: property 'a' is a read-only and non-configurable..</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="可撤消的Proxy"><a href="#可撤消的Proxy" class="headerlink" title="可撤消的Proxy"></a>可撤消的Proxy</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">proxy`有一个唯一的静态方法，`Proxy.revocable(target, handler)</span><br></pre></td></tr></tbody></table></figure>

<p><code>Proxy.revocable()</code>方法可以用来创建一个可撤销的代理对象</p>
<p>该方法的返回值是一个对象，其结构为： <code>{"proxy": proxy, "revoke": revoke}</code></p>
<ul>
<li>proxy 表示新生成的代理对象本身，和用一般方式 new Proxy(target, handler) 创建的代理对象没什么不同，只是它可以被撤销掉。</li>
<li>revoke 撤销方法，调用的时候不需要加任何参数，就可以撤销掉和它一起生成的那个代理对象。</li>
</ul>
<p>该方法常用于完全封闭对目标对象的访问, 如下示例</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = { <span class="attr">name</span>: <span class="string">'vuejs'</span>}</span><br><span class="line"><span class="keyword">const</span> {proxy, revoke} = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler)</span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// 正常取值输出 vuejs</span></span><br><span class="line"><span class="title function_">revoke</span>() <span class="comment">// 取值完成对proxy进行封闭，撤消代理</span></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Proxy的应用场景"><a href="#Proxy的应用场景" class="headerlink" title="Proxy的应用场景"></a>Proxy的应用场景</h3><p><code>Proxy</code>的应用范围很广，下方列举几个典型的应用场景</p>
<h4 id="校验器"><a href="#校验器" class="headerlink" title="校验器"></a><strong>校验器</strong></h4><p>想要一个<code>number</code>，拿回来的却是<code>string</code>，惊不惊喜？意不意外？下面我们使用<code>Proxy</code>实现一个逻辑分离的数据格式验证器</p>
<p>嗯，真香!</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">_id</span>: <span class="string">'1024'</span>,</span><br><span class="line">  <span class="attr">name</span>:  <span class="string">'vuejs'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validators = {  </span><br><span class="line">    <span class="title function_">name</span>(<span class="params">val</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">'string'</span>;</span><br><span class="line">    },</span><br><span class="line">    <span class="title function_">_id</span>(<span class="params">val</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">'number'</span> &amp;&amp; val &gt; <span class="number">1024</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createValidator</span> = (<span class="params">target, validator</span>) =&gt; {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, {</span><br><span class="line">    <span class="attr">_validator</span>: validator,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, propkey, value, proxy</span>){</span><br><span class="line">      <span class="keyword">let</span> validator = <span class="variable language_">this</span>.<span class="property">_validator</span>[propkey](value)</span><br><span class="line">      <span class="keyword">if</span>(validator){</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, propkey, value, proxy)</span><br><span class="line">      }<span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">`Cannot set <span class="subst">${propkey}</span> to <span class="subst">${value}</span>. Invalid type.`</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">createValidator</span>(target, validators)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">'vue-js.com'</span> <span class="comment">// vue-js.com</span></span><br><span class="line">proxy.<span class="property">name</span> = <span class="number">10086</span> <span class="comment">// Uncaught Error: Cannot set name to 10086. Invalid type.</span></span><br><span class="line">proxy.<span class="property">_id</span> = <span class="number">1025</span> <span class="comment">// 1025</span></span><br><span class="line">proxy.<span class="property">_id</span> = <span class="number">22</span>  <span class="comment">// Uncaught Error: Cannot set _id to 22. Invalid type </span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><p>在日常编写代码的过程中，我们想定义一些私有属性，通常是在团队中进行约定，大家按照约定在变量名之前添加下划线 _ 或者其它格式来表明这是一个私有属性，但我们不能保证他能真私‘私有化’，下面使用Proxy轻松实现私有属性拦截</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = {</span><br><span class="line">  <span class="attr">_id</span>: <span class="string">'1024'</span>,</span><br><span class="line">  <span class="attr">name</span>:  <span class="string">'vuejs'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, {</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, propkey, proxy</span>){</span><br><span class="line">    <span class="keyword">if</span>(propkey[<span class="number">0</span>] === <span class="string">'_'</span>){</span><br><span class="line">      <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">${propkey}</span> is restricted`</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propkey, proxy)</span><br><span class="line">  },</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, propkey, value, proxy</span>){</span><br><span class="line">    <span class="keyword">if</span>(propkey[<span class="number">0</span>] === <span class="string">'_'</span>){</span><br><span class="line">      <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">${propkey}</span> is restricted`</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, propkey, value, proxy)</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// vuejs</span></span><br><span class="line">proxy.<span class="property">_id</span> <span class="comment">// Uncaught Error: _id is restricted</span></span><br><span class="line">proxy.<span class="property">_id</span> = <span class="string">'1025'</span> <span class="comment">// Uncaught Error: _id is restricted</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>Proxy</code> 使用场景还有很多很多，不再一一列举，如果你需要在某一个动作的生命周期内做一些特定的处理，那么<code>Proxy</code> 都是适合的</p>
<h3 id="为什么要用Proxy重构"><a href="#为什么要用Proxy重构" class="headerlink" title="为什么要用Proxy重构"></a>为什么要用Proxy重构</h3><p>在 <code>Proxy</code> 之前，<code>JavaScript</code> 中就提供过 <code>Object.defineProperty</code>，允许对对象的 <code>getter/setter</code> 进行拦截</p>
<p>Vue3.0之前的双向绑定是由 <code>defineProperty</code> 实现, 在3.0重构为 <code>Proxy</code>，那么两者的区别究竟在哪里呢？</p>
<p>首先我们再来回顾一下它的定义</p>
<blockquote>
<p>Object.defineProperty() 方法会直接在一个<strong>对象上</strong>定义一个<strong>新属性</strong>，或者修改一个对象的现有属性，并返回此对象</p>
</blockquote>
<p>上面给两个词划了重点，<strong>对象上</strong>，<strong>属性</strong>，我们可以理解为是针对对象上的某一个属性做处理的</p>
<p><strong>语法</strong></p>
<ul>
<li>obj 要定义属性的对象</li>
<li>prop 要定义或修改的属性的名称或 Symbol</li>
<li>descriptor 要定义或修改的属性描述符</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, descriptor)</span><br></pre></td></tr></tbody></table></figure>

<p>举个例子</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = {}</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">"a"</span>, {</span><br><span class="line">  value : <span class="number">1</span>,</span><br><span class="line">  writable : <span class="literal">false</span>, <span class="comment">// 是否可写 </span></span><br><span class="line">  configurable : <span class="literal">false</span>, <span class="comment">// 是否可配置</span></span><br><span class="line">  enumerable : <span class="literal">false</span> <span class="comment">// 是否可枚举</span></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面给了三个false, 下面的相关操作就很容易理解了</span></span><br><span class="line">obj.<span class="property">a</span> = <span class="number">2</span> <span class="comment">// 无效</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">a</span> <span class="comment">// 无效</span></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">in</span> obj){</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key) <span class="comment">// 无效 </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>一个优秀的开源框架本身就是一个不断打碎重朔的过程，上面做了些许铺垫，现在我们简要总结一下</p>
<ul>
<li><code>Proxy</code> 作为新标准将受到浏览器厂商重点持续的性能优化</li>
<li><code>Proxy</code> 能观察的类型比 <code>defineProperty</code> 更丰富</li>
<li><code>Proxy</code> 不兼容IE，也没有 <code>polyfill</code>, <code>defineProperty</code> 能支持到IE9</li>
<li><code>Object.definedProperty</code> 是劫持对象的属性，新增元素需要再次 <code>definedProperty</code>。而 <code>Proxy</code> 劫持的是整个对象，不需要做特殊处理</li>
<li>使用 <code>defineProperty</code> 时，我们修改原来的 <code>obj</code> 对象就可以触发拦截，而使用 <code>proxy</code>，就必须修改代理对象，即 <code>Proxy</code> 的实例才可以触发拦截</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>非原始值的响应式</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官：你对SPA单页面的理解</title>
    <url>/posts/32710.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="面试官：你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"><a href="#面试官：你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢" class="headerlink" title="面试官：你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"></a>面试官：你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢</h1><img src="/posts/32710/32710/image-20221011061141846.png" class="" title="image-20221011061141846">

<h2 id="一、什么是SPA"><a href="#一、什么是SPA" class="headerlink" title="一、什么是SPA"></a>一、什么是SPA</h2><p>SPA（single-page application），翻译过来就是单页应用<code>SPA</code>是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（<code>HTML</code>、<code>JavaScript</code>和<code>CSS</code>）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载，也不会将控制转移到其他页面举个例子来讲就是一个杯子，早上装的牛奶，中午装的是开水，晚上装的是茶，我们发现，变的始终是杯子里的内容，而杯子始终是那个杯子结构如下图：</p>
<span id="more"></span>

<img src="/posts/32710/32710/image-20221011061213843.png" class="" title="image-20221011061213843">

<p>我们熟知的JS框架如<code>react</code>,<code>vue</code>,<code>angular</code>,<code>ember</code>都属于<code>SPA</code></p>
<h2 id="二、SPA和MPA的区别"><a href="#二、SPA和MPA的区别" class="headerlink" title="二、SPA和MPA的区别"></a>二、SPA和MPA的区别</h2><p>上面大家已经对单页面有所了解了，下面来讲讲多页应用MPA（MultiPage-page application），翻译过来就是多页应用在<code>MPA</code>中，每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载<code>html</code>、<code>css</code>、<code>js</code>文件，公共文件则根据需求按需加载如下图</p>
<img src="/posts/32710/32710/image-20221011061312701.png" class="" title="image-20221011061312701">

<h4 id="单页应用与多页应用的区别："><a href="#单页应用与多页应用的区别：" class="headerlink" title="单页应用与多页应用的区别："></a>单页应用与多页应用的区别：</h4><img src="/posts/32710/32710/image-20221011061336211.png" class="" title="image-20221011061336211">

<h4 id="单页应用优缺点"><a href="#单页应用优缺点" class="headerlink" title="单页应用优缺点"></a>单页应用优缺点</h4><p>优点：</p>
<ul>
<li>具有桌面应用的即时性、网站的可移植性和可访问性</li>
<li>用户体验好、快，内容的改变不需要重新加载整个页面</li>
<li>良好的前后端分离，分工更明确</li>
</ul>
<p>缺点：</p>
<ul>
<li>不利于搜索引擎的抓取</li>
<li>首次渲染速度相对较慢</li>
</ul>
<h2 id="三、实现一个SPA"><a href="#三、实现一个SPA" class="headerlink" title="三、实现一个SPA"></a>三、实现一个SPA</h2><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ol>
<li>监听地址栏中<code>hash</code>变化驱动界面变化</li>
<li>用<code>pushsate</code>记录浏览器的历史，驱动界面发送变化</li>
</ol>
<img src="/posts/32710/32710/image-20221011061432829.png" class="" title="image-20221011061432829">

<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a><code>hash</code> 模式</h5><p>核心通过监听<code>url</code>中的<code>hash</code>来进行路由跳转</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 Router  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> {  </span><br><span class="line">    <span class="title function_">constructor</span> () {  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">routes</span> = {}; <span class="comment">// 存放路由path及callback  </span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">currentUrl</span> = <span class="string">''</span>;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 监听路由change调用相对应的路由回调  </span></span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">'load'</span>, <span class="variable language_">this</span>.<span class="property">refresh</span>, <span class="literal">false</span>);  </span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">'hashchange'</span>, <span class="variable language_">this</span>.<span class="property">refresh</span>, <span class="literal">false</span>);  </span><br><span class="line">    }  </span><br><span class="line">      </span><br><span class="line">    <span class="title function_">route</span>(<span class="params">path, callback</span>){  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">routes</span>[path] = callback;  </span><br><span class="line">    }  </span><br><span class="line">      </span><br><span class="line">    <span class="title function_">push</span>(<span class="params">path</span>) {  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">routes</span>[path] &amp;&amp; <span class="variable language_">this</span>.<span class="property">routes</span>[path]()  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用 router  </span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">miniRouter</span> = <span class="keyword">new</span> <span class="title class_">Router</span>();  </span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">'/'</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'page1'</span>))  </span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">'/page2'</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'page2'</span>))  </span><br><span class="line">  </span><br><span class="line">miniRouter.<span class="title function_">push</span>(<span class="string">'/'</span>) <span class="comment">// page1  </span></span><br><span class="line">miniRouter.<span class="title function_">push</span>(<span class="string">'/page2'</span>) <span class="comment">// page2  </span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h5><p><code>history</code> 模式核心借用 <code>HTML5 history api</code>，<code>api</code> 提供了丰富的 <code>router</code> 相关属性先了解一个几个相关的api</p>
<ul>
<li><p><code>history.pushState</code> 浏览器历史纪录添加记录</p>
</li>
<li><p><code>history.replaceState</code>修改浏览器历史纪录中当前纪录</p>
</li>
<li><p><code>history.popState</code> 当 <code>history</code> 发生变化时触发</p>
</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 Router  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> {  </span><br><span class="line">    <span class="title function_">constructor</span> () {  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">routes</span> = {};  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">listerPopState</span>()  </span><br><span class="line">    }  </span><br><span class="line">      </span><br><span class="line">    <span class="title function_">init</span>(<span class="params">path</span>) {  </span><br><span class="line">        history.<span class="title function_">replaceState</span>({<span class="attr">path</span>: path}, <span class="literal">null</span>, path);  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">routes</span>[path] &amp;&amp; <span class="variable language_">this</span>.<span class="property">routes</span>[path]();  </span><br><span class="line">    }  </span><br><span class="line">      </span><br><span class="line">    <span class="title function_">route</span>(<span class="params">path, callback</span>){  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">routes</span>[path] = callback;  </span><br><span class="line">    }  </span><br><span class="line">      </span><br><span class="line">    <span class="title function_">push</span>(<span class="params">path</span>) {  </span><br><span class="line">        history.<span class="title function_">pushState</span>({<span class="attr">path</span>: path}, <span class="literal">null</span>, path);  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">routes</span>[path] &amp;&amp; <span class="variable language_">this</span>.<span class="property">routes</span>[path]();  </span><br><span class="line">    }  </span><br><span class="line">      </span><br><span class="line">    listerPopState () {  </span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">'popstate'</span> , <span class="function"><span class="params">e</span> =&gt;</span> {  </span><br><span class="line">            <span class="keyword">const</span> path = e.<span class="property">state</span> &amp;&amp; e.<span class="property">state</span>.<span class="property">path</span>;  </span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">routers</span>[path] &amp;&amp; <span class="variable language_">this</span>.<span class="property">routers</span>[path]()  </span><br><span class="line">        })  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用 Router  </span></span><br><span class="line">  </span><br><span class="line"><span class="variable language_">window</span>.<span class="property">miniRouter</span> = <span class="keyword">new</span> <span class="title class_">Router</span>();  </span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">'/'</span>, <span class="function">()=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'page1'</span>))  </span><br><span class="line">miniRouter.<span class="title function_">route</span>(<span class="string">'/page2'</span>, <span class="function">()=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'page2'</span>))  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 跳转  </span></span><br><span class="line">miniRouter.<span class="title function_">push</span>(<span class="string">'/page2'</span>)  <span class="comment">// page2  </span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="四、题外话：如何给SPA做SEO"><a href="#四、题外话：如何给SPA做SEO" class="headerlink" title="四、题外话：如何给SPA做SEO"></a>四、题外话：如何给SPA做SEO</h2><p>下面给出基于<code>Vue</code>的<code>SPA</code>如何实现<code>SEO</code>的三种方式</p>
<h4 id="SSR服务端渲染"><a href="#SSR服务端渲染" class="headerlink" title="SSR服务端渲染"></a>SSR服务端渲染</h4><p>将组件或页面通过服务器生成html，再返回给浏览器，如<code>nuxt.js</code></p>
<h4 id="静态化"><a href="#静态化" class="headerlink" title="静态化"></a><strong>静态化</strong></h4><p>目前主流的静态化主要有两种：（1）一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中（2）另外一种是通过WEB服务器的 <code>URL Rewrite</code>的方式，它的原理是通过web服务器内部模块按一定规则将外部的URL请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现URL静态化的效果</p>
<ol>
<li><strong>使用<code>Phantomjs</code>针对爬虫处理</strong></li>
</ol>
<p>原理是通过<code>Nginx</code>配置，判断访问来源是否为爬虫，如果是则搜索引擎的爬虫请求会转发到一个<code>node server</code>，再通过<code>PhantomJS</code>来解析完整的<code>HTML</code>，返回给爬虫。下面是大致流程图</p>
<p><img src="/posts/32710/image-20221011061639950.png" alt="image-20221011061639950"></p>
<h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><ul>
<li><a href="https://segmentfault.com/a/1190000019623624">https://segmentfault.com/a/1190000019623624</a></li>
<li><a href="https://juejin.cn/post/6844903512107663368">https://juejin.cn/post/6844903512107663368</a></li>
<li><a href="https://www.cnblogs.com/constantince/p/5586851.html">https://www.cnblogs.com/constantince/p/5586851.html</a></li>
</ul>
<p>@js语音答题社区</p>
</body></html>]]></content>
      <categories>
        <category>vue面试题</category>
      </categories>
      <tags>
        <tag>spa</tag>
      </tags>
  </entry>
  <entry>
    <title>项目中为什么有那么多配置文件？</title>
    <url>/posts/38979.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="为什么在我的简单的-web-项目中有这么多的配置文件？"><a href="#为什么在我的简单的-web-项目中有这么多的配置文件？" class="headerlink" title="为什么在我的简单的 web 项目中有这么多的配置文件？"></a>为什么在我的简单的 web 项目中有这么多的配置文件？</h1><img src="/posts/38979/38979/image-20221026164733995.png" class="" title="image-20221026164733995">

<p>在从事任何 Web 开发项目时，您是否遇到过一些奇怪而神秘的配置文件？即使是一个简单的小项目也可能有ー—eslintrc.js, .eslintignore, .editorconfig，tsconfig.json，pretier.config.js，firebase.src 等等。</p>
<span id="more"></span>

<p>让我们浏览一下常见的 javascript 配置文件，并检查它们主要用于什么。</p>
<p>一些配置文件可以用多种语言编写，通常是: Javascript (. js)、 json、 yaml、 toml。</p>
<h2 id="格式化操作"><a href="#格式化操作" class="headerlink" title="格式化操作"></a>格式化操作</h2><p>对于任何项目来说，保持一致的代码格式和维护代码质量都是非常关键的，而且在与一个大型团队合作时会变得非常困难。下面是一些工具及其使用方法，以及它们的配置文件。</p>
<img src="/posts/38979/38979/image-20221026165130441.png" class="" title="image-20221026165130441">

<h3 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h3><p>此文件用于以一致的方式格式化代码，并防止编辑器的默认代码格式化程序处理此文件。这主要用于开源项目中的一致性行为。</p>
<img src="/posts/38979/38979/image-20221026165254058.png" class="" title="image-20221026165254058">

<h3 id="prettier"><a href="#prettier" class="headerlink" title=".prettier"></a>.prettier</h3><p>这是一个名为 Prettier 的广泛使用的格式化扩展插件的配置文件。它与上面的文件类似，但不完全一样。这包含一组代码格式化规则，通常在保存文件后触发格式化程序时应用这些规则。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">   <span class="string">"trailingComma"</span>: <span class="string">"es5"</span>,</span><br><span class="line">   <span class="string">"tabWidth"</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="string">"semi"</span>: <span class="literal">false</span>,</span><br><span class="line">   <span class="string">"singleQuote"</span>: <span class="literal">true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="stylelintrc"><a href="#stylelintrc" class="headerlink" title=".stylelintrc"></a>.stylelintrc</h3><p>顾名思义，这个配置文件控制层叠样式表(CSS 文件)的格式</p>
<p>Stylelint 也可以使用预处理器ーー SCSS，LESS。</p>
<p>例如，如果任何属性使用的单位不是列出的单位，则下面的规则将引发错误。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{   </span><br><span class="line">  "rules": {     </span><br><span class="line">    "unit-allowed-list": ["em", "rem", "%"],   </span><br><span class="line">  } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="csslint"><a href="#csslint" class="headerlink" title=".csslint"></a>.csslint</h3><p>非常类似于 stylelintrc，但只适用于 CSS 文件。</p>
<h3 id="tailwind-config-js"><a href="#tailwind-config-js" class="headerlink" title=".tailwind.config.js"></a>.tailwind.config.js</h3><p>这属于一个名为 Tailwind 的 CSS 库</p>
<h3 id="postcss-config-js"><a href="#postcss-config-js" class="headerlink" title=".postcss.config.js"></a>.postcss.config.js</h3><p>在使用诸如 Tailwind 之类的 CSS 库时，在将代码发布到生产环境之前，我们还需要使用这些库转换和传递样式。Postcss 就是这样一个工具，这个文件包含样式的规则。</p>
<h3 id="eslint"><a href="#eslint" class="headerlink" title=".eslint"></a>.eslint</h3><p>与前面的非常相似，但是它关注的不仅仅是代码样式。它用于分析代码和检测代码质量问题。Eslint 同时使用 javascript 和 typescript。</p>
<p>例如，如果从未使用过变量，则下面的规则将给出一个错误</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"rules"</span>: {</span><br><span class="line">    <span class="string">"no-unused-vars"</span>: [<span class="string">"error"</span>, { <span class="string">"vars"</span>: <span class="string">"local"</span>, <span class="string">"args"</span>: <span class="string">"after-used"</span> }]</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通常，eslint和prettier一起使用，但只是为了代码质量和样式分别。</p>
<h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><p>所有的类型脚本文件最终都需要被编译成 javascript 文件，而这个配置文件保持了类型脚本编译器的行为。</p>
<p>例如，下面的规则将确保编译器将类型脚本文件转换为针对特定风格的 javascript，即 es6。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"compilerOptions"</span>: {</span><br><span class="line">    .</span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"es6"</span>  </span><br><span class="line">    . </span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="babel-config-js"><a href="#babel-config-js" class="headerlink" title="babel.config.js"></a>babel.config.js</h3><p>Babel 是一个免费的开源 JavaScript 转换器，主要用于将 ES6 + 代码转换为向后兼容的 JavaScript 代码，可以由旧的 JavaScript 引擎运行。</p>
<h2 id="Bundlers"><a href="#Bundlers" class="headerlink" title="Bundlers"></a>Bundlers</h2><p>在现代 Web 应用程序中，我们通常不编译 javascript 文件并直接使用它们。我们将所有的 javascript 模块绑定到一个文件中。</p>
<img src="/posts/38979/38979/image-20221026170043318.png" class="" title="image-20221026170043318">

<h3 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h3><p>这个配置文件属于 Webpack，一个静态模块捆绑器，它包含了 javascript 文件用于捆绑的目录、新文件的名称和路径的信息</p>
<p>还有其他广泛使用的捆绑包，如ーー Parcel (. parcelrc)、 Rollup (Rollup.config.js)、 Vite (Vite.config.js)和 Browserify。</p>
<h2 id="Packaging"><a href="#Packaging" class="headerlink" title="Packaging"></a>Packaging</h2><p>我们需要管理这些不同的库和模块并维护成一个列表。此外，我们还需要这些依赖项的版本。这就是包管理器的用武之地。这些管理员提供一个单一的入口点来维护项目中使用的所有包。一些包装管理器ーー NPM、yarn、 pnpm。</p>
<img src="/posts/38979/38979/image-20221026170400981.png" class="" title="image-20221026170400981">

<h3 id="Package-json"><a href="#Package-json" class="headerlink" title="Package.json"></a>Package.json</h3><p>这是您的node项目的核心。它记录关于项目及其依赖关系的重要元数据，并定义包管理器使用的功能属性。</p>
<h3 id="Package-lock-json"><a href="#Package-lock-json" class="headerlink" title="Package-lock.json"></a>Package-lock.json</h3><p>当您使用 npm 安装任何包时，它还会创建这个文件来维护您的依赖项及其依赖项、依赖项及其依赖项的列表..</p>
<p>这个文件不是我们可以编辑的。</p>
<h3 id="yarn-lock"><a href="#yarn-lock" class="headerlink" title="yarn.lock"></a>yarn.lock</h3><p>与 package-lock. json 类似，这个文件是在使用yarn作为包管理器时创建的。</p>
<h2 id="Hosting"><a href="#Hosting" class="headerlink" title="Hosting"></a>Hosting</h2><p>在某些时候，您可能希望将代码部署到某个地方，这里有一些与托管相关的文件。</p>
<img src="/posts/38979/38979/image-20221026170615206.png" class="" title="image-20221026170615206">

<h3 id="firebaserc"><a href="#firebaserc" class="headerlink" title=".firebaserc"></a>.firebaserc</h3><p>在 Firebase 上托管的项目的配置设置。</p>
<img src="/posts/38979/38979/image-20221026170702246.png" class="" title="image-20221026170702246">

<h3 id="netlify-toml"><a href="#netlify-toml" class="headerlink" title="netlify.toml"></a>netlify.toml</h3><p>承载在 Netlify 上的项目的配置设置。</p>
<h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><p>在将代码发送到生产环境之前，我们必须对代码进行测试。下面是一些工具和它们的配置文件，按照它们的测试类型分组:</p>
<img src="/posts/38979/38979/image-20221026170812816.png" class="" title="image-20221026170812816">

<h2 id="End-to-end-testing"><a href="#End-to-end-testing" class="headerlink" title="End-to-end testing"></a>End-to-end testing</h2><ul>
<li><a href="https://www.cypress.io/">Cypress</a> — cypress.config.js</li>
<li><a href="https://playwright.dev/">Playwright</a> — playwright.config.js</li>
</ul>
<h2 id="Unit-testing"><a href="#Unit-testing" class="headerlink" title="Unit testing"></a>Unit testing</h2><ul>
<li><a href="https://jestjs.io/">Jest</a> — jest.config.js</li>
<li><a href="https://vitest.dev/">Vitest</a> — vitest.config.js</li>
<li><a href="https://mochajs.org/">Mocha</a> — .mocharc</li>
</ul>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>最后，Git 用于维护项目中所有文件的版本。</p>
<img src="/posts/38979/38979/image-20221026171022495.png" class="" title="image-20221026171022495">

<h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>Git 用于维护一个文件或目录列表，以便在 git 回购中进行版本跟踪时忽略这些文件或目录。</p>
<h2 id="github"><a href="#github" class="headerlink" title=".github"></a>.github</h2><p>这是一个 git 目录，用于检查任何用于持续集成/持续部署(CI/CD)的 GitHub 操作。</p>
<img src="/posts/38979/38979/image-20221026171120897.png" class="" title="image-20221026171120897">

<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>这些是一些工具和配置文件，它们被领先的软件公司广泛用于网页开发。您可能会遇到与此列表具有类似配置文件的其他工具。</p>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>配置文件</tag>
      </tags>
  </entry>
</search>
