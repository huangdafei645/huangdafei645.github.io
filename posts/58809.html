<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"huangdafei645.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="非原始值的响应式方案vue2的实现：使Object数据变得“可观测”数据的每次读和写能够被我们看的见，即我们能够知道数据什么时候被读取了或数据什么时候被改写了，我们将其称为数据变的‘可观测’。">
<meta property="og:type" content="article">
<meta property="og:title" content="非原始值的响应式方案">
<meta property="og:url" content="http://huangdafei645.github.io/posts/58809.html">
<meta property="og:site_name" content="coder-Tom">
<meta property="og:description" content="非原始值的响应式方案vue2的实现：使Object数据变得“可观测”数据的每次读和写能够被我们看的见，即我们能够知道数据什么时候被读取了或数据什么时候被改写了，我们将其称为数据变的‘可观测’。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://huangdafei645.github.io/posts/58809/image-20221102073423099.png">
<meta property="og:image" content="http://huangdafei645.github.io/posts/58809/image-20221102074920068.png">
<meta property="article:published_time" content="2022-11-01T23:27:39.000Z">
<meta property="article:modified_time" content="2022-12-09T08:07:36.531Z">
<meta property="article:author" content="coder-Tom">
<meta property="article:tag" content="非原始值的响应式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://huangdafei645.github.io/posts/58809/image-20221102073423099.png">

<link rel="canonical" href="http://huangdafei645.github.io/posts/58809.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>非原始值的响应式方案 | coder-Tom</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">coder-Tom</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个喜欢代码， 音乐，读书， 跑步， 记录生活的程序员</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huangdafei645.github.io/posts/58809.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="coder-Tom">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="coder-Tom">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          非原始值的响应式方案
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-02 07:27:39" itemprop="dateCreated datePublished" datetime="2022-11-02T07:27:39+08:00">2022-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-09 16:07:36" itemprop="dateModified" datetime="2022-12-09T16:07:36+08:00">2022-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="非原始值的响应式方案"><a href="#非原始值的响应式方案" class="headerlink" title="非原始值的响应式方案"></a>非原始值的响应式方案</h1><h2 id="vue2的实现："><a href="#vue2的实现：" class="headerlink" title="vue2的实现："></a>vue2的实现：</h2><h3 id="使Object数据变得“可观测”"><a href="#使Object数据变得“可观测”" class="headerlink" title="使Object数据变得“可观测”"></a>使Object数据变得“可观测”</h3><p>数据的每次读和写能够被我们看的见，即我们能够知道数据什么时候被读取了或数据什么时候被改写了，我们将其称为数据变的‘可观测’。</p>
<span id="more"></span>

<p>要将数据变的‘可观测’，我们就要借助前言中提到的<code>Object.defineProperty</code>方法了，在本文中，我们就使用这个方法使数据变得“可观测”。</p>
<p>首先，我们定义一个数据对象<code>car</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = &#123;</span><br><span class="line">  <span class="string">&#x27;brand&#x27;</span>:<span class="string">&#x27;BMW&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;price&#x27;</span>:<span class="number">3000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了这个<code>car</code>的品牌<code>brand</code>是<code>BMW</code>,价格<code>price</code>是3000。现在我们可以通过<code>car.brand</code>和<code>car.price</code>直接读写这个<code>car</code>对应的属性值。但是，当这个<code>car</code>的属性被读取或修改时，我们并不知情。那么应该如何做才能够让<code>car</code>主动告诉我们，它的属性被修改了呢？</p>
<p>接下来，我们使用<code>Object.defineProperty()</code>改写上面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> val = <span class="number">3000</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(car, <span class="string">&#x27;price&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,     <span class="comment">//枚举</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;price属性被读取了&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newVal</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;price属性被修改了&#x27;</span>)</span><br><span class="line">    val = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过<code>Object.defineProperty()</code>方法给<code>car</code>定义了一个<code>price</code>属性，并把这个属性的读和写分别使用<code>get()</code>和<code>set()</code>进行拦截，每当该属性进行读或写操作的时候就会触发<code>get()</code>和<code>set()</code>。如下图：</p>
<img src="/posts/58809/image-20221102073423099.png" class title="image-20221102073423099">

<p>可以看到，<code>car</code>已经可以主动告诉我们它的属性的读写情况了，这也意味着，这个<code>car</code>的数据对象已经是“可观测”的了。</p>
<p>为了把<code>car</code>的所有属性都变得可观测，我们可以编写如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码位置：src/core/observer/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (value) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    <span class="comment">// 给value新增一个__ob__属性，值为该value的Observer实例</span></span><br><span class="line">    <span class="comment">// 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作</span></span><br><span class="line">    <span class="title function_">def</span>(value,<span class="string">&#x27;__ob__&#x27;</span>,<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">      <span class="comment">// 当value为数组时的逻辑</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">walk</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk (<span class="attr">obj</span>: <span class="title class_">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">defineReactive</span>(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使一个对象转化成可观测对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type"> Object </span>&#125; obj 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type"> String </span>&#125; key 对象的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type"> Any </span>&#125; val 对象的某个key的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span> (obj,key,val) &#123;</span><br><span class="line">  <span class="comment">// 如果只传了obj和key，那么val = obj[key]</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Observer</span>(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>属性被读取了`</span>);</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newVal</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(val === newVal)&#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>属性被修改了`</span>);</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们定义了<code>observer</code>类，它用来将一个正常的<code>object</code>转换成可观测的<code>object</code>。</p>
<p>并且给<code>value</code>新增一个<code>__ob__</code>属性，值为该<code>value</code>的<code>Observer</code>实例。这个操作相当于为<code>value</code>打上标记，表示它已经被转化成响应式了，避免重复操作</p>
<p>然后判断数据的类型，只有<code>object</code>类型的数据才会调用<code>walk</code>将每一个属性转换成<code>getter/setter</code>的形式来侦测变化。 最后，在<code>defineReactive</code>中当传入的属性值还是一个<code>object</code>时使用<code>new observer（val）</code>来递归子属性，这样我们就可以把<code>obj</code>中的所有属性（包括子属性）都转换成<code>getter/seter</code>的形式来侦测变化。 也就是说，只要我们将一个<code>object</code>传到<code>observer</code>中，那么这个<code>object</code>就会变成可观测的、响应式的<code>object</code>。</p>
<p><code>observer</code>类位于源码的<code>src/core/observer/index.js</code>中。</p>
<p>那么现在，我们就可以这样定义<code>car</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Observer</span>(&#123;</span><br><span class="line">  <span class="string">&#x27;brand&#x27;</span>:<span class="string">&#x27;BMW&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;price&#x27;</span>:<span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样，<code>car</code>的两个属性都变得可观测了。</p>
<h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><h4 id="什么是依赖收集"><a href="#什么是依赖收集" class="headerlink" title="什么是依赖收集"></a>什么是依赖收集</h4><p>在上一章中，我们迈出了第一步：让<code>object</code>数据变的可观测。变的可观测以后，我们就能知道数据什么时候发生了变化，那么当数据发生变化时，我们去通知视图更新就好了。那么问题又来了，视图那么大，我们到底该通知谁去变化？总不能一个数据变化了，把整个视图全部更新一遍吧，这样显然是不合理的。此时，你肯定会想到，视图里谁用到了这个数据就更新谁呗。对！你想的没错，就是这样。</p>
<p>视图里谁用到了这个数据就更新谁，我们换个优雅说法：我们把”谁用到了这个数据”称为”谁依赖了这个数据”,我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们：”你们依赖的数据变啦，你们该更新啦！”。这个过程就是依赖收集。</p>
<h4 id="何时收集依赖？何时通知依赖更新？"><a href="#何时收集依赖？何时通知依赖更新？" class="headerlink" title="何时收集依赖？何时通知依赖更新？"></a>何时收集依赖？何时通知依赖更新？</h4><p>明白了什么是依赖收集后，那么我们到底该在何时收集依赖？又该在何时通知依赖更新？</p>
<p>其实这个问题在上一小节中已经回答了，我们说过：谁用到了这个数据，那么当这个数据变化时就通知谁。所谓谁用到了这个数据，其实就是谁获取了这个数据，而可观测的数据被获取时会触发<code>getter</code>属性，那么我们就可以在<code>getter</code>中收集这个依赖。同样，当这个数据变化时会触发<code>setter</code>属性，那么我们就可以在<code>setter</code>中通知依赖更新。</p>
<p>总结一句话就是：<strong>在getter中收集依赖，在setter中通知依赖更新</strong>。</p>
<h4 id="把依赖收集到哪里"><a href="#把依赖收集到哪里" class="headerlink" title="把依赖收集到哪里"></a>把依赖收集到哪里</h4><p>明白了什么是依赖收集以及何时收集何时通知后，那么我们该把依赖收集到哪里？</p>
<p>我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。单单用一个数组来存放依赖的话，功能好像有点欠缺并且代码过于耦合。我们应该将依赖数组的功能扩展一下，更好的做法是我们应该为每一个数据都建立一个依赖管理器，把这个数据所有的依赖都管理起来。OK，到这里，我们的依赖管理器<code>Dep</code>类应运而生，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码位置：src/core/observer/dep.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除一个依赖</span></span><br><span class="line">  removeSub (sub) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">subs</span>, sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加一个依赖</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">addSub</span>(<span class="variable language_">window</span>.<span class="property">target</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知所有依赖更新</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove an item from an array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">remove</span> (arr, item) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = arr.<span class="title function_">indexOf</span>(item)</span><br><span class="line">    <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr.<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在上面的依赖管理器<code>Dep</code>类中，我们先初始化了一个<code>subs</code>数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作。</p>
<p>有了依赖管理器后，我们就可以在getter中收集依赖，在setter中通知依赖更新了，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span> (obj,key,val) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Observer</span>(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()  <span class="comment">//实例化一个依赖管理器，生成一个依赖管理数组dep</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">      dep.<span class="title function_">depend</span>()    <span class="comment">// 在getter中收集依赖</span></span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newVal</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(val === newVal)&#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      dep.<span class="title function_">notify</span>()   <span class="comment">// 在setter中通知依赖更新</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们在<code>getter</code>中调用了<code>dep.depend()</code>方法收集依赖，在<code>setter</code>中调用<code>dep.notify()</code>方法通知所有依赖更新。</p>
<h3 id="依赖到底是谁"><a href="#依赖到底是谁" class="headerlink" title="依赖到底是谁"></a>依赖到底是谁</h3><p>我们明白了什么是依赖？何时收集依赖？以及收集的依赖存放到何处？那么我们收集的依赖到底是谁？</p>
<p>虽然我们一直在说”谁用到了这个数据谁就是依赖“，但是这仅仅是在口语层面上，那么反应在代码上该如何来描述这个”谁“呢？</p>
<p>其实在<code>Vue</code>中还实现了一个叫做<code>Watcher</code>的类，而<code>Watcher</code>类的实例就是我们上面所说的那个”谁”。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的<code>Watch</code>实例，由<code>Watcher</code>实例去通知真正的视图。</p>
<p><code>Watcher</code>类的具体实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (vm,expOrFn,cb) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">target</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span>.<span class="property">vm</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">target</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, <span class="variable language_">this</span>.<span class="property">value</span>, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse simple path.</span></span><br><span class="line"><span class="comment"> * 把一个形如&#x27;data.a.b.c&#x27;的字符串路径所表示的值，从真实的data对象中取出来</span></span><br><span class="line"><span class="comment"> * 例如：</span></span><br><span class="line"><span class="comment"> * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125;</span></span><br><span class="line"><span class="comment"> * parsePath(&#x27;a.b.c&#x27;)(data)  // 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parsePath</span> (path) &#123;</span><br><span class="line">  <span class="keyword">if</span> (bailRE.<span class="title function_">test</span>(path)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> segments = path.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></span><br><span class="line">      obj = obj[segments[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>谁用到了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例，在创建<code>Watcher</code>实例的过程中会自动的把自己添加到这个数据对应的依赖管理器中，以后这个<code>Watcher</code>实例就代表这个依赖，当数据变化时，我们就通知<code>Watcher</code>实例，由<code>Watcher</code>实例再去通知真正的依赖。</p>
<p>那么，在创建<code>Watcher</code>实例的过程中它是如何的把自己添加到这个数据对应的依赖管理器中呢？</p>
<p>下面我们分析<code>Watcher</code>类的代码实现逻辑：</p>
<ol>
<li>当实例化<code>Watcher</code>类时，会先执行其构造函数；</li>
<li>在构造函数中调用了<code>this.get()</code>实例方法；</li>
<li>在<code>get()</code>方法中，首先通过<code>window.target = this</code>把实例自身赋给了全局的一个唯一对象<code>window.target</code>上，然后通过<code>let value = this.getter.call(vm, vm)</code>获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的<code>getter</code>，上文我们说过，在<code>getter</code>里会调用<code>dep.depend()</code>收集依赖，而在<code>dep.depend()</code>中取到挂载<code>window.target</code>上的值并将其存入依赖数组中，在<code>get()</code>方法最后将<code>window.target</code>释放掉。</li>
<li>而当数据变化时，会触发数据的<code>setter</code>，在<code>setter</code>中调用了<code>dep.notify()</code>方法，在<code>dep.notify()</code>方法中，遍历所有依赖(即watcher实例)，执行依赖的<code>update()</code>方法，也就是<code>Watcher</code>类中的<code>update()</code>实例方法，在<code>update()</code>方法中调用数据变化的更新回调函数，从而更新视图。</li>
</ol>
<p>简单总结一下就是：<code>Watcher</code>先把自己设置到全局唯一的指定位置（<code>window.target</code>），然后读取数据。因为读取了数据，所以会触发这个数据的<code>getter</code>。接着，在<code>getter</code>中就会从全局唯一的那个位置读取当前正在读取数据的<code>Watcher</code>，并把这个<code>watcher</code>收集到<code>Dep</code>中去。收集好之后，当数据发生变化时，会向<code>Dep</code>中的每个<code>Watcher</code>发送通知。通过这样的方式，<code>Watcher</code>可以主动去订阅任意一个数据的变化。为了便于理解，我们画出了其关系流程图，如下图：</p>
<img src="/posts/58809/image-20221102074920068.png" class title="image-20221102074920068">

<p>以上，就彻底完成了对<code>Object</code>数据的侦测，依赖收集，依赖的更新等所有操作</p>
<h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><p>虽然我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，但是这个方法仅仅只能观测到<code>object</code>数据的取值及设置值，当我们向<code>object</code>数据里添加一对新的<code>key/value</code>或删除一对已有的<code>key/value</code>时，它是无法观测到的，导致当我们对<code>object</code>数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。</p>
<p>当然，<code>Vue</code>也注意到了这一点，为了解决这一问题，<code>Vue</code>增加了两个全局API:<code>Vue.set</code>和<code>Vue.delete</code>，这两个API的实现原理将会在后面学习全局API的时候说到。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先，我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，并且封装了<code>Observer</code>类，让我们能够方便的把<code>object</code>数据中的所有属性（包括子属性）都转换成<code>getter/seter</code>的形式来侦测变化。</p>
<p>接着，我们学习了什么是依赖收集？并且知道了在<code>getter</code>中收集依赖，在<code>setter</code>中通知依赖更新，以及封装了依赖管理器<code>Dep</code>，用于存储收集到的依赖。</p>
<p>最后，我们为每一个依赖都创建了一个<code>Watcher</code>实例，当数据发生变化时，通知<code>Watcher</code>实例，由<code>Watcher</code>实例去做真实的更新操作。</p>
<p>其整个流程大致如下：</p>
<ol>
<li><code>Data</code>通过<code>observer</code>转换成了<code>getter/setter</code>的形式来追踪变化。</li>
<li>当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而将<code>Watcher</code>添加到依赖中。</li>
<li>当数据发生了变化时，会触发<code>setter</code>，从而向<code>Dep</code>中的依赖（即Watcher）发送通知。</li>
<li><code>Watcher</code>接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</li>
</ol>
<h2 id="vue3的实现："><a href="#vue3的实现：" class="headerlink" title="vue3的实现："></a>vue3的实现：</h2><h3 id="理解proxy和reflect"><a href="#理解proxy和reflect" class="headerlink" title="理解proxy和reflect"></a>理解proxy和reflect</h3><h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h4><p>简单地说，使用 Proxy 可以创建一个代理对象。它能够实现对其他对象 的代理，这里的关键词是其他对象，也就是说，Proxy 只能代理对象，无法代理非对象值，例如字符串、布尔值等。那么，代理指的是什么呢？所谓代理，指的是对一个对象基本语义的代理。它允许我们拦截并重新定义对一个对象的基本操作。这句话的关键词比较多，我们逐一解释。</p>
<p>什么是基本语义？给出一个对象 obj，可以对它进行一些操作， 例如读取属性值、设置属性值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> obj.<span class="property">foo</span> <span class="comment">// 读取属性 foo 的值</span></span><br><span class="line"><span class="number">02</span> obj.<span class="property">foo</span>++ <span class="comment">// 读取和设置属性 foo 的值</span></span><br></pre></td></tr></table></figure>

<p>Proxy定义: 用于定义基本操作的自定义行为</p>
<p><code>proxy</code>修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程(<code>meta</code> <code>programming</code>)</p>
<ul>
<li><strong>元编程（英语：Metaprogramming</strong>，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作</li>
</ul>
<p>一段代码来理解元编程:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># metaprogram</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;#!/bin/bash&#x27;</span> &gt;program</span><br><span class="line"><span class="keyword">for</span> ((I=<span class="number">1</span>; I&lt;=<span class="number">1024</span>; I++)) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;echo <span class="variable">$I</span>&quot;</span> &gt;&gt;program</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">chmod</span> +x program</span><br></pre></td></tr></table></figure>

<p>这段程序每执行一次能帮我们生成一个名为program的文件，文件内容为1024行<code>echo</code>，如果我们手动来写1024行代码，效率显然低效</p>
<p><strong>元编程优点</strong>：与手工编写全部代码相比，程序员可以获得更高的工作效率，或者给与程序更大的灵活度去处理新的情形而无需重新编译</p>
<p><code>proxy</code> 译为代理，可以理解为在操作目标对象前架设一层代理，将所有本该我们手动编写的程序交由代理来处理，生活中也有许许多多的“proxy”, 如代购，中介，因为他们所有的行为都不会直接触达到目标对象</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul>
<li>target 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理</li>
<li>handler 一个通常以函数作为属性的对象，用来定制拦截行为</li>
</ul>
<p>类似这种读取、设置属性值的操作，就属于基本语义的操作，即 基本操作。既然是基本操作，那么它就可以使用 Proxy 拦截：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"><span class="number">02</span> <span class="comment">// 拦截读取属性操作</span></span><br><span class="line"><span class="number">03</span> <span class="title function_">get</span>(<span class="params"></span>) &#123; <span class="comment">/*...*/</span> &#125;,</span><br><span class="line"><span class="number">04</span> <span class="comment">// 拦截设置属性操作</span></span><br><span class="line"><span class="number">05</span> <span class="title function_">set</span>(<span class="params"></span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"><span class="number">06</span> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如以上代码所示，Proxy 构造函数接收两个参数。第一个参数是 被代理的对象，第二个参数也是一个对象，这个对象是一组夹子 （trap）。其中 get 函数用来拦截读取操作，set 函数用来拦截设置 操作。 </p>
<p>在 JavaScript 的世界里，万物皆对象。例如一个函数也是一个对 象，所以调用函数也是对一个对象的基本操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">name</span>) =&gt; &#123;</span><br><span class="line"><span class="number">02</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是：&#x27;</span>, name)</span><br><span class="line"><span class="number">03</span> &#125;</span><br><span class="line"><span class="number">04</span></span><br><span class="line"><span class="number">05</span> <span class="comment">// 调用函数是对对象的基本操作</span></span><br><span class="line"><span class="number">06</span> <span class="title function_">fn</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此，我们可以用 Proxy 来拦截函数的调用操作，这里我们使用 apply 拦截函数的调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(fn, &#123;</span><br><span class="line"><span class="number">02</span> <span class="comment">// 使用 apply 拦截函数调用</span></span><br><span class="line"><span class="number">03</span> <span class="title function_">apply</span>(<span class="params">target, thisArg, argArray</span>) &#123;</span><br><span class="line"><span class="number">04</span> target.<span class="title function_">call</span>(thisArg, ...argArray)</span><br><span class="line"><span class="number">05</span> &#125;</span><br><span class="line"><span class="number">06</span> &#125;)</span><br><span class="line"><span class="number">07</span></span><br><span class="line"><span class="number">08</span> <span class="title function_">p2</span>(<span class="string">&#x27;hcy&#x27;</span>) <span class="comment">// 输出：&#x27;我是：hcy&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面两个例子说明了什么是基本操作。Proxy 只能够拦截对一个 对象的基本操作。那么，什么是非基本操作呢？其实调用对象下的方 法就是典型的非基本操作，我们叫它复合操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> obj.<span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure>

<p>实际上，调用一个对象下的方法，是由两个基本语义组成的。第一个基本语义是 get，即先通过 get 操作得到 obj.fn 属性。第二个基本语义是函数调用，即通过 get 得到 obj.fn 的值后再调用它，也就是我们上面说到的 apply。理解 Proxy 只能够代理对象的基本语义 很重要，后续我们讲解如何实现对数组或 Map、Set 等数据类型的代 理时，都利用了 Proxy 的这个特点。</p>
<h4 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h4><p>理解了 Proxy，我们再来讨论 Reflect。Reflect 是一个全局对象，其下有许多方法，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>()</span><br><span class="line"><span class="number">02</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>()</span><br><span class="line"><span class="number">03</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>()</span><br><span class="line"><span class="number">04</span> <span class="comment">// ...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你可能已经注意到了，Reflect 下的方法与 Proxy 的拦截器方 法名字相同，其实这不是偶然。任何在 Proxy 的拦截器中能够找到的 方法，都能够在 Reflect 中找到同名函数，那么这些函数的作用是什 么呢？其实它们的作用一点儿都不神秘。拿 Reflect.get 函数来 说，它的功能就是提供了访问一个对象属性的默认行为，例如下面两 个操作是等价的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="number">02</span></span><br><span class="line"><span class="number">03</span> <span class="comment">// 直接读取</span></span><br><span class="line"><span class="number">04</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="number">05</span> <span class="comment">// 使用 Reflect.get 读取</span></span><br><span class="line"><span class="number">06</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(obj, <span class="string">&#x27;foo&#x27;</span>)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>可能有的读者会产生疑问：既然操作等价，那么它存在的意义是 什么呢？实际上 Reflect.get 函数还能接收第三个参数，即指定接 收者 receiver，你可以把它理解为函数调用过程中的 this，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="number">02</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(obj, <span class="string">&#x27;foo&#x27;</span>, &#123; <span class="attr">foo</span>: <span class="number">2</span> &#125;)) <span class="comment">// 输出的是 2 而</span></span><br><span class="line">不是 <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们指定第三个参数 receiver 为一个对象 { foo: 2 }，这时读取到的值是 receiver 对象的 foo 属性值。实际 上，Reflect.* 方法还有很多其他方面的意义，但这里我们只关心并 讨论这一点，因为它与响应式数据的实现密切相关。为了说明问题， 回顾一下在上一节中实现响应式数据的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="number">02</span></span><br><span class="line"><span class="number">03</span> <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"><span class="number">04</span> <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line"><span class="number">05</span> <span class="title function_">track</span>(target, key)</span><br><span class="line"><span class="number">06</span> <span class="comment">// 注意，这里我们没有使用 Reflect.get 完成读取</span></span><br><span class="line"><span class="number">07</span> <span class="keyword">return</span> target[key]</span><br><span class="line"><span class="number">08</span> &#125;,</span><br><span class="line"><span class="number">09</span> <span class="title function_">set</span>(<span class="params">target, key, newVal</span>) &#123;</span><br><span class="line"><span class="number">10</span> <span class="comment">// 这里同样没有使用 Reflect.set 完成设置</span></span><br><span class="line"><span class="number">11</span> target[key] = newVal</span><br><span class="line"><span class="number">12</span> <span class="title function_">trigger</span>(target, key)</span><br><span class="line"><span class="number">13</span> &#125;</span><br><span class="line"><span class="number">14</span> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是上一章中用来实现响应式数据的最基本的代码。在 get 和 set 拦截函数中，我们都是直接使用原始对象 target 来完成对属性 的读取和设置操作的，其中原始对象 target 就是上述代码中的 obj 对象。 那么这段代码有什么问题吗？我们借助 effect 让问题暴露出 来。首先，我们修改一下 obj 对象，为它添加 bar 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> obj = &#123;</span><br><span class="line"><span class="number">02</span>   <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line"><span class="number">03</span>   <span class="keyword">get</span> <span class="title function_">bar</span>() &#123;</span><br><span class="line"><span class="number">04</span>      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span></span><br><span class="line"><span class="number">05</span>   &#125;</span><br><span class="line"><span class="number">06</span> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，bar 属性是一个访问器属性，它返回了 this.foo 属 性的值。接着，我们在 effect 副作用函数中通过代理对象 p 访问 bar 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="number">02</span> 		<span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">bar</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="number">03</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>我们来分析一下这个过程发生了什么。当 effect 注册的副作用 函数执行时，会读取 p.bar 属性，它发现 p.bar 是一个访问器属 性，因此执行 getter 函数。由于在 getter 函数中通过 this.foo 读取了 foo 属性值，因此我们认为副作用函数与属性 foo 之间也会建 立联系。当我们修改 p.foo 的值时应该能够触发响应，使得副作用函 数重新执行才对。然而实际并非如此，当我们尝试修改 p.foo 的值 时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01 p.foo++</span><br></pre></td></tr></table></figure>

<p>副作用函数并没有重新执行，问题出在哪里呢？ 实际上，问题就出在 bar 属性的访问器函数 getter 里：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> obj = &#123;</span><br><span class="line"><span class="number">02</span> 		<span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line"><span class="number">03</span> 		<span class="keyword">get</span> <span class="title function_">bar</span>() &#123;</span><br><span class="line"><span class="number">04</span> 			<span class="comment">// 这里的 this 指向的是谁？</span></span><br><span class="line"><span class="number">05</span> 			<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span></span><br><span class="line"><span class="number">06</span> 		&#125;</span><br><span class="line"><span class="number">07</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们使用 this.foo 读取 foo 属性值时，这里的 this 指向的 是谁呢？我们回顾一下整个流程。首先，我们通过代理对象 p 访问 p.bar，这会触发代理对象的 get 拦截函数执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"><span class="number">02</span> 	  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line"><span class="number">03</span> 		<span class="title function_">track</span>(target, key)</span><br><span class="line"><span class="number">04</span> 		<span class="comment">// 注意，这里我们没有使用 Reflect.get 完成读取</span></span><br><span class="line"><span class="number">05</span> 		<span class="keyword">return</span> target[key]</span><br><span class="line"><span class="number">06</span> 	  &#125;,</span><br><span class="line"><span class="number">07</span>    <span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="number">08</span> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 get 拦截函数内，通过 target[key] 返回属性值。其中 target 是原始对象 obj，而 key 就是字符串 ‘bar’，所以 target[key] 相当于 obj.bar。因此，当我们使用 p.bar 访问 bar 属性时，它的 getter 函数内的 this 指向的其实是原始对象 obj， 这说明我们最终访问的其实是 obj.foo。很显然，在副作用函数内通 过原始对象访问它的某个属性是不会建立响应联系的，这等价于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="number">02</span> 		<span class="comment">// obj 是原始数据，不是代理对象，这样的访问不能够建立响应联系</span></span><br><span class="line"><span class="number">03</span> 		obj.<span class="property">foo</span></span><br><span class="line"><span class="number">04</span> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为这样做不会建立响应联系，所以出现了无法触发响应的问 题。那么这个问题应该如何解决呢？这时 Reflect.get 函数就派上 用场了。先给出解决问题的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"><span class="number">02</span> 		<span class="comment">// 拦截读取操作，接收第三个参数 receiver</span></span><br><span class="line"><span class="number">03</span> 		<span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line"><span class="number">04</span> 			<span class="title function_">track</span>(target, key)</span><br><span class="line"><span class="number">05</span> 			<span class="comment">// 使用 Reflect.get 返回读取到的属性值</span></span><br><span class="line"><span class="number">06</span> 				<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line"><span class="number">07</span> 		&#125;,</span><br><span class="line"><span class="number">08</span> 		<span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="number">09</span> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上面的代码所示，代理对象的 get 拦截函数接收第三个参数 receiver，它代表谁在读取属性，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> p.<span class="property">bar</span> <span class="comment">// 代理对象 p 在读取 bar 属性</span></span><br></pre></td></tr></table></figure>

<p>当我们使用代理对象 p 访问 bar 属性时，那么 receiver 就是 p，你可以把它简单地理解为函数调用中的 this。接着关键的一步发 生了，我们使用 Reflect.get(target, key, receiver) 代替 之前的 target[key]，这里的关键点就是第三个参数 receiver。 我们已经知道它就是代理对象 p，所以访问器属性 bar 的 getter 函 数内的 this 指向代理对象 p：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">const</span> obj = &#123;</span><br><span class="line"><span class="number">02</span> 		<span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line"><span class="number">03</span> 		<span class="keyword">get</span> <span class="title function_">bar</span>() &#123;</span><br><span class="line"><span class="number">04</span> 			<span class="comment">// 现在这里的 this 为代理对象 p</span></span><br><span class="line"><span class="number">05</span> 			<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span></span><br><span class="line"><span class="number">06</span> 		&#125;</span><br><span class="line"><span class="number">07</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，this 由原始对象 obj 变成了代理对象 p。很显然，这 会在副作用函数与响应式数据之间建立响应联系，从而达到依赖收集 的效果。如果此时再对 p.foo 进行自增操作，会发现已经能够触发副 作用函数重新执行了。</p>
<h3 id="Handler-对象常用的方法"><a href="#Handler-对象常用的方法" class="headerlink" title="Handler 对象常用的方法"></a>Handler 对象常用的方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>handler.has()</td>
<td>in 操作符的捕捉器。</td>
</tr>
<tr>
<td>handler.get()</td>
<td>属性读取操作的捕捉器。</td>
</tr>
<tr>
<td>handler.set()</td>
<td>属性设置操作的捕捉器。</td>
</tr>
<tr>
<td>handler.deleteProperty()</td>
<td>delete 操作符的捕捉器。</td>
</tr>
<tr>
<td>handler.ownKeys()</td>
<td>Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。</td>
</tr>
<tr>
<td>handler.apply()</td>
<td>函数调用操作的捕捉器。</td>
</tr>
<tr>
<td>handler.construct()</td>
<td>new 操作符的捕捉器</td>
</tr>
</tbody></table>
<p>下面挑<code>handler.get</code>重点讲一下，其它方法的使用也都大同小异，不同的是参数的区别</p>
<h4 id="handler-get"><a href="#handler-get" class="headerlink" title="handler.get"></a>handler.get</h4><p><code>get</code>我们在上面例子已经体验过了，现在详细介绍一下，用于代理目标对象的属性读取操作</p>
<p>授受三个参数 <code>get(target, propKey, ?receiver)</code></p>
<ul>
<li>target 目标对象</li>
<li>propkey 属性名</li>
<li>receiver Proxy 实例本身</li>
</ul>
<p><strong>举个例子</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">like</span>: <span class="string">&quot;vuejs&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (propKey <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[propKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(<span class="string">&quot;Prop name \&quot;&quot;</span> + propKey + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">like</span> <span class="comment">// vuejs</span></span><br><span class="line">obj.<span class="property">test</span> <span class="comment">// Uncaught ReferenceError: Prop name &quot;test&quot; does not exist.</span></span><br></pre></td></tr></table></figure>

<p>上面的代码表示在读取代理目标的值时，如果有值则直接返回，没有值就抛出一个自定义的错误</p>
<p><strong>注意:</strong></p>
<ul>
<li>如果要访问的目标属性是不可写以及不可配置的，则返回的值必须与该目标属性的值相同</li>
<li>如果要访问的目标属性没有配置访问方法，即get方法是undefined的，则返回值必须为undefined</li>
</ul>
<p>如下面的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;a&quot;</span>, &#123; </span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>, </span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>, </span><br><span class="line">  <span class="attr">value</span>: <span class="number">10</span>, </span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span> </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="property">a</span> <span class="comment">// Uncaught TypeError: &#x27;get&#x27; on proxy: property &#x27;a&#x27; is a read-only and non-configurable..</span></span><br></pre></td></tr></table></figure>

<h3 id="可撤消的Proxy"><a href="#可撤消的Proxy" class="headerlink" title="可撤消的Proxy"></a>可撤消的Proxy</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy`有一个唯一的静态方法，`Proxy.revocable(target, handler)</span><br></pre></td></tr></table></figure>

<p><code>Proxy.revocable()</code>方法可以用来创建一个可撤销的代理对象</p>
<p>该方法的返回值是一个对象，其结构为： <code>&#123;&quot;proxy&quot;: proxy, &quot;revoke&quot;: revoke&#125;</code></p>
<ul>
<li>proxy 表示新生成的代理对象本身，和用一般方式 new Proxy(target, handler) 创建的代理对象没什么不同，只是它可以被撤销掉。</li>
<li>revoke 撤销方法，调用的时候不需要加任何参数，就可以撤销掉和它一起生成的那个代理对象。</li>
</ul>
<p>该方法常用于完全封闭对目标对象的访问, 如下示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">name</span>: <span class="string">&#x27;vuejs&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;proxy, revoke&#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler)</span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// 正常取值输出 vuejs</span></span><br><span class="line"><span class="title function_">revoke</span>() <span class="comment">// 取值完成对proxy进行封闭，撤消代理</span></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure>

<h3 id="Proxy的应用场景"><a href="#Proxy的应用场景" class="headerlink" title="Proxy的应用场景"></a>Proxy的应用场景</h3><p><code>Proxy</code>的应用范围很广，下方列举几个典型的应用场景</p>
<h4 id="校验器"><a href="#校验器" class="headerlink" title="校验器"></a><strong>校验器</strong></h4><p>想要一个<code>number</code>，拿回来的却是<code>string</code>，惊不惊喜？意不意外？下面我们使用<code>Proxy</code>实现一个逻辑分离的数据格式验证器</p>
<p>嗯，真香!</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">_id</span>: <span class="string">&#x27;1024&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>:  <span class="string">&#x27;vuejs&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validators = &#123;  </span><br><span class="line">    <span class="title function_">name</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">_id</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;number&#x27;</span> &amp;&amp; val &gt; <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createValidator</span> = (<span class="params">target, validator</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="attr">_validator</span>: validator,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, propkey, value, proxy</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> validator = <span class="variable language_">this</span>.<span class="property">_validator</span>[propkey](value)</span><br><span class="line">      <span class="keyword">if</span>(validator)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, propkey, value, proxy)</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">`Cannot set <span class="subst">$&#123;propkey&#125;</span> to <span class="subst">$&#123;value&#125;</span>. Invalid type.`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">createValidator</span>(target, validators)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;vue-js.com&#x27;</span> <span class="comment">// vue-js.com</span></span><br><span class="line">proxy.<span class="property">name</span> = <span class="number">10086</span> <span class="comment">// Uncaught Error: Cannot set name to 10086. Invalid type.</span></span><br><span class="line">proxy.<span class="property">_id</span> = <span class="number">1025</span> <span class="comment">// 1025</span></span><br><span class="line">proxy.<span class="property">_id</span> = <span class="number">22</span>  <span class="comment">// Uncaught Error: Cannot set _id to 22. Invalid type </span></span><br></pre></td></tr></table></figure>

<h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><p>在日常编写代码的过程中，我们想定义一些私有属性，通常是在团队中进行约定，大家按照约定在变量名之前添加下划线 _ 或者其它格式来表明这是一个私有属性，但我们不能保证他能真私‘私有化’，下面使用Proxy轻松实现私有属性拦截</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">_id</span>: <span class="string">&#x27;1024&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>:  <span class="string">&#x27;vuejs&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, propkey, proxy</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(propkey[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">$&#123;propkey&#125;</span> is restricted`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propkey, proxy)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, propkey, value, proxy</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(propkey[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">$&#123;propkey&#125;</span> is restricted`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, propkey, value, proxy)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// vuejs</span></span><br><span class="line">proxy.<span class="property">_id</span> <span class="comment">// Uncaught Error: _id is restricted</span></span><br><span class="line">proxy.<span class="property">_id</span> = <span class="string">&#x27;1025&#x27;</span> <span class="comment">// Uncaught Error: _id is restricted</span></span><br></pre></td></tr></table></figure>

<p><code>Proxy</code> 使用场景还有很多很多，不再一一列举，如果你需要在某一个动作的生命周期内做一些特定的处理，那么<code>Proxy</code> 都是适合的</p>
<h3 id="为什么要用Proxy重构"><a href="#为什么要用Proxy重构" class="headerlink" title="为什么要用Proxy重构"></a>为什么要用Proxy重构</h3><p>在 <code>Proxy</code> 之前，<code>JavaScript</code> 中就提供过 <code>Object.defineProperty</code>，允许对对象的 <code>getter/setter</code> 进行拦截</p>
<p>Vue3.0之前的双向绑定是由 <code>defineProperty</code> 实现, 在3.0重构为 <code>Proxy</code>，那么两者的区别究竟在哪里呢？</p>
<p>首先我们再来回顾一下它的定义</p>
<blockquote>
<p>Object.defineProperty() 方法会直接在一个<strong>对象上</strong>定义一个<strong>新属性</strong>，或者修改一个对象的现有属性，并返回此对象</p>
</blockquote>
<p>上面给两个词划了重点，<strong>对象上</strong>，<strong>属性</strong>，我们可以理解为是针对对象上的某一个属性做处理的</p>
<p><strong>语法</strong></p>
<ul>
<li>obj 要定义属性的对象</li>
<li>prop 要定义或修改的属性的名称或 Symbol</li>
<li>descriptor 要定义或修改的属性描述符</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, descriptor)</span><br></pre></td></tr></table></figure>

<p>举个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  value : <span class="number">1</span>,</span><br><span class="line">  writable : <span class="literal">false</span>, <span class="comment">// 是否可写 </span></span><br><span class="line">  configurable : <span class="literal">false</span>, <span class="comment">// 是否可配置</span></span><br><span class="line">  enumerable : <span class="literal">false</span> <span class="comment">// 是否可枚举</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面给了三个false, 下面的相关操作就很容易理解了</span></span><br><span class="line">obj.<span class="property">a</span> = <span class="number">2</span> <span class="comment">// 无效</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">a</span> <span class="comment">// 无效</span></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key) <span class="comment">// 无效 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>一个优秀的开源框架本身就是一个不断打碎重朔的过程，上面做了些许铺垫，现在我们简要总结一下</p>
<ul>
<li><code>Proxy</code> 作为新标准将受到浏览器厂商重点持续的性能优化</li>
<li><code>Proxy</code> 能观察的类型比 <code>defineProperty</code> 更丰富</li>
<li><code>Proxy</code> 不兼容IE，也没有 <code>polyfill</code>, <code>defineProperty</code> 能支持到IE9</li>
<li><code>Object.definedProperty</code> 是劫持对象的属性，新增元素需要再次 <code>definedProperty</code>。而 <code>Proxy</code> 劫持的是整个对象，不需要做特殊处理</li>
<li>使用 <code>defineProperty</code> 时，我们修改原来的 <code>obj</code> 对象就可以触发拦截，而使用 <code>proxy</code>，就必须修改代理对象，即 <code>Proxy</code> 的实例才可以触发拦截</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%9E%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F/" rel="tag"># 非原始值的响应式</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/11481.html" rel="prev" title="说说vue中的diff算法">
      <i class="fa fa-chevron-left"></i> 说说vue中的diff算法
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/5373.html" rel="next" title="谈谈你对axios封装的理解">
      谈谈你对axios封装的理解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81NzMxMy8zMzc3Nw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%9E%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E6%96%B9%E6%A1%88"><span class="nav-number">1.</span> <span class="nav-text">非原始值的响应式方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#vue2%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">vue2的实现：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BFObject%E6%95%B0%E6%8D%AE%E5%8F%98%E5%BE%97%E2%80%9C%E5%8F%AF%E8%A7%82%E6%B5%8B%E2%80%9D"><span class="nav-number">1.1.1.</span> <span class="nav-text">使Object数据变得“可观测”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86"><span class="nav-number">1.1.2.</span> <span class="nav-text">依赖收集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">什么是依赖收集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E6%94%B6%E9%9B%86%E4%BE%9D%E8%B5%96%EF%BC%9F%E4%BD%95%E6%97%B6%E9%80%9A%E7%9F%A5%E4%BE%9D%E8%B5%96%E6%9B%B4%E6%96%B0%EF%BC%9F"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">何时收集依赖？何时通知依赖更新？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%8A%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E5%88%B0%E5%93%AA%E9%87%8C"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">把依赖收集到哪里</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%88%B0%E5%BA%95%E6%98%AF%E8%B0%81"><span class="nav-number">1.1.3.</span> <span class="nav-text">依赖到底是谁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84"><span class="nav-number">1.1.4.</span> <span class="nav-text">不足之处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue3%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">vue3的实现：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3proxy%E5%92%8Creflect"><span class="nav-number">1.2.1.</span> <span class="nav-text">理解proxy和reflect</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#proxy"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">proxy</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">1.2.1.1.1.</span> <span class="nav-text">语法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reflect"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">reflect</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Handler-%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.2.</span> <span class="nav-text">Handler 对象常用的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#handler-get"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">handler.get</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E6%92%A4%E6%B6%88%E7%9A%84Proxy"><span class="nav-number">1.2.3.</span> <span class="nav-text">可撤消的Proxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.4.</span> <span class="nav-text">Proxy的应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%A1%E9%AA%8C%E5%99%A8"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">校验器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="nav-number">1.2.5.</span> <span class="nav-text">私有属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Proxy%E9%87%8D%E6%9E%84"><span class="nav-number">1.2.6.</span> <span class="nav-text">为什么要用Proxy重构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94"><span class="nav-number">1.3.</span> <span class="nav-text">对比</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="coder-Tom"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">coder-Tom</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">96</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">95</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huangdafei645" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huangdafei645" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1635482898@qq.com" title="E-Mail → mailto:1635482898@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/@huangdafei11" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;@huangdafei11" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/Dafei%20Huang" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;Dafei Huang" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>FB Page</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">coder-Tom</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '84px',
  right: 'unset',
  left: '22px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

    </div>
</body>
</html>
